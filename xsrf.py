#!/usr/bin/env python3
import argparse
import glob
import logging
import os
import re
import requests
import subprocess
import sys

OSS_FUZZ_BUGURL = "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id="
DOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='

testcase_pattern = re.compile(r'https://oss-fuzz\.com/testcase\?key=(\d+)')
proto_pattern = r'\bFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\b'                    

parser = argparse.ArgumentParser()
parser.add_argument("--debug", action="store_true", help="Enable verbose logging")
parser.add_argument("--cookie-file", "-c", help="File containing cookie value")

# Pass through options
reporter_params = [
    ("report", None),
    ("timeout", int),
    ("memlimit", int),
    ("memleaks", None),
]
for name, arg_type in reporter_params:
    args = ["--" + name]
    kwargs = {}
    if arg_type:
        kwargs["type"] = arg_type
    else:
        kwargs["action"] = "store_true"
    kwargs["default"] = None
    kwargs["help"] = "Option is passed to the reporter"
    parser.add_argument(*args, **kwargs)
parser.add_argument("--reporter-args", "-r", help="Options to pass through")


parser.add_argument("issue_id", type=int)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)

def fatal(*args):
    logging.error(*args)
    sys.exit(1)

def parse_cookies(text):
    cookies = {}
    for m in re.finditer(r'(SACSID)\s+(~[0-9a-zA-Z_-]+)\s+([a-z.-]+)(?:\s|$)', text):
        key, value, domain = m.groups()
        cookies[domain] = (key, value)
    # compatibility with Netscape cookie jar
    garbage = r'(?:TRUE|FALSE)\s+/\s+(?:TRUE|FALSE)\s+\d+\s+'
    cj_pattern = r'([a-z.-]+)\s+' + garbage + r'(SACSID)\s+(~[0-9a-zA-Z_-]+)(?:\s+|$)'
    for m in re.finditer(cj_pattern, text):
        domain, key, value = m.groups()
        cookies[domain] = (key, value)
    if any(not d in cookies for d in ["bugs.chromium.org", "oss-fuzz.com"]):
        fatal("Missing domains, got: %s", " ".join(cookies.keys()))
    return cookies

cookie_file = args.cookie_file
if not cookie_file:
    # TODO maybe fallback to a default location?
    parser.error("Missing cookie file")
sid_cookies = parse_cookies(open(cookie_file).read().strip())

session = requests.Session()
for domain, (key, value) in sid_cookies.items():
    session.cookies.set(key, value, domain=domain)

# Fetch bug contents
issue_id = str(args.issue_id)
bugurl = OSS_FUZZ_BUGURL + issue_id
r = session.get(bugurl)
r.raise_for_status()

# Look for ID
pat = re.search(testcase_pattern, r.text)
if not pat:
    fatal('Cannot find testcase ID')
testcase_id = pat.group(1)

# Look for type (IP, etc.)
pat = re.search(proto_pattern, r.text)
if not pat:
    # XXX maybe assume IP?
    fatal('Protocol not found')
protocol = pat.group(1)

attachment_name = None
# Try to locate existing file
for prefix in ["clusterfuzz-testcase-minimized-", "clusterfuzz-testcase-"]:
    for suffix in ['', '.pcap']:
        name = prefix + testcase_id + suffix
        if os.path.exists(name):
            attachment_name = name
            break

# Download the attachment if missing
if attachment_name is None:
    att_url = DOWNLOAD_URL + testcase_id
    r = session.get(att_url, stream=True)
    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])
    if not pat:
        fatal('Cannot parse header: %s', r.headers['content-disposition'])
    attachment_name = pat.group(1)
    try:
        # Open without overwriting existing contents.
        with open(attachment_name, 'xb') as f:
            for chunk in r.iter_content(chunk_size=4096):
                f.write(chunk)
        logging.info("Downloaded: %s", attachment_name)
    except FileExistsError:
        # Ignore existing file.
        pass

cmd = [
    "oss-fuzz-report.py",
    "--proto", protocol,
    attachment_name,
    issue_id
]
if args.reporter_args:
    cmd += args.reporter_args.split()
for name, arg_type in reporter_params:
    value = getattr(args, name)
    if value is not None:
        cmd.append("--" + name)
        if arg_type:
            cmd.append(str(value))
print(' '.join(cmd))

os.execvp(cmd[0], cmd)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

import os
from core.colors import *
from files.config import *
from core.verbout import verbout
from files.discovered import INTERNAL_URLS, FILES_EXEC, SCAN_ERRORS
from files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS                    

def logger(filename, content):
    '''
    This module is for logging all the stuff we found
            while crawling and scanning.
    '''
    output_file = OUTPUT_DIR + filename + '.log'
    with open(output_file, 'w+', encoding='utf8') as f:
        if type(content) is tuple or type(content) is list:
            for m in content:  # if it is list or tuple, it is iterable
                f.write(m+'\n')
        else:
            f.write(content)  # else we write out as it is... ;)
        f.write('\n')

def pheaders(tup):
    '''
    This module prints out the headers as received in the
                    requests normally.
    '''
    verbout(GR, 'Receiving headers...\n')
    verbout(color.GREY,'  '+color.UNDERLINE+'HEADERS'+color.END+color.GREY+':'+'\n')
    for key, val in tup.items():
        verbout('  ',color.CYAN+key+': '+color.ORANGE+val)
    verbout('','')

def GetLogger():
    if INTERNAL_URLS:
        logger('internal-links', INTERNAL_URLS)
    if SCAN_ERRORS:
        logger('errored', SCAN_ERRORS)
    if FILES_EXEC:
        logger('files-found', FILES_EXEC)
    if REQUEST_TOKENS:
        logger('anti-csrf-tokens', REQUEST_TOKENS)
    if FORMS_TESTED:
        logger('forms-tested', FORMS_TESTED)
    if VULN_LIST:
        logger('vulnerabilities', VULN_LIST)

def ErrorLogger(url, error):
    con = '(i) '+url+' -> '+error.__str__()
    SCAN_ERRORS.append(con)

def VulnLogger(url, vuln):
    tent = '[!] '+url+' -> '+vuln
    VULN_LIST.append(tent)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

# Importing stuff
import argparse, sys, tld
import urllib.parse, os
from files import config
from core.colors import R, G
from core.updater import updater

# Processing command line arguments
parser = argparse.ArgumentParser('python3 xsrfprobe.py')
parser._action_groups.pop()

# A simple hack to have required argumentsa and optional arguments separately
required = parser.add_argument_group('Required Arguments')
optional = parser.add_argument_group('Optional Arguments')

# Required Options
required.add_argument('-u', '--url', help='Main URL to test', dest='url')

# Optional Arguments (main stuff and necessary)
optional.add_argument('-c', '--cookie', help='Cookie value to be requested with each successive request. If there are multiple cookies, separate them with commas. For example: `-c PHPSESSID=i837c5n83u4, _gid=jdhfbuysf`.', dest='cookie')
optional.add_argument('-o', '--output', help='Output directory where files to be stored. Default is the`files` folder where all files generated will be stored.', dest='output')
optional.add_argument('-d', '--delay', help='Time delay between requests in seconds. Default is zero.', dest='delay', type=float)
optional.add_argument('-q', '--quiet', help='Set the DEBUG mode to quiet. Report only when vulnerabilities are found. Minimal output will be printed on screen. ', dest='quiet', action='store_true')
optional.add_argument('-v', '--verbose', help='Increase the verbosity of the output (e.g., -vv is more than -v). ', dest='verbose', action='store_true')

# Other Options
# optional.add_argument('-h', '--help', help='Show this help message and exit', dest='disp', default=argparse.SUPPRESS, action='store_true')
optional.add_argument('--user-agent', help='Custom user-agent to be used. Only one user-agent can be specified.', dest='user_agent', type=str)
optional.add_argument('--headers', help='Comma separated list of custom headers you\'d want to use. For example: ``--headers "Accept=text/php, X-Requested-With=Dumb"``.', dest='headers', type=str)
optional.add_argument('--exclude', help='Comma separated list of paths or directories to be excluded which are not in scope. These paths/dirs won\'t be scanned. For example: `--exclude somepage/, sensitive-dir/, pleasedontscan/`', dest='exclude', type=str)
optional.add_argument('--timeout', help='HTTP request timeout value in seconds. The entered value must be in floating point decimal. Example: ``--timeout 10.0``', dest='timeout', type=float)
optional.add_argument('--max-chars', help='Maximum allowed character length for the custom token value to be generated. For example: `--max-chars 5`. Default value is 6.', dest='maxchars', type=int)
optional.add_argument('--crawl', help="Crawl the whole site and simultaneously test all discovered endpoints for CSRF.", dest='crawl', action='store_true')
optional.add_argument('--skip-analysis', help='Skip the Post-Scan Analysis of Tokens which were gathered during requests', dest='skipal', action='store_true')
optional.add_argument('--skip-poc', help='Skip the PoC Form Generation of POST-Based Cross Site Request Forgeries.', dest='skippoc', action='store_true')
optional.add_argument('--update', help='Update XSRFProbe to latest version on GitHub via git.', dest='update', action='store_true')
optional.add_argument('--random-agent', help='Use random user-agents for making requests.', dest='randagent', action='store_true')
optional.add_argument('--version', help='Display the version of XSRFProbe and exit.', dest='version', action='store_true')
args = parser.parse_args()

if not len(sys.argv) > 1:
    print('''
    \033[1;91mXSRFProbe\033[0m, \033[1;97mA \033[1;93mCross Site Request Forgery \033[1;97mAudit Toolkit\033[0m
''')
    parser.print_help()
    quit('')

# Update XSRFProbe to latest version
if args.update:
    updater()
    quit('')

# Print out XSRFProbe version
if args.version:
    print('\n\033[1;97m [+] \033[1;91mXSRFProbe Version\033[0m : \033[1;97m'+open('files/VersionNum').read())
    quit()

# Now lets update some global config variables
if args.maxchars:
    config.TOKEN_GENERATION_LENGTH = args.maxchars

# Setting custom user-agent
if args.user_agent:
    config.USER_AGENT = args.user_agent

# Option to skip analysis
if args.skipal:
    config.SCAN_ANALYSIS = False

# Option to skip poc generation
if args.skippoc:
    config.POC_GENERATION = False

# Updating main root url
if not args.version and not args.update:
    if args.url: # and not args.help:
        if 'http' in args.url:
            config.SITE_URL = args.url
        else:
            config.SITE_URL = 'http://'+args.url
    else:
        print(R+'You must supply a url/endpoint.')

# Crawl the site if --crawl supplied.
if args.crawl:
    config.CRAWL_SITE = True

if args.cookie:
    # Assigning Cookie
    if ',' in args.cookie:
        for cook in args.cookie.split(','):
            config.COOKIE_VALUE.append(cook.strip())
            # This is necessary when a cookie value is supplied
            # Since if the user-agent used to make the request changes
            # from time to time, the remote site might trigger up
            # security mechanisms (or worse, perhaps block your ip?)
            config.USER_AGENT_RANDOM = False

# Timeout value
if args.timeout:
    config.TIMEOUT_VALUE = args.timeout

# Custom header values if specified
if args.headers:
    # NOTE: As a default idea, when the user supplies custom headers, we
    # simply add the custom headers to a list of existing headers in
    # files/config.py.
    # Uncomment the following lines to just reinitialise the headers everytime
    # they make a request.
    #
    #config.HEADER_VALUES = {}
    for m in args.headers.split(','):
        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1]                    

if args.exclude:
    exc = args.exclude
    #config.EXCLUDE_URLS = [s for s in exc.split(',').strip()]
    m = exc.split(',').strip()
    for s in m:
        config.EXCLUDE_DIRS.append(urllib.parse.urljoin(config.SITE_URL, s))

if args.randagent:
    # If random-agent argument supplied...
    config.USER_AGENT_RANDOM = True
    # Turn off a single User-Agent mechanism...
    config.USER_AGENT = ''

if config.SITE_URL:
    if args.output:
        # If output directory is mentioned...
        try:
            if not os.path.exists(args.output+tld.get_fld(config.SITE_URL)):
                os.makedirs(args.output+tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = args.output+tld.get_fld(config.SITE_URL) + '/'
    else:
        try:
            os.makedirs(tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = tld.get_fld(config.SITE_URL) + '/'

if args.quiet:
    config.DEBUG = False

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Configuration variables for defining remote applications.                    

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler="...",
            disconnect_handler="...",
            signup_handler=dict(
                info="...",
                setup="...",
                view="...",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url="https://github.com/login/oauth/access_token",
                access_token_method='POST',
                authorize_url="https://github.com/login/oauth/authorize",
                app_key="GITHUB_APP_CREDENTIALS",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key="changeme"
        consumer_secret="changeme"
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_default_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            signup_handler=dict(
                info="invenio.modules.oauthclient.contrib.orcid:account_info",
                setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
                view="invenio.modules.oauthclient.handlers:signup_handler",
            ),
            # ...
        )
    )
"""

OAUTHCLIENT_REMOTE_APPS = {}
"""Configuration of remote applications."""

OAUTHCLIENT_SESSION_KEY_PREFIX = "oauth_token"
"""Session key prefix used when storing the access token for a remote app."""

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="changeme",
           consumer_secret="changeme",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="<CLIENT ID>",
           consumer_secret="<CLIENT SECRET>",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href="{{url_for('oauthclient.login', remote_app='orcid')}}">Sign in with ORCID</a>

"""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
    disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
    signup_handler=dict(
        info="invenio.modules.oauthclient.contrib.orcid:account_info",
        setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
        view="invenio.modules.oauthclient.handlers:signup_handler",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},                    
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url="https://pub.orcid.org/oauth/token",
        access_token_method='POST',
        authorize_url="https://orcid.org/oauth/authorize#show_login",                    
        app_key="ORCID_APP_CREDENTIALS",
        content_type="application/json",
    )
)
""" ORCID Remote Application. """

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
"""ORCID Sandbox Remote Application."""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url="https://api.sandbox.orcid.org/",
    access_token_url="https://api.sandbox.orcid.org/oauth/token",
    authorize_url="https://sandbox.orcid.org/oauth/authorize#show_login",
))


def account_info(remote, resp):
    """Retrieve remote account information used to find local user."""
    account_info = dict(external_id=resp.get("orcid"), external_method="orcid")

    return account_info


@session_manager
def account_setup(remote, token):
    """Perform additional setup after user have been logged in."""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        "_account_info").get("external_id")

    extra_data = {
        "orcid": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method="orcid").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception("No user entry in userEXT.")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception("Not valid JSON response from " +
                                             "ORCID:\n {0}".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio["orcid-profile"]["orcid-bio"]["personal-details"]
                user.given_names = name["given-names"]["value"]
                user.family_name = name["family-name"]["value"]
            except KeyError:
                current_app.logger.exception("Unexpected return format " +
                                             "from ORCID:\n {0}".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()


# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch                    
from six.moves.urllib_parse import quote_plus                    
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite                    
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url="https://foo.bar/oauth/access_token",
            authorize_url="https://foo.bar/oauth/authorize",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params("fullid"),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return "TEST"

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """ Mock the oauth response to use the remote """
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                "access_token": "test_access_token",
                "scope": "",
                "token_type": "bearer"
            }
        )

    def test_login(self):                    
        # Test redirect
        resp = self.client.get(url_for("oauthclient.login", remote_app='test'))                    
        self.assertStatus(resp, 302)
        self.assertEqual(                    
            resp.location,                    
            "https://foo.bar/oauth/authorize?response_type=code&"                    
            "client_id=testid&redirect_uri=%s" % quote_plus(url_for(
                "oauthclient.authorized", remote_app='test', _external=True                    
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for("oauthclient.login", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for("oauthclient.login", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    "oauthclient.authorized",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == "TEST"
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(                    
                TypeError,
                c.get,
                url_for(
                    "oauthclient.authorized",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for("oauthclient.authorized", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for("oauthclient.disconnect", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):                    
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')                    

                t = RemoteToken.get(1, "fullid")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    "access_token": "new_access_token",
                    "scope": "",
                    "token_type": "bearer"
                })

                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, "fullid")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    "oauthclient.disconnect", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, "fullid")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):                    
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login("admin", "")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == "__main__":
    run_test_suite(TEST_SUITE)

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Client blueprint used to handle OAuth callbacks. """                    

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request                    

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler                    


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix="/oauth",
    static_folder="../static",
    template_folder="../templates",
)


@blueprint.before_app_first_request
def setup_app():
    """ Setup OAuth clients. """                    
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """ Send user to remote application for authentication. """                    
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,                    
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)                    


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """ Authorized handler callback. """                    
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """ Extra signup step. """                    
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """ Disconnect user from remote application.                    

    Removes application as well as associated information.
    """
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Configuration variables for defining remote applications.                    

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler="...",
            disconnect_handler="...",
            signup_handler=dict(
                info="...",
                setup="...",
                view="...",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url="https://github.com/login/oauth/access_token",
                access_token_method='POST',
                authorize_url="https://github.com/login/oauth/authorize",
                app_key="GITHUB_APP_CREDENTIALS",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key="changeme"
        consumer_secret="changeme"
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_default_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            signup_handler=dict(
                info="invenio.modules.oauthclient.contrib.orcid:account_info",
                setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
                view="invenio.modules.oauthclient.handlers:signup_handler",
            ),
            # ...
        )
    )
"""

OAUTHCLIENT_REMOTE_APPS = {}
"""Configuration of remote applications."""

OAUTHCLIENT_SESSION_KEY_PREFIX = "oauth_token"
"""Session key prefix used when storing the access token for a remote app."""

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="changeme",
           consumer_secret="changeme",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="<CLIENT ID>",
           consumer_secret="<CLIENT SECRET>",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href="{{url_for('oauthclient.login', remote_app='orcid')}}">Sign in with ORCID</a>

"""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
    disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
    signup_handler=dict(
        info="invenio.modules.oauthclient.contrib.orcid:account_info",
        setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
        view="invenio.modules.oauthclient.handlers:signup_handler",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},                    
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url="https://pub.orcid.org/oauth/token",
        access_token_method='POST',
        authorize_url="https://orcid.org/oauth/authorize#show_login",                    
        app_key="ORCID_APP_CREDENTIALS",
        content_type="application/json",
    )
)
""" ORCID Remote Application. """

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
"""ORCID Sandbox Remote Application."""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url="https://api.sandbox.orcid.org/",
    access_token_url="https://api.sandbox.orcid.org/oauth/token",
    authorize_url="https://sandbox.orcid.org/oauth/authorize#show_login",
))


def account_info(remote, resp):
    """Retrieve remote account information used to find local user."""
    account_info = dict(external_id=resp.get("orcid"), external_method="orcid")

    return account_info


@session_manager
def account_setup(remote, token):
    """Perform additional setup after user have been logged in."""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        "_account_info").get("external_id")

    extra_data = {
        "orcid": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method="orcid").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception("No user entry in userEXT.")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception("Not valid JSON response from " +
                                             "ORCID:\n {0}".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio["orcid-profile"]["orcid-bio"]["personal-details"]
                user.given_names = name["given-names"]["value"]
                user.family_name = name["family-name"]["value"]
            except KeyError:
                current_app.logger.exception("Unexpected return format " +
                                             "from ORCID:\n {0}".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()


# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch                    
from six.moves.urllib_parse import quote_plus                    
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite                    
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url="https://foo.bar/oauth/access_token",
            authorize_url="https://foo.bar/oauth/authorize",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params("fullid"),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return "TEST"

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """ Mock the oauth response to use the remote """
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                "access_token": "test_access_token",
                "scope": "",
                "token_type": "bearer"
            }
        )

    def test_login(self):                    
        # Test redirect
        resp = self.client.get(url_for("oauthclient.login", remote_app='test'))                    
        self.assertStatus(resp, 302)
        self.assertEqual(                    
            resp.location,                    
            "https://foo.bar/oauth/authorize?response_type=code&"                    
            "client_id=testid&redirect_uri=%s" % quote_plus(url_for(
                "oauthclient.authorized", remote_app='test', _external=True                    
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for("oauthclient.login", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for("oauthclient.login", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    "oauthclient.authorized",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == "TEST"
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(                    
                TypeError,
                c.get,
                url_for(
                    "oauthclient.authorized",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for("oauthclient.authorized", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for("oauthclient.disconnect", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):                    
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')                    

                t = RemoteToken.get(1, "fullid")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    "access_token": "new_access_token",
                    "scope": "",
                    "token_type": "bearer"
                })

                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, "fullid")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    "oauthclient.disconnect", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, "fullid")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):                    
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login("admin", "")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == "__main__":
    run_test_suite(TEST_SUITE)

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Client blueprint used to handle OAuth callbacks. """                    

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request                    

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler                    


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix="/oauth",
    static_folder="../static",
    template_folder="../templates",
)


@blueprint.before_app_first_request
def setup_app():
    """ Setup OAuth clients. """                    
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """ Send user to remote application for authentication. """                    
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,                    
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)                    


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """ Authorized handler callback. """                    
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """ Extra signup step. """                    
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """ Disconnect user from remote application.                    

    Removes application as well as associated information.
    """
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Configuration variables for defining remote applications.                    

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler="...",
            disconnect_handler="...",
            signup_handler=dict(
                info="...",
                setup="...",
                view="...",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url="https://github.com/login/oauth/access_token",
                access_token_method='POST',
                authorize_url="https://github.com/login/oauth/authorize",
                app_key="GITHUB_APP_CREDENTIALS",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key="changeme"
        consumer_secret="changeme"
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_default_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            signup_handler=dict(
                info="invenio.modules.oauthclient.contrib.orcid:account_info",
                setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
                view="invenio.modules.oauthclient.handlers:signup_handler",
            ),
            # ...
        )
    )
"""

OAUTHCLIENT_REMOTE_APPS = {}
"""Configuration of remote applications."""

OAUTHCLIENT_SESSION_KEY_PREFIX = "oauth_token"
"""Session key prefix used when storing the access token for a remote app."""

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="changeme",
           consumer_secret="changeme",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="<CLIENT ID>",
           consumer_secret="<CLIENT SECRET>",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href="{{url_for('oauthclient.login', remote_app='orcid')}}">Sign in with ORCID</a>

"""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
    disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
    signup_handler=dict(
        info="invenio.modules.oauthclient.contrib.orcid:account_info",
        setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
        view="invenio.modules.oauthclient.handlers:signup_handler",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},                    
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url="https://pub.orcid.org/oauth/token",
        access_token_method='POST',
        authorize_url="https://orcid.org/oauth/authorize#show_login",                    
        app_key="ORCID_APP_CREDENTIALS",
        content_type="application/json",
    )
)
""" ORCID Remote Application. """

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
"""ORCID Sandbox Remote Application."""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url="https://api.sandbox.orcid.org/",
    access_token_url="https://api.sandbox.orcid.org/oauth/token",
    authorize_url="https://sandbox.orcid.org/oauth/authorize#show_login",
))


def account_info(remote, resp):
    """Retrieve remote account information used to find local user."""
    account_info = dict(external_id=resp.get("orcid"), external_method="orcid")

    return account_info


@session_manager
def account_setup(remote, token):
    """Perform additional setup after user have been logged in."""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        "_account_info").get("external_id")

    extra_data = {
        "orcid": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method="orcid").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception("No user entry in userEXT.")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception("Not valid JSON response from " +
                                             "ORCID:\n {0}".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio["orcid-profile"]["orcid-bio"]["personal-details"]
                user.given_names = name["given-names"]["value"]
                user.family_name = name["family-name"]["value"]
            except KeyError:
                current_app.logger.exception("Unexpected return format " +
                                             "from ORCID:\n {0}".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()


# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch                    
from six.moves.urllib_parse import quote_plus                    
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite                    
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url="https://foo.bar/oauth/access_token",
            authorize_url="https://foo.bar/oauth/authorize",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params("fullid"),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return "TEST"

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """ Mock the oauth response to use the remote """
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                "access_token": "test_access_token",
                "scope": "",
                "token_type": "bearer"
            }
        )

    def test_login(self):                    
        # Test redirect
        resp = self.client.get(url_for("oauthclient.login", remote_app='test'))                    
        self.assertStatus(resp, 302)
        self.assertEqual(                    
            resp.location,                    
            "https://foo.bar/oauth/authorize?response_type=code&"                    
            "client_id=testid&redirect_uri=%s" % quote_plus(url_for(
                "oauthclient.authorized", remote_app='test', _external=True                    
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for("oauthclient.login", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for("oauthclient.login", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    "oauthclient.authorized",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == "TEST"
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(                    
                TypeError,
                c.get,
                url_for(
                    "oauthclient.authorized",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for("oauthclient.authorized", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for("oauthclient.disconnect", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):                    
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')                    

                t = RemoteToken.get(1, "fullid")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    "access_token": "new_access_token",
                    "scope": "",
                    "token_type": "bearer"
                })

                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, "fullid")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    "oauthclient.disconnect", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, "fullid")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):                    
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login("admin", "")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == "__main__":
    run_test_suite(TEST_SUITE)

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Client blueprint used to handle OAuth callbacks. """                    

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request                    

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler                    


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix="/oauth",
    static_folder="../static",
    template_folder="../templates",
)


@blueprint.before_app_first_request
def setup_app():
    """ Setup OAuth clients. """                    
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """ Send user to remote application for authentication. """                    
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,                    
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)                    


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """ Authorized handler callback. """                    
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """ Extra signup step. """                    
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """ Disconnect user from remote application.                    

    Removes application as well as associated information.
    """
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Configuration variables for defining remote applications.                    

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler="...",
            disconnect_handler="...",
            signup_handler=dict(
                info="...",
                setup="...",
                view="...",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url="https://github.com/login/oauth/access_token",
                access_token_method='POST',
                authorize_url="https://github.com/login/oauth/authorize",
                app_key="GITHUB_APP_CREDENTIALS",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key="changeme"
        consumer_secret="changeme"
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_default_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            signup_handler=dict(
                info="invenio.modules.oauthclient.contrib.orcid:account_info",
                setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
                view="invenio.modules.oauthclient.handlers:signup_handler",
            ),
            # ...
        )
    )
"""

OAUTHCLIENT_REMOTE_APPS = {}
"""Configuration of remote applications."""

OAUTHCLIENT_SESSION_KEY_PREFIX = "oauth_token"
"""Session key prefix used when storing the access token for a remote app."""

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="changeme",
           consumer_secret="changeme",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="<CLIENT ID>",
           consumer_secret="<CLIENT SECRET>",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href="{{url_for('oauthclient.login', remote_app='orcid')}}">Sign in with ORCID</a>

"""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
    disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
    signup_handler=dict(
        info="invenio.modules.oauthclient.contrib.orcid:account_info",
        setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
        view="invenio.modules.oauthclient.handlers:signup_handler",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},                    
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url="https://pub.orcid.org/oauth/token",
        access_token_method='POST',
        authorize_url="https://orcid.org/oauth/authorize#show_login",                    
        app_key="ORCID_APP_CREDENTIALS",
        content_type="application/json",
    )
)
""" ORCID Remote Application. """

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
"""ORCID Sandbox Remote Application."""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url="https://api.sandbox.orcid.org/",
    access_token_url="https://api.sandbox.orcid.org/oauth/token",
    authorize_url="https://sandbox.orcid.org/oauth/authorize#show_login",
))


def account_info(remote, resp):
    """Retrieve remote account information used to find local user."""
    account_info = dict(external_id=resp.get("orcid"), external_method="orcid")

    return account_info


@session_manager
def account_setup(remote, token):
    """Perform additional setup after user have been logged in."""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        "_account_info").get("external_id")

    extra_data = {
        "orcid": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method="orcid").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception("No user entry in userEXT.")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception("Not valid JSON response from " +
                                             "ORCID:\n {0}".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio["orcid-profile"]["orcid-bio"]["personal-details"]
                user.given_names = name["given-names"]["value"]
                user.family_name = name["family-name"]["value"]
            except KeyError:
                current_app.logger.exception("Unexpected return format " +
                                             "from ORCID:\n {0}".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()


# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch                    
from six.moves.urllib_parse import quote_plus                    
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite                    
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url="https://foo.bar/oauth/access_token",
            authorize_url="https://foo.bar/oauth/authorize",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params("fullid"),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return "TEST"

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """ Mock the oauth response to use the remote """
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                "access_token": "test_access_token",
                "scope": "",
                "token_type": "bearer"
            }
        )

    def test_login(self):                    
        # Test redirect
        resp = self.client.get(url_for("oauthclient.login", remote_app='test'))                    
        self.assertStatus(resp, 302)
        self.assertEqual(                    
            resp.location,                    
            "https://foo.bar/oauth/authorize?response_type=code&"                    
            "client_id=testid&redirect_uri=%s" % quote_plus(url_for(
                "oauthclient.authorized", remote_app='test', _external=True                    
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for("oauthclient.login", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for("oauthclient.login", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    "oauthclient.authorized",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == "TEST"
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(                    
                TypeError,
                c.get,
                url_for(
                    "oauthclient.authorized",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for("oauthclient.authorized", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for("oauthclient.disconnect", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):                    
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')                    

                t = RemoteToken.get(1, "fullid")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    "access_token": "new_access_token",
                    "scope": "",
                    "token_type": "bearer"
                })

                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, "fullid")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    "oauthclient.disconnect", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, "fullid")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):                    
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login("admin", "")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == "__main__":
    run_test_suite(TEST_SUITE)

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Client blueprint used to handle OAuth callbacks. """                    

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request                    

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler                    


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix="/oauth",
    static_folder="../static",
    template_folder="../templates",
)


@blueprint.before_app_first_request
def setup_app():
    """ Setup OAuth clients. """                    
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """ Send user to remote application for authentication. """                    
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,                    
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)                    


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """ Authorized handler callback. """                    
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """ Extra signup step. """                    
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """ Disconnect user from remote application.                    

    Removes application as well as associated information.
    """
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Configuration variables for defining remote applications.                    

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler="...",
            disconnect_handler="...",
            signup_handler=dict(
                info="...",
                setup="...",
                view="...",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url="https://github.com/login/oauth/access_token",
                access_token_method='POST',
                authorize_url="https://github.com/login/oauth/authorize",
                app_key="GITHUB_APP_CREDENTIALS",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key="changeme"
        consumer_secret="changeme"
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_default_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
            disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
            )
            signup_handler=dict(
                info="invenio.modules.oauthclient.contrib.orcid:account_info",
                setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
                view="invenio.modules.oauthclient.handlers:signup_handler",
            ),
            # ...
        )
    )
"""

OAUTHCLIENT_REMOTE_APPS = {}
"""Configuration of remote applications."""

OAUTHCLIENT_SESSION_KEY_PREFIX = "oauth_token"
"""Session key prefix used when storing the access token for a remote app."""

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="changeme",
           consumer_secret="changeme",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key="<CLIENT ID>",
           consumer_secret="<CLIENT SECRET>",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href="{{url_for('oauthclient.login', remote_app='orcid')}}">Sign in with ORCID</a>

"""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler="invenio.modules.oauthclient.handlers"
                       ":authorized_signup_handler",
    disconnect_handler="invenio.modules.oauthclient.handlers"
                       ":disconnect_handler",
    signup_handler=dict(
        info="invenio.modules.oauthclient.contrib.orcid:account_info",
        setup="invenio.modules.oauthclient.contrib.orcid:account_setup",
        view="invenio.modules.oauthclient.handlers:signup_handler",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},                    
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url="https://pub.orcid.org/oauth/token",
        access_token_method='POST',
        authorize_url="https://orcid.org/oauth/authorize#show_login",                    
        app_key="ORCID_APP_CREDENTIALS",
        content_type="application/json",
    )
)
""" ORCID Remote Application. """

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
"""ORCID Sandbox Remote Application."""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url="https://api.sandbox.orcid.org/",
    access_token_url="https://api.sandbox.orcid.org/oauth/token",
    authorize_url="https://sandbox.orcid.org/oauth/authorize#show_login",
))


def account_info(remote, resp):
    """Retrieve remote account information used to find local user."""
    account_info = dict(external_id=resp.get("orcid"), external_method="orcid")

    return account_info


@session_manager
def account_setup(remote, token):
    """Perform additional setup after user have been logged in."""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        "_account_info").get("external_id")

    extra_data = {
        "orcid": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method="orcid").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception("No user entry in userEXT.")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception("Not valid JSON response from " +
                                             "ORCID:\n {0}".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio["orcid-profile"]["orcid-bio"]["personal-details"]
                user.given_names = name["given-names"]["value"]
                user.family_name = name["family-name"]["value"]
            except KeyError:
                current_app.logger.exception("Unexpected return format " +
                                             "from ORCID:\n {0}".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()


# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch                    
from six.moves.urllib_parse import quote_plus                    
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite                    
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url="https://foo.bar/oauth/access_token",
            authorize_url="https://foo.bar/oauth/authorize",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params("fullid"),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return "TEST"

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """ Mock the oauth response to use the remote """
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                "access_token": "test_access_token",
                "scope": "",
                "token_type": "bearer"
            }
        )

    def test_login(self):                    
        # Test redirect
        resp = self.client.get(url_for("oauthclient.login", remote_app='test'))                    
        self.assertStatus(resp, 302)
        self.assertEqual(                    
            resp.location,                    
            "https://foo.bar/oauth/authorize?response_type=code&"                    
            "client_id=testid&redirect_uri=%s" % quote_plus(url_for(
                "oauthclient.authorized", remote_app='test', _external=True                    
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for("oauthclient.login", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for("oauthclient.login", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    "oauthclient.authorized",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == "TEST"
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(                    
                TypeError,
                c.get,
                url_for(
                    "oauthclient.authorized",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for("oauthclient.authorized", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for("oauthclient.disconnect", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):                    
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')                    

                t = RemoteToken.get(1, "fullid")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    "access_token": "new_access_token",
                    "scope": "",
                    "token_type": "bearer"
                })

                c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, "fullid")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    "oauthclient.disconnect", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, "fullid")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):                    
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for("oauthclient.login", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    "oauthclient.authorized", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login("admin", "")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == "__main__":
    run_test_suite(TEST_SUITE)

# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""" Client blueprint used to handle OAuth callbacks. """                    

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request                    

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler                    


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix="/oauth",
    static_folder="../static",
    template_folder="../templates",
)


@blueprint.before_app_first_request
def setup_app():
    """ Setup OAuth clients. """                    
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """ Send user to remote application for authentication. """                    
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,                    
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)                    


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """ Authorized handler callback. """                    
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """ Extra signup step. """                    
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """ Disconnect user from remote application.                    

    Removes application as well as associated information.
    """
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()


import socket
import threading
import tornado

import tornado.concurrent
import tornado.httputil
import tornado.httpserver
import tornado.gen
import tornado.ioloop
import tornado.process
import tornado.web

from bzs import const
from bzs import db
from bzs import files

from bzs import module_error404
from bzs import module_files
from bzs import module_home
from bzs import module_index
from bzs import module_static

WEB_PORT = 80

def main():
    # Creating web application
    web_app = tornado.web.Application([
            (r'^/$', module_index.MainframeHandler),
            (r'/static/.*', module_static.StaticHandler),                    
            # (r'/static/(.*)', tornado.web.StaticFileHandler, {
            #     "path": "./static/" # Optimized static file handler with cache
            # }),
            (r'^/home', module_home.HomeHandler),
            (r'^/files/?()$', module_files.FilesListHandler),
            (r'^/files/list/(.*)', module_files.FilesListHandler),
            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),
            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),
            (r'^/files/operation/?', module_files.FilesOperationHandler),
            (r'.*', module_error404.Error404Handler)
        ],
        xsrf_cookies=False # True to prevent CSRF third party attacks
    )
    # Starting server
    web_sockets = tornado.netutil.bind_sockets(
        const.get_const('server-port'),
        family=socket.AF_INET)
    if const.get_const('server-threads') > 1:
        if hasattr(os, 'fork'):
            # os.fork() operation unavailable on Windows.
            tornado.process.fork_processes(const.get_const('server-threads') - 1)
    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)
    web_server.add_sockets(web_sockets)
    # Boot I/O thread for asynchronous purposes
    tornado.ioloop.IOLoop.instance().start()
    return


import re
import tornado

from bzs import files
from bzs import const

class Error404Handler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        try:
            file_data = files.get_static_data('./static/404.html')
        except Exception:
            file_data = '404 Not Found'
        self.set_status(200, "OK")
        self._headers = tornado.httputil.HTTPHeaders()                    
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass


import base64
import binascii
import cgi
import io
import json
import re
import time
import tornado
import urllib

from bzs import const
from bzs import db
from bzs import files
from bzs import preproc
from bzs import users

def encode_str_to_hexed_b64(data):
    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')
def decode_hexed_b64_to_str(data):
    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')

################################################################################

class FilesListHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, target_path):
        """/files/list/HEXED_BASE64_STRING_OF_PATH/"""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async(target_path):
            # Getting file template.
            file_temp = files.get_static_data('./static/files.html')

            # Retrieving list operation target.
            try:
                target_path = decode_hexed_b64_to_str(target_path)
            except:
                target_path = '/'
            if not target_path:
                target_path = '/'

            # Getting hierarchical file path
            files_hierarchy = target_path.split('/')
            files_hierarchy_list = list()
            while '' in files_hierarchy:
                files_hierarchy.remove('')
            files_hierarchy = [''] + files_hierarchy
            files_hierarchy_cwd = ''
            for i in range(0, len(files_hierarchy)):
                files_hierarchy[i] += '/'
                files_hierarchy_cwd += files_hierarchy[i]
                files_hierarchy_list.append(dict(
                    folder_name=files_hierarchy[i],
                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),
                    disabled=(i == len(files_hierarchy) - 1)))
                continue

            # Getting current directory content
            files_attrib_list = list()
            for f_handle in db.Filesystem.listdir(target_path):
                # try:
                    file_name = f_handle['file-name']
                    actual_path = target_path + file_name
                    attrib = dict()
                    attrib['file-name'] = file_name
                    attrib['file-name-url'] = urllib.parse.quote(file_name)
                    attrib['file-name-escaped'] = cgi.escape(file_name)
                    attrib['size'] = f_handle['file-size']
                    attrib['size-str'] = files.format_file_size(attrib['size'])
                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!
                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))
                    # Encoding MIME types
                    if f_handle['is-dir']:
                        attrib['mime-type'] = 'directory/folder'
                    else:
                        attrib['mime-type'] = files.guess_mime_type(file_name)
                    # Encoding hyperlinks
                    if attrib['mime-type'] == 'directory/folder':
                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')
                    else:
                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])
                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)
                    files_attrib_list.append(attrib)
                # except Exception:
                #     pass
            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)

            # File actually exists, sending data
            working_user = users.get_user_by_cookie(
                self.get_cookie('user_active_login', default=''))
            file_temp = preproc.preprocess_webpage(file_temp, working_user,
                files_attrib_list=files_attrib_list,
                files_hierarchy_list=files_hierarchy_list,
                cwd_uuid=cwd_uuid)
            future.set_result(file_temp)
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,
            target_path)
        file_temp = yield future

        self.set_status(200, "OK")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self

    head=get
    pass

################################################################################

class FilesDownloadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path, file_name):
        """/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME"""
        # Something that I do not wish to write too many times..
        def invoke_404():
            self.set_status(404, "Not Found")
            self._headers = tornado.httputil.HTTPHeaders()                    
            self.add_header('Content-Length', '0')
            self.flush()
            return

        # Get file location (exactly...)
        try:
            file_path = decode_hexed_b64_to_str(file_path)
        except Exception:
            file_path = ''
        if not file_path:
            invoke_404()
            return

        # Asynchronous web request...
        file_block_size = 64 * 1024 # 64 KiB / Chunk
        file_block = bytes()
        file_data = None

        future = tornado.concurrent.Future()
        def inquire_data_async():
            _tf_data = db.Filesystem.get_content(file_path)
            future.set_result(_tf_data)
        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)
        file_data = yield future
        file_stream = io.BytesIO(file_data)

        self.set_status(200, "OK")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'application/x-download')
        self.add_header('Content-Length', str(len(file_data)))

        while file_stream.tell() < len(file_data):
            byte_pos = file_stream.tell()
            # Entry to the concurrency worker
            future = tornado.concurrent.Future()
            # Concurrent worker
            def retrieve_data_async():
                block = file_stream.read(file_block_size)
                future.set_result(block)
            # Injection and pending
            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)
            # Reset or read
            file_block = yield future
            self.write(file_block)
            file_block = None
            self.flush()
        file_block = None
        self.finish()

        # Release memory...
        file_stream = None
        file_data = None
        return self

    head=get
    pass

################################################################################

class FilesOperationHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self):
        """/files/operation/"""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async():
            operation_content_raw = self.request.body
            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))
            action = operation_content['action']
            sources = operation_content['source']
            if type(sources) == list:
                for i in range(0, len(sources)):
                    try:
                        sources[i] = decode_hexed_b64_to_str(sources[i])
                    except:
                        pass
            else:
                sources = decode_hexed_b64_to_str(sources)
            if action in ['copy', 'move']:
                try:
                    target = decode_hexed_b64_to_str(operation_content['target'])
                except:
                    target = '/'
            elif action in ['rename', 'new-folder']:
                try:
                    target = operation_content['target']
                except:
                    target = sources # I am not handling more exceptions as this is brutal enough
            # Done assigning values, now attempting to perform operation
            if action == 'copy':
                for source in sources:
                    db.Filesystem.copy(source, target, new_owner='user-cp')
            elif action == 'move':
                for source in sources:
                    db.Filesystem.move(source, target)
            elif action == 'delete':
                for source in sources:
                    db.Filesystem.remove(source)
            elif action == 'rename':
                db.Filesystem.rename(sources, target)
            elif action == 'new-folder':
                db.Filesystem.mkdir(sources, target, 'user-nf')
            future.set_result('')
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)
        file_temp = yield future

        self.set_status(200, "OK")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self
    pass

################################################################################

class FilesUploadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self, target_path, file_name):
        """/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME"""
        # Another concurrency blob...
        future = tornado.concurrent.Future()
        working_user = users.get_user_by_cookie(
            self.get_cookie('user_active_login', default=''))

        def save_file_async(alter_ego, target_path, file_name, working_user):
            upload_data = alter_ego.request.body
            # Crucial, to release data.
            alter_ego.request.body = None
            target_path = decode_hexed_b64_to_str(target_path)
            # Committing changes to database
            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)
            # Final return
            future.set_result('bzs_upload_success')
        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,
            self, target_path, file_name, working_user)

        response_temp = yield future
        self.set_status(200, "OK")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(response_temp)))
        self.write(response_temp)
        self.flush()
        self.finish()
        return self
    pass


# -*- encoding: utf-8 -*-
#
#  base
#  ****
#
# Implementation of BaseHandler, the Cyclone class RequestHandler extended with our
# needings.
#

import httplib
import types
import collections
import json
import re
import sys
import logging

from StringIO import StringIO
from cgi import parse_header
from urllib import unquote

from twisted.python.failure import Failure
from twisted.internet.defer import inlineCallbacks
from twisted.internet import fdesc

from cyclone.web import RequestHandler, HTTPError, HTTPAuthenticationRequired, StaticFileHandler, RedirectHandler
from cyclone.httpserver import HTTPConnection, HTTPRequest, _BadRequestException
from cyclone import escape, httputil
from cyclone.escape import native_str, parse_qs_bytes

from globaleaks.jobs.statistics_sched import alarm_level
from globaleaks.utils.utility import log, log_remove_escapes, log_encode_html, datetime_now
from globaleaks.utils.mailutils import mail_exception
from globaleaks.settings import GLSetting
from globaleaks.rest import errors
from globaleaks.security import GLSecureTemporaryFile, security_sleep

def validate_host(host_key):
    """
    validate_host checks in the GLSetting list of valid 'Host:' values
    and if matched, return True, else return False
    Is used by all the Web handlers inherit from Cyclone
    """
    # hidden service has not a :port
    if len(host_key) == 22 and host_key[16:22] == '.onion':
        return True

    # strip eventually port
    hostchunk = str(host_key).split(":")
    if len(hostchunk) == 2:
        host_key = hostchunk[0]

    if host_key in GLSetting.accepted_hosts:
        return True

    log.debug("Error in host requested: %s not accepted between: %s " %
              (host_key, GLSetting.accepted_hosts))

    return False


class GLHTTPServer(HTTPConnection):
    file_upload = False

    def __init__(self):
        self.uploaded_file = {}

    def rawDataReceived(self, data):
        if self.content_length is not None:
            data, rest = data[:self.content_length], data[self.content_length:]
            self.content_length -= len(data)
        else:
            rest = ''

        self._contentbuffer.write(data)
        if self.content_length == 0 and self._contentbuffer is not None:
            tmpbuf = self._contentbuffer
            self.content_length = self._contentbuffer = None
            self.setLineMode(rest)
            tmpbuf.seek(0, 0)
            if self.file_upload:
                self._on_request_body(self.uploaded_file)
                self.file_upload = False
                self.uploaded_file = {}
            else:
                self._on_request_body(tmpbuf.read())

    def _on_headers(self, data):
        try:
            data = native_str(data.decode("latin1"))
            eol = data.find("\r\n")
            start_line = data[:eol]
            try:
                method, uri, version = start_line.split(" ")
            except ValueError:
                raise _BadRequestException("Malformed HTTP request line")
            if not version.startswith("HTTP/"):
                raise _BadRequestException(
                    "Malformed HTTP version in HTTP Request-Line")
            headers = httputil.HTTPHeaders.parse(data[eol:])
            self._request = HTTPRequest(
                connection=self, method=method, uri=uri, version=version,
                headers=headers, remote_ip=self._remote_ip)

            self.content_length = int(headers.get("Content-Length", 0))

            # we always use secure temporary files in case of large json or file uploads
            if self.content_length < 100000 and self._request.headers.get("Content-Disposition") is None:
                self._contentbuffer = StringIO('')
            else:
                self._contentbuffer = GLSecureTemporaryFile(GLSetting.tmp_upload_path)

            if headers.get("Expect") == "100-continue":
                self.transport.write("HTTP/1.1 100 (Continue)\r\n\r\n")

            c_d_header = self._request.headers.get("Content-Disposition")
            if c_d_header is not None:
                key, pdict = parse_header(c_d_header)
                if key != 'attachment' or 'filename' not in pdict:
                    raise _BadRequestException("Malformed Content-Disposition header")

                self.file_upload = True
                self.uploaded_file['filename'] = unquote(pdict['filename'])
                self.uploaded_file['content_type'] = self._request.headers.get("Content-Type",
                                                                               'application/octet-stream')

                self.uploaded_file['body'] = self._contentbuffer
                self.uploaded_file['body_len'] = int(self.content_length)
                self.uploaded_file['body_filepath'] = self._contentbuffer.filepath

            megabytes = int(self.content_length) / (1024 * 1024)

            if self.file_upload:
                limit_type = "upload"
                limit = GLSetting.memory_copy.maximum_filesize
            else:
                limit_type = "json"
                limit = 1000000 # 1MB fixme: add GLSetting.memory_copy.maximum_jsonsize
                # is 1MB probably too high. probably this variable must be in kB

            # less than 1 megabytes is always accepted
            if megabytes > limit:
                log.err("Tried %s request larger than expected (%dMb > %dMb)" %
                        (limit_type,
                         megabytes,
                         limit))

                # In HTTP Protocol errors need to be managed differently than handlers
                raise errors.HTTPRawLimitReach

            if self.content_length > 0:
                self.setRawMode()
                return
            elif self.file_upload:
                self._on_request_body(self.uploaded_file)
                self.file_upload = False
                self.uploaded_file = {}
                return

            self.request_callback(self._request)
        except Exception as exception:
            log.msg("Malformed HTTP request from %s: %s" % (self._remote_ip, exception))
            log.exception(exception)
            if self._request:
                self._request.finish()
            if self.transport:
                self.transport.loseConnection()

    def _on_request_body(self, data):
        try:
            self._request.body = data
            content_type = self._request.headers.get("Content-Type", "")
            if self._request.method in ("POST", "PATCH", "PUT"):
                if content_type.startswith("application/x-www-form-urlencoded") and self.content_length < GLSetting.www_form_urlencoded_maximum_size:
                    arguments = parse_qs_bytes(native_str(self._request.body))
                    for name, values in arguments.iteritems():
                        values = [v for v in values if v]
                        if values:
                            self._request.arguments.setdefault(name,
                                                               []).extend(values)
                elif content_type.startswith("application/x-www-form-urlencoded"):
                    raise errors.InvalidInputFormat("content type application/x-www-form-urlencoded not supported")
                elif content_type.startswith("multipart/form-data"):
                    raise errors.InvalidInputFormat("content type multipart/form-data not supported")
            self.request_callback(self._request)
        except Exception as exception:
            log.msg("Malformed HTTP request from %s: %s" % (self._remote_ip, exception))
            log.exception(exception)
            if self._request:
                self._request.finish()
            if self.transport:
                self.transport.loseConnection()


class BaseHandler(RequestHandler):
    xsrf_cookie_name = "XSRF-TOKEN"

    def set_default_headers(self):
        """
        In this function are written some security enforcements
        related to WebServer versioning and XSS attacks.

        This is the first function called when a new request reach GLB
        """
        self.request.start_time = datetime_now()

        # just reading the property is enough to
        # set the cookie as a side effect.
        self.xsrf_token

        # to avoid version attacks
        self.set_header("Server", "globaleaks")

        # to reduce possibility for XSS attacks.
        self.set_header("X-Content-Type-Options", "nosniff")
        self.set_header("X-XSS-Protection", "1; mode=block")

        # to mitigate information leakage on Browser/Proxy Cache
        self.set_header("Cache-control", "no-cache, no-store, must-revalidate")
        self.set_header("Pragma", "no-cache")
        self.set_header("Expires", "-1")

        # to avoid Robots spidering, indexing, caching
        self.set_header("X-Robots-Tag", "noindex")

        if not GLSetting.devel_mode:
            # to mitigate clickjaking attacks on iframes
            self.set_header("X-Frame-Options", "deny")

        lang = self.request.headers.get('GL-Language', None)

        if not lang:
            # before was used the Client language. but shall be unsupported
            # lang = self.request.headers.get('Accepted-Language', None)
            lang = GLSetting.memory_copy.default_language

        self.request.language = lang

    def check_xsrf_cookie(self):
        """
            Override needed to change name of header name
        """
        token = self.request.headers.get("X-XSRF-TOKEN")
        if not token:
            token = self.get_argument('xsrf-token', default=None)
        if not token:
            raise HTTPError(403, "X-XSRF-TOKEN argument missing from POST")

        # TODO
        # This need to be compared with cryptography "same time comparation etc"
        if self.xsrf_token != token:                    
            raise HTTPError(403, "XSRF cookie does not match POST argument")


    @staticmethod
    def validate_python_type(value, python_type):
        """
        Return True if the python class instantiates the python_type given,
            'int' fields are accepted also as 'unicode' but cast on base 10
            before validate them
            'bool' fields are accepted also as 'true' 'false' because this
            happen on angular.js
        """
        if value is None:
            return True

        if python_type == int:
            try:
                int(value)
                return True
            except Exception:
                return False

        if python_type == bool:
            if value == u'true' or value == u'false':
                return True

        return isinstance(value, python_type)

    @staticmethod
    def validate_GLtype(value, gl_type):
        """
        Return True if the python class matches the given regexp.
        """
        if isinstance(value, (str, unicode)):
            return bool(re.match(gl_type, value))
        else:
            return False

    @staticmethod
    def validate_type(value, gl_type):
        # if it's callable, than assumes is a primitive class
        if callable(gl_type):
            retval = BaseHandler.validate_python_type(value, gl_type)
            if not retval:
                log.err("-- Invalid python_type, in [%s] expected %s" % (value, gl_type))
            return retval
        # value as "{foo:bar}"
        elif isinstance(gl_type, collections.Mapping):
            retval = BaseHandler.validate_jmessage(value, gl_type)
            if not retval:
                log.err("-- Invalid JSON/dict [%s] expected %s" % (value, gl_type))
            return retval
        # regexp
        elif isinstance(gl_type, str):
            retval = BaseHandler.validate_GLtype(value, gl_type)
            if not retval:
                log.err("-- Failed Match in regexp [%s] against %s" % (value, gl_type))
            return retval
        # value as "[ type ]"
        elif isinstance(gl_type, collections.Iterable):
            # empty list is ok
            if len(value) == 0:
                return True
            else:
                retval = all(BaseHandler.validate_type(x, gl_type[0]) for x in value)
                if not retval:
                    log.err("-- List validation failed [%s] of %s" % (value, gl_type))
                return retval
        else:
            raise AssertionError

    @staticmethod
    def validate_jmessage(jmessage, message_template):
        """
        Takes a string that represents a JSON messages and checks to see if it
        conforms to the message type it is supposed to be.

        This message must be either a dict or a list. This function may be called
        recursively to validate sub-parameters that are also go GLType.

        message: the message string that should be validated

        message_type: the GLType class it should match.
        """
        valid_jmessage = {}
        for key in message_template.keys():
            if key not in jmessage:
                log.err('key %s not in %s' % (key, jmessage))
                raise errors.InvalidInputFormat('wrong schema: missing %s' % key)
            else:
                valid_jmessage[key] = jmessage[key]

        if GLSetting.loglevel == "DEBUG":
            # check if wrong keys are reaching the GLBackend, they are
            # stripped in the previous loop, because valid_jmessage is returned
            for double_k in jmessage.keys():
                if double_k not in message_template.keys():
                    log.err("[!?] key %s not expected" % double_k)

        jmessage = valid_jmessage
        del valid_jmessage

        for key, value in message_template.iteritems():
            if not BaseHandler.validate_type(jmessage[key], value):
                raise errors.InvalidInputFormat("REST integrity check 1, fail in %s" % key)

        for key, value in jmessage.iteritems():
            if not BaseHandler.validate_type(value, message_template[key]):
                raise errors.InvalidInputFormat("REST integrity check 2, fail in %s" % key)

        return True

    @staticmethod
    def validate_message(message, message_template):
        try:
            jmessage = json.loads(message)
        except ValueError:
            raise errors.InvalidInputFormat("Invalid JSON format")

        if BaseHandler.validate_jmessage(jmessage, message_template):
            return jmessage


    def output_stripping(self, message, message_template):
        """
        @param message: the serialized dict received
        @param message_template: the answers definition
        @return: a dict or a list without the unwanted keys
        """
        pass

    def on_connection_close(self, *args, **kwargs):
        pass

    def prepare(self):
        """
        This method is called by cyclone, and is implemented to
        handle the POST fallback, in environment where PUT and DELETE
        method may not be used.
        Is used also to log the complete request, if the option is
        command line specified
        """

        # just reading the property is enough to
        # set the cookie as a side effect.
        self.xsrf_token

        if not validate_host(self.request.host):
            raise errors.InvalidHostSpecified

        # if 0 is infinite logging of the requests
        if GLSetting.http_log >= 0:

            GLSetting.http_log_counter += 1

            try:
                content = (">" * 15)
                content += (" Request %d " % GLSetting.http_log_counter)
                content += (">" * 15) + "\n\n"

                content += self.request.method + " " + self.request.full_url() + "\n\n"

                content += "headers:\n"
                for k, v in self.request.headers.get_all():
                    content += "%s: %s\n" % (k, v)

                if type(self.request.body) == dict and 'body' in self.request.body:
                    # this is needed due to cyclone hack for file uploads
                    body = self.request.body['body'].read()
                else:
                    body = self.request.body

                if len(body):
                    content += "\nbody:\n" + body + "\n"

                self.do_verbose_log(content)

            except Exception as excep:
                log.err("JSON logging fail (prepare): %s" % excep.message)
                return

            # save in the request the numeric ID of the request, so the answer can be correlated
            self.globaleaks_io_debug = GLSetting.http_log_counter

            if 0 < GLSetting.http_log < GLSetting.http_log_counter:
                log.debug("Reached I/O logging limit of %d requests: disabling" % GLSetting.http_log)
                GLSetting.http_log = -1


    def flush(self, include_footers=False):
        """
        This method is used internally by Cyclone,
        Cyclone specify the function on_finish but in that time the request is already flushed,
        so overwrite flush() was the easiest way to achieve our collection.

        It's here implemented to supports the I/O logging if requested
        with the command line options --io $number_of_request_recorded
        """
        if hasattr(self, 'globaleaks_io_debug'):
            try:
                content = ("<" * 15)
                content += (" Response %d " % self.globaleaks_io_debug)
                content += ("<" * 15) + "\n\n"
                content += "status code: " + str(self._status_code) + "\n\n"

                content += "headers:\n"
                for k, v in self._headers.iteritems():
                    content += "%s: %s\n" % (k, v)

                if self._write_buffer is not None:
                    content += "\nbody: " + str(self._write_buffer) + "\n"

                self.do_verbose_log(content)
            except Exception as excep:
                log.err("JSON logging fail (flush): %s" % excep.message)
                return

        RequestHandler.flush(self, include_footers)


    def do_verbose_log(self, content):
        """
        Record in the verbose log the content as defined by Cyclone wrappers.
        """
        content = log_remove_escapes(content)
        content = log_encode_html(content)

        try:
            with open(GLSetting.httplogfile, 'a+') as fd:
                fdesc.writeToFD(fd.fileno(), content + "\n")
        except Exception as excep:
            log.err("Unable to open %s: %s" % (GLSetting.httplogfile, excep))

    def write_error(self, status_code, **kw):
        exception = kw.get('exception')
        if exception and hasattr(exception, 'error_code'):

            error_dict = {}
            error_dict.update({'error_message': exception.reason, 'error_code': exception.error_code})
            if hasattr(exception, 'arguments'):
                error_dict.update({'arguments': exception.arguments})
            else:
                error_dict.update({'arguments': []})

            self.set_status(status_code)
            self.finish(error_dict)
        else:
            RequestHandler.write_error(self, status_code, **kw)

    def write(self, chunk):
        """
        This is a monkey patch to RequestHandler to allow us to serialize also
        json list objects.

        """
        if isinstance(chunk, types.ListType):
            chunk = escape.json_encode(chunk)
            RequestHandler.write(self, chunk)
            self.set_header("Content-Type", "application/json")
        else:
            RequestHandler.write(self, chunk)


    @inlineCallbacks
    def uniform_answers_delay(self):
        """
        @return: nothing. just put a delay to normalize a minimum
           amount of time used by requests. this impair time execution analysis

        this safety measure, able to counteract some side channel attacks, is
        automatically disabled when the option -z and -l DEBUG are present
        (because mean that is run in development mode)

        is not really "uniformed" the delay, there are some range of randomness
        as documented in TODO
        """

        if GLSetting.loglevel == logging.DEBUG and GLSetting.devel_mode:
            return

        uniform_delay = 0.800
        request_time = self.request.request_time()
        needed_diff = uniform_delay - request_time

        if needed_diff > 0:
            #print "uniform delay of %.2fms to reach %.2fms" % (
            #    (1000.0 * needed_diff),
            #    (1000.0 * uniform_delay)
            #)
            yield security_sleep(needed_diff)
        else:
            #print "uniform delay of %.2fms it's more than %.2fms" % (
            #    (1000.0 * request_time ), (1000.0 * uniform_delay)
            #)
            pass


    @property
    def current_user(self):
        session_id = None

        session_id = self.request.headers.get('X-Session')

        if session_id is None:
            # Check for POST based authentication.
            session_id = self.get_argument('x-session', default=None)

        if session_id is None:
            return None

        try:
            session = GLSetting.sessions[session_id]
        except KeyError:
            return None
        return session

    @property
    def is_whistleblower(self):
        if not self.current_user or not self.current_user.has_key('role'):
            raise errors.NotAuthenticated

        return self.current_user['role'] == 'wb'

    @property
    def is_receiver(self):
        if not self.current_user or not self.current_user.has_key('role'):
            raise errors.NotAuthenticated

        return self.current_user['role'] == 'receiver'

    def _handle_request_exception(self, e):
        # sys.exc_info() does not always work at this stage
        if isinstance(e, Failure):
            exc_type = e.type
            exc_value = e.value
            exc_tb = e.getTracebackObject()
            e = e.value
        else:
            exc_type, exc_value, exc_tb = sys.exc_info()

        if isinstance(e, (HTTPError, HTTPAuthenticationRequired)):
            if GLSetting.http_log and e.log_message:
                string_format = "%d %s: " + e.log_message
                args = [e.status_code, self._request_summary()] + list(e.args)
                msg = lambda *args: string_format % args
                log.msg(msg(*args))
            if e.status_code not in httplib.responses:
                log.msg("Bad HTTP status code: %d" % e.status_code)
                return self.send_error(500, exception=e)
            else:
                return self.send_error(e.status_code, exception=e)
        else:
            log.err("Uncaught exception %s %s %s" % (exc_type, exc_value, exc_tb))
            if GLSetting.http_log:
                log.msg(e)
            mail_exception(exc_type, exc_value, exc_tb)
            return self.send_error(500, exception=e)

    def get_uploaded_file(self):
        uploaded_file = self.request.body

        if not isinstance(uploaded_file, dict) or len(uploaded_file.keys()) != 5:
            raise errors.InvalidInputFormat("Expected a dict of four keys in uploaded file")

        for filekey in uploaded_file.keys():
            if filekey not in [u'body',
                               u'body_len',
                               u'content_type',
                               u'filename',
                               u'body_filepath']:
                raise errors.InvalidInputFormat(
                    "Invalid JSON key in uploaded file (%s)" % filekey)

        return uploaded_file


class BaseStaticFileHandler(BaseHandler, StaticFileHandler):
    def prepare(self):
        """
        This method is called by cyclone,and perform 'Host:' header
        validation using the same 'validate_host' function used by
        BaseHandler. but BaseHandler manage the REST API,..
        BaseStaticFileHandler manage all the statically served files.
        """
        if not validate_host(self.request.host):
            raise errors.InvalidHostSpecified


class BaseRedirectHandler(BaseHandler, RedirectHandler):
    def prepare(self):
        """
        Same reason of StaticFileHandler
        """
        if not validate_host(self.request.host):
            raise errors.InvalidHostSpecified

def anomaly_check(element):
    """
    @param element: one of the events with threshold

    if anomaly_checks are disabled the decorator simply returns
    """

    def wrapper(method_handler):
        def call_handler(cls, *args, **kw):

            # if anomaly_checks are disabled the decorator simply returns
            if not GLSetting.memory_copy.anomaly_checks:
                return method_handler(cls, *args, **kw)

            if GLSetting.anomalies_counter[element] > alarm_level[element]:

                if element == 'new_submission':
                    log.debug("Blocked a New Submission (%d > %d)" % (
                        GLSetting.anomalies_counter[element],
                        alarm_level[element]
                    ))
                    raise errors.SubmissionFlood(30)
                elif element == 'finalized_submission':
                    log.debug("Blocked a Finalized Submission (%d > %d)" % (
                        GLSetting.anomalies_counter[element],
                        alarm_level[element]
                    ))
                    raise errors.SubmissionFlood(30)
                elif element == 'anon_requests':
                    log.debug("Blocked an Anon Request (%d > %d)" % (
                        GLSetting.anomalies_counter[element],
                        alarm_level[element]
                    ))
                    raise errors.FloodException(30)
                elif element == 'file_uploaded':
                    log.debug("Blocked a File upload (%d > %d)" % (
                        GLSetting.anomalies_counter[element],
                        alarm_level[element]
                    ))
                    raise errors.FileUploadFlood(30)
                else:
                    log.debug("Blocked an Unknown event (=%s) !? [BUG!] (%d > %d)" % (
                        element,
                        GLSetting.anomalies_counter[element],
                        alarm_level[element]
                    ))
                    raise errors.FloodException(30)

            return method_handler(cls, *args, **kw)
        return call_handler

    return wrapper

import os
from pathlib import Path
from datetime import datetime
from datetime import timedelta

import jwt
import tornado.web
import tornado.websocket
from utilities import db_utils
from utilities import cron_utils

class SocketBase(tornado.websocket.WebSocketHandler):
    def initialize(self, socket_manager):
        self.db_manager = db_utils.DatabaseManager(read_configuration())
        self.socket_manager = socket_manager

    def on_close(self):
        self.socket_manager.leave(self)

class BaseHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = tornado.web.RequestHandler.SUPPORTED_METHODS + ('BREW',)

    def initialize(self, socket_manager=None):
        self.set_header('X-Frame-Options', 'DENY')
        self.set_header('X-XSS-Protection', '1; mode=block')
        self.set_header('X-Content-Type-Options', 'nosniff')
        self.set_header('Referrer-Policy', 'same-origin')
        self.set_header('Content-Security-Policy', 'default-src \'self\' \'unsafe-inline\'; img-src \'self\' data:;')

        if socket_manager is not None:
            self.socket_manager = socket_manager

    @tornado.web.removeslash
    def prepare(self):
        """
        Setup a database session, initialise application configuration,
        handle user sessions validation and verify user access rights.
        """
        self.system_configuration = read_configuration()
        self.settings['cookie_secret'] = self.system_configuration['cookie_secret']
        self.db_manager = db_utils.DatabaseManager(self.system_configuration)
        self.cron_manager = cron_utils.CRONManager()
        self.jwt_secret = self.system_configuration['jwt_secret']
        self.config = {
            'event_name': 'Event' # placeholder
        }
        redirect_exclusions = [
            '/',
            '/login',
            '/register'
        ]
        remote = bool('/remote' in self.request.uri)

        if self.current_user is None and self.request.uri not in redirect_exclusions and not remote:
            self.redirect('/')
            return
        elif self.current_user is not None:
            cur_user = self.current_user
            cur_user['exp'] = datetime.utcnow() + timedelta(hours=1)
            self.config['user'] = cur_user
            self.set_secure_cookie('user', self.encode_jwt(cur_user))

        if '/admin' in self.request.uri:
            if not self.current_user or cur_user['role'] != 'admin':
                self.redirect('/')

        if self.db_manager.get_error_state() is True:
            self.write('Database authentication failed.')
            self.finish()

    def get_current_user(self):
        cookie = self.get_secure_cookie('user')
        decoded_jwt = None

        if cookie is not None:
            try:
                decoded_jwt = jwt.decode(cookie, self.jwt_secret, algorithms=['HS256'])
            except jwt.ExpiredSignatureError:
                self.redirect('/logout')
                return
            except jwt.DecodeError:
                self.redirect('/logout')
                return
        else:
            self.clear_all_cookies()                    

        return decoded_jwt

    def encode_jwt(self, payload):
        return jwt.encode(payload, self.jwt_secret, algorithm='HS256')

    @staticmethod
    def build_jwt_payload(user):
        return {
            '_id': str(user['_id']),
            'first_name': user['first_name'],
            'last_name': user['last_name'],
            'username': user['username'],
            'role': user['role'],
            'email': user['email'],
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(hours=1)
        }

    def write_error(self, status_code, **kwargs):
        """
        Handle non 404 errors.
        """
        message = 'An unexpected error has occurred. Please try your request again.'
        config = {
            'page_name': 'error',
            'event_name': 'Error'
        }

        self.render('error.html',
                    heading='Something went wrong :(',
                    config=config,
                    message=message)

    def check_xsrf_cookie(self):
        if self.request.method != 'BREW' and '/remote/' not in self.request.uri:
            tornado.web.RequestHandler.check_xsrf_cookie(self)

    def brew(self):
        self.set_status(418, "Easter Egg")
        self.write('Error 418: I am a teapot.')

class PageNotFoundHandler(BaseHandler):
    def prepare(self):
        super().prepare()
        self.config['page_name'] = 'error'

    def get(self):
        """
        Handle 404 errors.
        """
        self.set_status(404)
        message = 'The page you are looking for cannot be found.'
        self.render('error.html',
                    heading='404 Not Found',
                    config=self.config,
                    message=message)

def read_configuration():
    parent = str(Path(__file__).resolve().parents[1])
    path = os.path.join(parent, 'config.conf')
    config = {}

    with open(path, 'r') as conf_file:
        for line in conf_file:
            pair = line.split('=')
            config[pair[0]] = pair[1].strip()

    return config

"""
The ``server`` is the backbone of the BUCSS CTF Framework handling all
interactions between users and the framework.

.. codeauthor:: Alex Seymour <alex@luciddev.tech>
"""
import os
import uuid
import logging

import tornado.web
import tornado.httpserver
import tornado.ioloop
import tornado.options
from handlers import uimodules
from handlers import base
from handlers import index
from handlers import register
from handlers import login
from handlers import logout
from handlers import account
from handlers import events
from handlers import leaderboard
from handlers import sockets
from handlers import download
from handlers.admin import events as admin_events
from handlers.admin import users as admin_users
from handlers.admin import sites as admin_sites
from handlers.admin import settings as admin_settings
from handlers.admin import auth as admin_auth
from handlers.admin import leaderboards as admin_leaderboards
from handlers.admin import categories as admin_categories
from handlers.admin import challenges as admin_challenges
from handlers.admin import files as admin_files
from handlers.remote import cron
from utilities import socket_utils

class Application(tornado.web.Application):
    """
    Sets up the Tornado Web Framework :py:class:`tornado.web.Application` object.
    This class defines applications settings and routing information for HTTP requests.
    """
    def __init__(self, socket_manager):                    
        """
        Defines routing information for HTTP requests in the ``handlers`` list along
        with application configuration details in the ``settings`` dict.

        :param socket_manager: An instance of :py:class:`.SocketManager`
        """
        handlers = [
            (r'/', index.IndexHandler),
            (r'/register/?', register.RegisterHandler),
            (r'/login/?', login.LoginHandler),
            (r'/logout/?', logout.LogoutHandler),
            (r'/account/?', account.AccountHandler),
            (r'/events/?', events.EventListingHandler),
            (r'/events/register/(.*)/?', events.RegisterHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/challenges/?', events.EventHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/challenges/(.*)/?', events.EventHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/leaderboard/?', leaderboard.EventLeaderboardHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/leaderboard/user/(.*)/?', leaderboard.UserStatisticsHandler),
            (r'/download/(.*)/(.*)/?', download.DownloadHandler),
            (r'/leaderboard/?', leaderboard.GlobalLeaderboardHandler),
            (r'/socket/leaderboard/(.*)/?', sockets.LeaderboardSocket, dict(socket_manager=socket_manager)),
            (r'/socket/event/(.*)/?', sockets.EventSocket, dict(socket_manager=socket_manager)),
            (r'/admin/events/?', admin_events.EventsHandler),
            (r'/admin/events/edit/(.*)/?', admin_events.EditEventHandler),
            (r'/admin/events/start/(.*)&redirect=(.*)/?', admin_events.StartEventHandler, dict(socket_manager=socket_manager)),
            (r'/admin/events/stop/(.*)&redirect=(.*)/?', admin_events.StopEventHandler, dict(socket_manager=socket_manager)),
            (r'/admin/events/lock/(.*)&redirect=(.*)/?', admin_events.LockEventHandler),
            (r'/admin/events/unlock/(.*)&redirect=(.*)/?', admin_events.UnlockEventHandler),
            (r'/admin/events/answers/lock/(.*)&redirect=(.*)/?', admin_events.LockAnswersHandler),
            (r'/admin/events/answers/unlock/(.*)&redirect=(.*)/?', admin_events.UnlockAnswersHandler),
            (r'/admin/files/delete/(.*)/(.*)&redirect=(.*)/?', admin_files.DeleteHandler),
            (r'/admin/leaderboard/reset/(.*)/event/(.*)&redirect=(.*)/?', admin_leaderboards.ResetBoardHandler),
            (r'/admin/categories/delete/(.*)&redirect=(.*)/?', admin_categories.DeleteCategoryHandler),
            (r'/admin/challenges/delete/(.*)&redirect=(.*)/?', admin_challenges.DeleteChallengeHandler),
            (r'/admin/users/?', admin_users.UsersHandler),
            (r'/admin/users/approve/(.*)/?', admin_auth.ApproveUserHandler),
            (r'/admin/users/reject/(.*)/?', admin_auth.RejectUserHandler),
            (r'/admin/users/resetpassword/(.*)/?', admin_auth.ResetUserPasswordHandler),
            (r'/admin/users/lock/(.*)/?', admin_auth.LockUserHandler),
            (r'/admin/users/unlock/(.*)/?', admin_auth.UnlockUserHandler),
            (r'/admin/users/promote/(.*)/?', admin_auth.MakeUserAdminHandler),
            (r'/admin/users/demote/(.*)/?', admin_auth.RevokeUserAdminHandler),
            (r'/admin/users/delete/(.*)/?', admin_auth.DeleteUserHandler),
            (r'/admin/settings/?', admin_settings.SettingsHandler),
            (r'/admin/sites/?', admin_sites.SitesHandler),
            (r'/admin/sites/delete/(.*)/?', admin_sites.DeleteSiteHandler),
            (r'/remote/schedule/update/event/(.*)/action/(.*)/auth/(.*)/?', cron.UpdateEventHandler, dict(socket_manager=socket_manager)),
            (r'/.*/?', base.PageNotFoundHandler)
        ]

        settings = {
            'debug': False,
            'template_path': os.path.join(os.path.dirname(__file__), 'templates'),
            'static_path': os.path.join(os.path.dirname(__file__), 'static'),
            'ui_modules': uimodules,
            'cookie_secret': str(uuid.uuid4()),
            'xsrf_cookies': True                    
        }
        tornado.web.Application.__init__(self, handlers, **settings)

if __name__ == '__main__':
    if os.path.exists('logs/') is False:
        os.makedirs('logs/', exist_ok=True)

    tornado.options.options['log_file_prefix'] = 'logs/log.log'
    tornado.options.options['logging'] = 'warning'
    tornado.options.parse_command_line()

    socket_manager = socket_utils.SocketManager()
    app = Application(socket_manager)
    server = tornado.httpserver.HTTPServer(app)
    server.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

"""
The ``server`` is the backbone of the BUCSS CTF Framework handling all
interactions between users and the framework.

.. codeauthor:: Alex Seymour <alex@luciddev.tech>
"""
import os
import uuid
import logging

import tornado.web
import tornado.httpserver
import tornado.ioloop
import tornado.options
from handlers import uimodules
from handlers import base
from handlers import index
from handlers import register
from handlers import login
from handlers import logout
from handlers import account
from handlers import events
from handlers import leaderboard
from handlers import sockets
from handlers import download
from handlers.admin import events as admin_events
from handlers.admin import users as admin_users
from handlers.admin import sites as admin_sites
from handlers.admin import settings as admin_settings
from handlers.admin import auth as admin_auth
from handlers.admin import leaderboards as admin_leaderboards
from handlers.admin import categories as admin_categories
from handlers.admin import challenges as admin_challenges
from handlers.admin import files as admin_files
from handlers.remote import cron
from utilities import socket_utils

class Application(tornado.web.Application):
    """
    Sets up the Tornado Web Framework :py:class:`tornado.web.Application` object.
    This class defines applications settings and routing information for HTTP requests.
    """
    def __init__(self, socket_manager, xsrf_cookies=True):
        """
        Defines routing information for HTTP requests in the ``handlers`` list along
        with application configuration details in the ``settings`` dict.

        :param socket_manager: An instance of :py:class:`.SocketManager`
        """
        handlers = [
            (r'/', index.IndexHandler),
            (r'/register/?', register.RegisterHandler),
            (r'/login/?', login.LoginHandler),
            (r'/logout/?', logout.LogoutHandler),
            (r'/account/?', account.AccountHandler),
            (r'/events/?', events.EventListingHandler),
            (r'/events/register/(.*)/?', events.RegisterHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/challenges/?', events.EventHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/challenges/(.*)/?', events.EventHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/leaderboard/?', leaderboard.EventLeaderboardHandler, dict(socket_manager=socket_manager)),
            (r'/events/(.*)/leaderboard/user/(.*)/?', leaderboard.UserStatisticsHandler),
            (r'/download/(.*)/(.*)/?', download.DownloadHandler),
            (r'/leaderboard/?', leaderboard.GlobalLeaderboardHandler),
            (r'/socket/leaderboard/(.*)/?', sockets.LeaderboardSocket, dict(socket_manager=socket_manager)),
            (r'/socket/event/(.*)/?', sockets.EventSocket, dict(socket_manager=socket_manager)),
            (r'/admin/events/?', admin_events.EventsHandler),
            (r'/admin/events/edit/(.*)/?', admin_events.EditEventHandler),
            (r'/admin/events/start/(.*)&redirect=(.*)/?', admin_events.StartEventHandler, dict(socket_manager=socket_manager)),
            (r'/admin/events/stop/(.*)&redirect=(.*)/?', admin_events.StopEventHandler, dict(socket_manager=socket_manager)),
            (r'/admin/events/lock/(.*)&redirect=(.*)/?', admin_events.LockEventHandler),
            (r'/admin/events/unlock/(.*)&redirect=(.*)/?', admin_events.UnlockEventHandler),
            (r'/admin/events/answers/lock/(.*)&redirect=(.*)/?', admin_events.LockAnswersHandler),
            (r'/admin/events/answers/unlock/(.*)&redirect=(.*)/?', admin_events.UnlockAnswersHandler),
            (r'/admin/files/delete/(.*)/(.*)&redirect=(.*)/?', admin_files.DeleteHandler),
            (r'/admin/leaderboard/reset/(.*)/event/(.*)&redirect=(.*)/?', admin_leaderboards.ResetBoardHandler),
            (r'/admin/categories/delete/(.*)&redirect=(.*)/?', admin_categories.DeleteCategoryHandler),
            (r'/admin/challenges/delete/(.*)&redirect=(.*)/?', admin_challenges.DeleteChallengeHandler),
            (r'/admin/users/?', admin_users.UsersHandler),
            (r'/admin/users/approve/(.*)/?', admin_auth.ApproveUserHandler),
            (r'/admin/users/reject/(.*)/?', admin_auth.RejectUserHandler),
            (r'/admin/users/resetpassword/(.*)/?', admin_auth.ResetUserPasswordHandler),
            (r'/admin/users/lock/(.*)/?', admin_auth.LockUserHandler),
            (r'/admin/users/unlock/(.*)/?', admin_auth.UnlockUserHandler),
            (r'/admin/users/promote/(.*)/?', admin_auth.MakeUserAdminHandler),
            (r'/admin/users/demote/(.*)/?', admin_auth.RevokeUserAdminHandler),
            (r'/admin/users/delete/(.*)/?', admin_auth.DeleteUserHandler),
            (r'/admin/settings/?', admin_settings.SettingsHandler),
            (r'/admin/sites/?', admin_sites.SitesHandler),
            (r'/admin/sites/delete/(.*)/?', admin_sites.DeleteSiteHandler),
            (r'/remote/schedule/update/event/(.*)/action/(.*)/auth/(.*)/?', cron.UpdateEventHandler, dict(socket_manager=socket_manager)),
            (r'/.*/?', base.PageNotFoundHandler)
        ]

        settings = {
            'debug': False,
            'template_path': os.path.join(os.path.dirname(__file__), 'templates'),
            'static_path': os.path.join(os.path.dirname(__file__), 'static'),
            'ui_modules': uimodules,
            'cookie_secret': str(uuid.uuid4()),
            'xsrf_cookies': xsrf_cookies,                    
            'xsrf_cookies_kwargs': {'HttpOnly': True}                    
        }
        tornado.web.Application.__init__(self, handlers, **settings)

if __name__ == '__main__':
    if os.path.exists('logs/') is False:
        os.makedirs('logs/', exist_ok=True)

    tornado.options.options['log_file_prefix'] = 'logs/log.log'
    tornado.options.options['logging'] = 'warning'
    tornado.options.parse_command_line()

    socket_manager = socket_utils.SocketManager()
    app = Application(socket_manager)
    server = tornado.httpserver.HTTPServer(app)
    server.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

"""
The `base` modules act as a parent class for request and websocket handlers, performing
common operations, setting configurations and utility methods.

.. codeauthor:: Alex Seymour <alex@luciddev.tech>
"""

import os
import functools
from pathlib import Path
from datetime import datetime
from datetime import timedelta

import jwt
import tornado.web
import tornado.websocket
from utilities import db_utils
from utilities import cron_utils

class SocketBase(tornado.websocket.WebSocketHandler):
    """
    Derives from :py:class:`tornado.websocket.WebSocketHandler`.

    :class:`.SocketBase` acts as the parent class for all websocket handlers.
    """
    def initialize(self, socket_manager):
        """
        Setup a :class:`.DatabaseManager` and :class:`.SocketManager` within
        the scope of ``self``.

        :param socket_manager: An instance of :class:`.SocketManager`
        """
        self.db_manager = db_utils.DatabaseManager(read_configuration())
        self.socket_manager = socket_manager

    def on_close(self):
        """
        Remove clients from their subscribed room(s) when their connection is
        closed.
        """
        self.socket_manager.leave(self)

    def check_origin(self, origin):
        """
        Ensures that websockets are not blocked - an issue found when trying
        to use Firefox to access the site behind Nginx.
        """
        return True

class BaseHandler(tornado.web.RequestHandler):
    """
    Derives from :py:class:`tornado.web.RequestHandler`.

    :class:`.BaseHandler` acts as the parent class for all request handlers.
    """
    tornado.web.RequestHandler.SUPPORTED_METHODS = tornado.web.RequestHandler.SUPPORTED_METHODS + ('BREW',)

    def removeslash(method):
        """
        A customised version to :py:func:`tornado.web.removeslash` which allows
        BREW as a valid HTTP method to enable the 418 easter egg.
        """
        @functools.wraps(method)
        def wrapper(self, *args, **kwargs):
            if self.request.path.endswith('/'):
                if self.request.method in ('GET', 'HEAD', 'BREW'):
                    uri = self.request.path.rstrip('/')
                    if uri:
                        self.redirect(uri, permanent=True)
                        return
                else:
                    raise tornado.web.HTTPError(404)
            return method(self, *args, **kwargs)
        return wrapper

    def initialize(self, socket_manager=None):
        """
        Sets response headers for all HTTP responses and initialises a :class:`.SocketManager`
        if one is passed in.

        :param socket_manager: An instance of :class:`.SocketManager`
        """
        self.set_header('X-Frame-Options', 'DENY')
        self.set_header('X-XSS-Protection', '1; mode=block')
        self.set_header('X-Content-Type-Options', 'nosniff')
        self.set_header('Referrer-Policy', 'same-origin')
        self.set_header('Content-Security-Policy', 'default-src \'self\' \'unsafe-inline\'; img-src \'self\' data:; script-src \'self\' \'unsafe-eval\' \'unsafe-inline\' data:; connect-src \'self\' ws:;')

        if socket_manager is not None:
            self.socket_manager = socket_manager

    @removeslash
    def prepare(self):
        """
        Setup a database session, initialise application configuration,
        handle user sessions validation and verify user access rights.
        """
        self.system_configuration = read_configuration()
        self.settings['cookie_secret'] = self.system_configuration['cookie_secret']
        self.db_manager = db_utils.DatabaseManager(self.system_configuration)
        self.cron_manager = cron_utils.CRONManager()
        self.jwt_secret = self.system_configuration['jwt_secret']
        remote = bool('/remote' in self.request.uri)
        redirect_exclusions = [
            '/',
            '/login',
            '/register',
            '/leaderboard'
        ]
        db_settings = self.db_manager.retrieve_settings()

        if db_settings is not None:
            self.system_configuration.update(db_settings)
        else:
            self.system_configuration['site_title'] = 'BUCSS CTF Framework'
            self.system_configuration['end_message'] = 'This event has now finished.'

        self.config = {
            'site_title': self.system_configuration['site_title']
        }

        if self.current_user is None and self.request.uri not in redirect_exclusions and not remote:
            self.redirect('/')
            return
        elif self.current_user is not None:
            cur_user = self.current_user
            cur_user['exp'] = datetime.utcnow() + timedelta(hours=1)
            self.config['user'] = cur_user
            self.set_secure_cookie('user', self.encode_jwt(cur_user), httponly=True)

        if '/admin' in self.request.uri:
            if not self.current_user or cur_user['role'] != 'admin':
                self.redirect('/')
                return

        if self.db_manager.get_error_state() is True:
            self.set_status(401)
            self.write('Database authentication failed.')
            self.finish()

    def get_current_user(self):
        """
        Retrieves and decrypts the JWT stored in the user cookie.
        If the JWT fails to validate the user is automatically logged out.

        :returns: dict
        """
        cookie = self.get_secure_cookie('user')
        decoded_jwt = None

        if cookie is not None:
            try:
                decoded_jwt = jwt.decode(cookie, self.jwt_secret, algorithms=['HS256'])
            except jwt.ExpiredSignatureError:
                self.redirect('/logout')
                return
            except jwt.DecodeError:
                self.redirect('/logout')
                return
        else:
            self.clear_cookie('user')

        return decoded_jwt

    def encode_jwt(self, payload):
        """
        Creates and encrypts a JWT from a dictionary.

        .. note::
            Payload should be the result of :func:`build_jwt_payload`.

        :param payload: The JWT payload.
        :type payload: dict
        """
        return jwt.encode(payload, self.jwt_secret, algorithm='HS256')

    @staticmethod
    def build_jwt_payload(user):
        """
        Builds a valid JWT payload.

        :param user: A user document retrieved from the database.
        :type user: :py:class:`pymongo.cursor.Cursor`
        """
        return {
            '_id': str(user['_id']),
            'first_name': user['first_name'],
            'last_name': user['last_name'],
            'username': user['username'],
            'role': user['role'],
            'email': user['email'],
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(hours=1)
        }

    def write_error(self, status_code, **kwargs):
        """
        Handle non 404 errors.
        """
        self.config['page_name'] = 'error'
        self.config['site_title'] = 'error'
        message = 'An unexpected error has occurred. Please try your request again.'

        self.render('error.html',
                    heading='Something went wrong :(',
                    config=self.config,
                    message=message)

    def check_xsrf_cookie(self):
        """
        Checks XSRF token are valid if the request comes from a valid path/method.

        XSRF checks are ignored for the BREW method so that the correct error code can be sent.
        """
        if self.request.method != 'BREW' and '/remote/' not in self.request.uri:
            tornado.web.RequestHandler.check_xsrf_cookie(self)                    

    def brew(self):
        """
        Returns error 418 if a request is made with the BREW method.
        """
        self.set_status(418, 'I am a teapot.')
        self.write('Error 418: I am a teapot.')

class PageNotFoundHandler(BaseHandler):
    """
    **Path:** (.*)

    Handles any requests that do not match any other route.
    """
    def prepare(self):
        """
        Inherits from :func:`BaseHandler.prepare` and sets the ``page_name``.
        """
        super().prepare()
        self.config['page_name'] = 'error'

    def get(self):
        """
        Display the ``error.html`` template customised for a 404 error.
        """
        self.set_status(404)
        message = 'The page you are looking for cannot be found.'
        self.render('error.html',
                    heading='404 Not Found',
                    config=self.config,
                    message=message)

def read_configuration():
    """
    Reads the config.conf file and returns a dictionary of the contents.

    :returns: dict
    """
    parent = str(Path(__file__).resolve().parents[1])
    path = os.path.join(parent, 'config.conf')
    config = {}

    with open(path, 'r') as conf_file:
        for line in conf_file:
            pair = line.split('=')
            config[pair[0]] = pair[1].strip()

    return config

#!/usr/bin/env python2
# coding: utf-8

import os
import sys
import socket
import string
import time
import urllib2
import HTMLParser
import zlib

import libirc

HOST="irc.freenode.net"
PORT=6667
NICK="titlebot"
IDENT="titlebot"
REALNAME="titlebot"
CHANS=["##Orz"]

def ParseURL(s):
    http_idx=s.find('http:')
    https_idx=s.find('https:')
    if https_idx==-1:
        if http_idx==-1:
            return None
        else:
            return s[http_idx:]
    else:
        if http_idx==-1:
            return s[https_idx:]
        else:
            return s[min(http_idx, https_idx):]

try:
    c=libirc.IRCConnection()
    c.connect((HOST, PORT))
    c.setnick(NICK)
    c.setuser(IDENT, REALNAME)
    for CHAN in CHANS:
        c.join(CHAN)
except:
    time.sleep(10)
    sys.stderr.write("Restarting...\n")
    os.execlp("python2", "python2", __file__)
    raise
CHAN=CHANS[0]
socket.setdefaulttimeout(10)

html_parser=HTMLParser.HTMLParser()

quiting=False
while not quiting:
    if not c.sock:
        quiting=True
        time.sleep(10)
        sys.stderr.write("Restarting...\n")
        os.execlp("python2", "python2", __file__)
        break
    try:
        line=c.recvline(block=True)
        if not line:
            continue
        sys.stderr.write("%s\n" % line.encode('utf-8', 'replace'))
        line=c.parse(line=line)
        if line and line["cmd"]=="PRIVMSG":
            if line["dest"]==NICK:
                if line["msg"]==u"Get out of this channel!": # A small hack
                    c.quit(u"%s asked to leave." % line["nick"])
                    quiting=True
            else:
                CHAN=line["dest"]
                for w in line["msg"].split():
                    w=ParseURL(w)
                    if w:
                        w=w.split(">", 1)[0].split('"', 1)[0]
                        if re.match("https?:/*git.io(/|$)", w): # Fix buggy git.io
                            continue
                        opener=urllib2.build_opener()
                        opener.addheaders = [("Accept-Charset", "utf-8, iso-8859-1"), ("Accept-Language", "zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en"), ("Range", "bytes=0-16383"), ("User-Agent", "Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)"), ("X-Forwarded-For", "10.2.0.101"), ("X-moz", "prefetch"), ("X-Prefetch", "yes")]                    
                        h=opener.open(w.encode("utf-8", "replace"))
                        if h.code==200 or h.code==206:
                            if not "Content-Type" in h.info() or h.info()["Content-Type"].split(";")[0]=="text/html":
                                wbuf=h.read(16384)
                                read_times=1
                                while len(wbuf)<16384 and read_times<4:
                                    read_times+=1
                                    wbuf_=h.read(16384)
                                    if wbuf_:
                                        wbuf+=wbuf_
                                    else:
                                        break
                                if "Content-Encoding" in h.info() and h.info()["Content-Encoding"]=="gzip": # Fix buggy www.bilibili.tv
                                    try:
                                        gunzip_obj=zlib.decompressobj(16+zlib.MAX_WBITS)
                                        wbuf=gunzip_obj.decompress(wbuf)
                                    except:
                                        pass
                                if wbuf.find("<title>")!=-1:
                                    titleenc=wbuf.split("<title>")[1].split("</title>")[0]
                                    title=None
                                    for enc in ("utf-8", "gbk", "gb18030", "iso-8859-1"):
                                        try:
                                            title=titleenc.decode(enc)
                                            break
                                        except UnicodeDecodeError:
                                            pass
                                    if title==None:
                                        title=title.decode("utf-8", "replace")
                                    title=html_parser.unescape(title).replace("\r", "").replace("\n", " ").strip()
                                    c.say(CHAN, u": %s" % title)
                                else:
                                    c.say(CHAN, u"")
                            else:
                                if "Content-Range" in h.info():
                                    c.say(CHAN, u": %s, : %s \r\n" % (h.info()["Content-Type"], h.info()["Content-Range"].split("/")[1]))
                                elif "Content-Length" in h.info():
                                    c.say(CHAN, u": %s, : %s \r\n" % (h.info()["Content-Type"], h.info()["Content-Length"]))
                                else:
                                    c.say(CHAN, u": %s\r\n" % h.info()["Content-Type"])
                        else:
                            c.say(CHAN, u"HTTP %d \r\n" % h.code)
    except Exception as e:
        try:
            c.say(CHAN, u"%s : %s" % (NICK, e))
        except:
            pass
    except socket.error as e:
        sys.stderr.write("Error: %s\n", e)
        c.quit("Network error.")

# vim: et ft=python sts=4 sw=4 ts=4

#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import os

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template
from openid.consumer.consumer import Consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions import sreg
from openid.extensions import ax

from aeoid import store
from aeoid import users


class BaseHandler(webapp.RequestHandler):
  def initialize(self, request, response):
    super(BaseHandler, self).initialize(request, response)
    self.session = self.request.environ.get('aeoid.beaker.session')

  def render_template(self, filename, template_args=None):
    if not template_args:
      template_args = {}
    path = os.path.join(os.path.dirname(__file__), 'templates', filename)
    self.response.out.write(template.render(path, template_args))

  def get_consumer(self):
    return Consumer(self.session, store.AppEngineStore())


class BeginLoginHandler(BaseHandler):
  def get(self):
    openid_url = self.request.get('openid_url')
    if not openid_url:
      self.render_template('login.html', {
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
      return

    try:
      consumer = self.get_consumer()
      request = consumer.begin(openid_url)
			
      # TODO: Support custom specification of extensions
      # TODO: Don't ask for data we already have, perhaps?
      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    
      ax_req = ax.FetchRequest()
      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))
      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))
      request.addExtension(ax_req)
      
      continue_url = self.request.get('continue', '/')
      return_to = "%s%s?continue=%s" % (self.request.host_url,
                                        users.OPENID_FINISH_PATH, continue_url)
      self.redirect(request.redirectURL(self.request.host_url, return_to))
      self.session.save()                    
    except DiscoveryFailure, ex:
      logging.error("Unexpected error in OpenID authentication: %s" % ex)
      self.render_template('error.html', {'identity_url': openid_url})


  def post(self):
    self.get()


class FinishLoginHandler(BaseHandler):
  def finish_login(self, response):
    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}
    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    #if ax_fetch:
    #  ax_data = ax_fetch.getExtensionArgs();
    #else:
    #  ax_data = {}
      
    #for k, v in ax_data.items():
    #  logging.info("key: " + k + ", value: " + v)
    
    #user_info = users.UserInfo.update_or_insert(
    #    response.endpoint.claimed_id,
    #    server_url=response.endpoint.server_url,
    #    **dict(sreg_data))

    ax_data = {}
    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    if ax_fetch:
      args = ax_fetch.getExtensionArgs()
      i = 0
      while "type.ext%i" % i in args:
        t = args["type.ext%i" % i]
        logging.info("type: %s" % t)
        if t == "http://axschema.org/namePerson/first":
          p = "nickname"
        elif t == "http://axschema.org/contact/email":
          p = "email"
        else:
          p = "unknown"
        ax_data[p] = args["value.ext%i.1" % i]
        i = i + 1

    res_data = {}
    res_data.update(sreg_data)
    res_data.update(ax_data)
    
    user_info = users.UserInfo.update_or_insert(
        response.endpoint.claimed_id,
        server_url=response.endpoint.server_url,
        **dict(res_data))
    
    self.session['aeoid.user'] = str(user_info.key())
    self.session.save()                    
    users._current_user = users.User(None, _from_model_key=user_info.key(),
                                     _from_model=user_info)
    self.redirect(self.request.get('continue', '/'))                    

  def get(self):
    consumer = self.get_consumer()
    response = consumer.complete(self.request.GET, self.request.url)
    if response.status == 'success':
      self.finish_login(response)
    elif response.status in ('failure', 'cancel'):
      self.render_template('failure.html', {
          'response': response,
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
    else:
      logging.error("Unexpected error in OpenID authentication: %s", response)
      self.render_template('error.html', {'identity_url': response.identity_url()})


class LogoutHandler(BaseHandler):
  def get(self):
    # TODO: Handle the possibility of XSRF forcing a user to log out
    if 'aeoid.user' in self.session:                    
      del self.session['aeoid.user']                    
    self.session.save()                    
    self.redirect(self.request.get('continue', '/'))                    


# highly modified from example at:
# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/
class StaticHandler(webapp.RequestHandler):
  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }
  
  def get(self, filepath, fileext):
    # build full system path to requested file
    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )
    
    # only allow specified file extensions
    if not self.allowed_exts.has_key(fileext):
      logging.error("Not an allowed file extension: %s" % fileext)
      self.error(404)
      return
    
    # file must exist before we can return it
    if not os.path.isfile(resourcepath):
      logging.error("Not an existing file: '%s'" % resourcepath)
      self.error(404)
      return
    
    # only allow absolute paths (no symlinks or up-level references, for example)
    testpath = os.path.normcase(resourcepath)
    if testpath != os.path.abspath(testpath):
      logging.error("Not an absolute path to file: '%s' != '%s'" % (testpath, os.path.abspath(testpath)) )
      self.error(403)
      return
    
    # set appropriate content-type
    self.response.headers['Content-Type'] = self.allowed_exts[fileext]
    
    # serve file (supporting client-side caching)
    try:
      import datetime
      fileinfo = os.stat(resourcepath)
      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])
      if self.request.headers.has_key('If-Modified-Since'):
        dt = self.request.headers.get('If-Modified-Since').split(';')[0]
        modsince = datetime.datetime.strptime(dt, "%a, %d %b %Y %H:%M:%S %Z")
        if modsince >= lastmod:
        # The file is older than the cached copy (or exactly the same)
          self.error(304)
          return
        else:
        # The file is newer
          self.output_file(resourcepath, lastmod)
      else:
        self.output_file(resourcepath, lastmod)
    except Exception, e:
      logging.error("Failed to serve file: %s" % e)
      self.error(404)
      return

  def output_file(self, resourcepath, lastmod):
    import datetime
    try:
      self.response.headers['Cache-Control']='public, max-age=31536000'
      self.response.headers['Last-Modified'] = lastmod.strftime("%a, %d %b %Y %H:%M:%S GMT")
      expires=lastmod+datetime.timedelta(days=365)
      self.response.headers['Expires'] = expires.strftime("%a, %d %b %Y %H:%M:%S GMT")
      self.response.out.write( file(resourcepath, 'rb').read() )
      return
    except IOError, e:
      logging.error("Failed to output file: %s" % e)
      self.error(404)
      return


handler_map = [
    (users.OPENID_LOGIN_PATH, BeginLoginHandler),
    (users.OPENID_FINISH_PATH, FinishLoginHandler),
    (users.OPENID_LOGOUT_PATH, LogoutHandler),
    (users.OPENID_STATIC_PATH, StaticHandler),
]

#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

def to_authorization_params(param):
    param_list = [
        'contact_name',
        'contact_email',
        'organization_name',
        'domain_write_permission',
        'read_permission',
        'full_read_permission',
        'search_permission',
        'subscribe_permission',
        'mark_notes_reviewed',
        'believed_dead_permission',
        'stats_permission',
        'is_valid',
    ]
    ret = {}
    for param_name in param_list:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href="%s">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class="email">%s</span>'
                % escape(user.email()))
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags)                    


class CreateOrUpdateApiKey(utils.BaseHandler):
    """A handler for create/update API keys."""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """Display a form for create/update Authorization"""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href="%s">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href="%s">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class="email">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """Handle a post request from the create/update/edit form"""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and                     
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))


# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""View-related code common to the whole app."""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """Base view class shared across the app."""

    # This should be overridden by subclasses.
    ACTION_ID = None

    _GET_PARAMETERS = {
        'lang': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        """Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = utils.Struct()
        self.read_params(get_params=BaseView._GET_PARAMETERS)

        # Set up env variable with data needed by the whole app.
        self.env = utils.Struct()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def read_params(self, get_params=None, post_params=None, file_params=None):
        """Reads CGI parameter values into self.params.

        Args:
            get_params (dict): A dictionary from GET parameter keys to validator
                functions.
            post_params (dict): A dictionary from POST parameter keys to
                validator functions.
            file_params (dict): A dictionary from POST parameter keys for
                uploaded files to validator functions.
        """
        if self.request.method == 'GET':
            if get_params:
                for key, validator in get_params.items():
                    if key in self.request.GET:
                        setattr(self.params, key,
                                validator(self.request.GET[key]))
        else:
            if post_params:
                for key, validator in post_params.items():
                    if key in self.request.POST:
                        setattr(self.params, key,
                                validator(self.request.POST[key]))
            if file_params:
                for key, validator in file_params.items():
                    if key in self.request.FILES:
                        setattr(self.params, key,
                                validator(self.request.FILES[key]))

    def _request_is_for_prefixed_path(self):
        """Checks if the request's path uses an optional path prefix."""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None):
        """Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """
        if path is None:
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, **template_vars):                    
        """Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """

        def get_vars():
            """A function returning vars, for use by the resources module."""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0))                    

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """Main entry point for a request-response process."""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError("You tried to pass in the %s method name as a "
                                "keyword argument to %s(). Don't do that." %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    "%s() received an invalid keyword %r. as_view "
                    "only accepts arguments that are already "
                    "attributes of the class." % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view


#!/usr/bin/python2.7
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from const import *                    
from model import *                    
from utils import *                    
import reveal                    


class Handler(BaseHandler):                    
    """An admin page to delete person records."""                    

    # After a repository is deactivated, we still need the admin page to be
    # accessible so we can edit its settings.
    ignore_deactivation = True                    

    repo_required = False                    
    admin_required = True                    

    def get(self):                    
        xsrf_tool = XsrfTool()                    
        user = users.get_current_user()                    
        self.render(                    
            'admin_delete_record.html',                    
            id=self.env.domain + '/person.',                    
            xsrf_token=xsrf_tool.generate_token(                    
                user.user_id(), 'admin_delete_record'))                    

    def post(self):                    
        xsrf_tool = XsrfTool()                    
        user = users.get_current_user()                    
        if not (self.params.xsrf_token and xsrf_tool.verify_token(                    
                    self.params.xsrf_token, user.user_id(),                    
                    'admin_delete_record')):                    
            self.error(403)                    
            return False                    
        # Redirect to the deletion handler with a valid signature.
        action = ('delete', str(self.params.id))                    
        self.redirect('/delete', id=self.params.id,                    
                      signature=reveal.sign(action))                    

"""Tests for the XSRF tool."""

import datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):
    """Test cases for utils.XsrfTool."""

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def test_gen_and_verify_good_token(self):
        """Tests generating and verifying a good token."""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_rejects_invalid_token(self):                    
        """Tests that an invalid token is rejected."""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))

    def test_rejects_expired_token(self):
        """Tests that an expired token is rejected."""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +
                                  datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def test_good_with_no_prior_key(self):
        """Tests a good token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_bad_with_no_prior_key(self):
        """Tests a bad token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))


"""Tools to help run tests against the Django app."""

import const
import utils

import scrape
import testutils.base


class ViewTestsBase(testutils.base.ServerTestsBase):
    """A base class for tests for the Django app."""

    _USER_ID = 'k'                    

    def setUp(self):
        super(ViewTestsBase, self).setUp()
        self._xsrf_tool = utils.XsrfTool()

    def login(self, is_admin=False):
        """Logs in the "user" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """
        self.testbed.setup_env(
            user_email='kay@mib.gov',                    
            user_id=ViewTestsBase._USER_ID,                    
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)                    

    def to_doc(self, response):
        """Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)

#!/usr/bin/env python

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient
import tornado.gen

import os
import random
import shutil
import json
import multiprocessing

from utilities import sort_naturally
import settings
import redditUserImageScraper

# Require a username and password in order to use the web interface. See ReadMe.org for details.
enable_authentication = False
#enable_authentication = True

if enable_authentication:
    import PasswordManager

# List of valid user ids (used to compare user cookie)
authenticated_users = []

videoExtensions = ('.mp4', '.webm')
supportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')

savedImagesCache = []
def generateSavedImagesCache(outputDir):
    global savedImagesCache
    # Clear cache in case already created
    savedImagesCache = []

    print('Creating Liked Saved cache...')
    
    for root, dirs, files in os.walk(outputDir):
        for file in files:
            if file.endswith(supportedExtensions):
                savedImagesCache.append(os.path.join(root, file))

    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))

def outputPathToServerPath(path):
    # This is a little weird
    return 'output' + path.split(settings.settings['Output_dir'])[1]

def getRandomImage(filteredImagesCache=None, randomImageFilter=''):
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])

    if filteredImagesCache:
        randomImage = random.choice(filteredImagesCache)
    else:
        randomImage = random.choice(savedImagesCache)

    print('\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))

    serverPath = outputPathToServerPath(randomImage)

    return randomImage, serverPath

#
# Tornado handlers
#

# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py
# https://www.tornadoweb.org/en/stable/guide/security.html

def login_get_current_user(handler):
    if enable_authentication:
        cookie = handler.get_secure_cookie("user")
        if cookie in authenticated_users:
            return cookie
        else:
            print("Bad/expired cookie received")
            return None
    else:
        return "authentication_disabled"

class AuthHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
class LoginHandler(AuthHandler):
    def get(self):
        if not enable_authentication:
            self.redirect("/")
        else:
            self.write('<html>'
                       '<head>'
	               '<title>Liked Saved Downloader</title>'
	               '<link rel="stylesheet" type="text/css" href="webInterfaceNoAuth/index.css">'
                       '</head>'
                       '<body><h1>Login Required</h1>'
                       '<form action="/login" method="post">'
                       'Name: <input type="text" name="name"><br />'
                       'Password: <input type="password" name="password">'
                       '{}'
                       '<br /><input type="submit" value="Sign in">'
                       '</form></body></html>'.format(self.xsrf_form_html()))

    def post(self):
        global authenticated_users
        # Test password
        if enable_authentication and PasswordManager.verify(self.get_argument("password")):
            # Generate new authenticated user session
            randomGenerator = random.SystemRandom()
            cookieSecret = str(randomGenerator.getrandbits(128))
            authenticated_user = self.get_argument("name") + "_" + cookieSecret
            authenticated_user = authenticated_user.encode()
            authenticated_users.append(authenticated_user)
            
            # Set the cookie on the user's side
            self.set_secure_cookie("user", authenticated_user)
            
            print("Authenticated user {}".format(self.get_argument("name")))
            
            # Let them in
            self.redirect("/")
        else:
            print("Refused user {} (password doesn't match any in database)".format(self.get_argument("name")))
            self.redirect("/login")
            
class LogoutHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        global authenticated_users
        
        if enable_authentication:
            print("User {} logging out".format(self.current_user))
            if self.current_user in authenticated_users:
                authenticated_users.remove(self.current_user)
            self.redirect("/login")
        else:
            self.redirect("/")

class AuthedStaticHandler(tornado.web.StaticFileHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
    @tornado.web.authenticated
    def prepare(self):
        pass

class HomeHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        self.render('webInterface/index.html')

def settingsToHtmlForm():
    settingsInputs = []

    for sectionSettingsPair in settings.settingsStructure:
        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))

        for sectionOption in sectionSettingsPair[1]:
            option = None
            optionComment = ''
            if type(sectionOption) == tuple:
                option = sectionOption[0]
                optionComment = '<p class="optionComment">{}</p>'.format(sectionOption[1])
            else:
                option = sectionOption
                
            if type(settings.settings[option]) == bool:
                settingsInputs.append('''<label for="{option}">{optionName}</label>
                                     <input type="checkbox" id="{option}" name="{option}" value="{optionValue}" {checkedState} />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment,
                                              checkedState=('checked' if settings.settings[option] else ''),
                                              optionValue=('1' if settings.settings[option] else '0')))
                
            elif type(settings.settings[option]) == int:
                settingsInputs.append('''<label for="{option}">{optionName}</label>
                                     <input type="number" id="{option}" name="{option}" value="{optionValue}" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,
                                              optionValue=settings.settings[option]))
                
            elif type(settings.settings[option]) == str:
                settingsInputs.append('''<label for="{option}">{optionName}</label>
                                     <input type="{type}" id="{option}" name="{option}" value="{optionValue}" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment, optionValue=settings.settings[option],
                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))

    return ''.join(settingsInputs)

class SettingsHandler(AuthHandler):
    def doSettings(self, afterSubmit):
        htmlSettingsForm = settingsToHtmlForm()
        settingsFilename = settings.getSettingsFilename()
        
        self.write('''<html>
                            <head>
                                  <link rel="stylesheet" type="text/css" href="webInterface/settings.css">
                                  <script type="text/javascript" src="webInterface/settings.js"></script>
                            </head>
                            <body>
                                  <h1>Liked Saved Downloader Settings</h1>
                                  <a href="/">Back to Homepage</a><br /><br />
                                  {}
                                  <p>Settings being read from {}</p>
                                  <form action="/settings" method="post">
                                       <input type="submit" value="Submit">
                                       {}
                                       <input type="submit" value="Submit">
                                  </form>
                            </body>
                      </html>'''
                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),
                           settingsFilename, htmlSettingsForm))                    

    @tornado.web.authenticated
    def get(self):
        self.doSettings(False)

    @tornado.web.authenticated
    def post(self):
        currentOutputDir = settings.settings['Output_dir']
        
        print('Received new settings')
        
        for option in settings.settings:
            newValue = self.get_argument(option, None)
            if not newValue:
                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes
                # This means the user set the value to false
                if type(settings.settings[option]) == bool:
                    settings.settings[option] = False
                else:
                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'
                          '\n\tIgnore this if the field is intentionally empty'.format(option))
            else:
                # All false bools are handed in the above if block, so we know they're true here
                if type(settings.settings[option]) == bool:
                    newValue = True
                elif type(settings.settings[option]) == int:
                    newValue = int(newValue)
                
                settings.settings[option] = newValue
                # print('\tSet {} = {}'.format(option, newValue))

        # Write out the new settings
        settings.writeServerSettings()
        
        # Respond with a settings page saying we've updated the settings
        self.doSettings(True)

        # Refresh the cache in case the output directory changed
        if currentOutputDir != settings.settings['Output_dir']:
            generateSavedImagesCache(settings.settings['Output_dir'])
            

class RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):
    connections = set()

    def cacheFilteredImages(self):
        # Clear the cache
        self.filteredImagesCache = []

        if not self.randomImageFilter:
            return

        randomImageFilterLower = self.randomImageFilter.lower()
    
        for imagePath in savedImagesCache:
            if randomImageFilterLower in imagePath.lower():
                self.filteredImagesCache.append(imagePath)

        print('\tFiltered images with "{}"; {} images matching filter'
              .format(self.randomImageFilter, len(self.filteredImagesCache)))

    def changeCurrentDirectory(self, newDirectory):
        self.currentDirectoryPath = newDirectory
        dirList = os.listdir(self.currentDirectoryPath)
        
        filteredDirList = []
        for fileOrDir in dirList:
            # The script spits out a lot of .json files the user probably doesn't want to see
            if (not fileOrDir.endswith('.json')
                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):
                filteredDirList.append(fileOrDir)
                
        self.currentDirectoryCache = sorted(filteredDirList)

    def open(self):
        if not login_get_current_user(self):
            return None
        
        self.connections.add(self)
        self.randomHistory = []
        self.randomHistoryIndex = -1
        self.favorites = []
        self.favoritesIndex = 0
        self.currentImage = None
        self.randomImageFilter = ''
        self.filteredImagesCache = []
        
        self.currentDirectoryPath = ''
        self.currentDirectoryCache = []
        self.directoryFilter = ''
        # Set up the directory cache with the top-level output
        self.changeCurrentDirectory(settings.settings['Output_dir'])

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RandomImageBrowserWebSocket: Received message ', message)
        parsedMessage = json.loads(message)
        command = parsedMessage['command']
        print('RandomImageBrowserWebSocket: Command ', command)
        action = ''

        """
         Random Image Browser
        """

        if command == 'imageAddToFavorites':
            if self.currentImage:
                self.favorites.append(self.currentImage)
                self.favoritesIndex = len(self.favorites) - 1

        if command == 'nextFavorite':
            self.favoritesIndex += 1
            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):
                action = 'setImage'
                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]
            else:
                self.favoritesIndex = len(self.favorites) - 1
                if len(self.favorites):
                    action = 'setImage'
                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'previousFavorite' and len(self.favorites):
            action = 'setImage'

            if self.favoritesIndex > 0:
                self.favoritesIndex -= 1
                
            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'nextImage':
            action = 'setImage'

            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:
                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)
                self.randomHistory.append((fullImagePath, serverImagePath))
                self.randomHistoryIndex = len(self.randomHistory) - 1
            else:
                self.randomHistoryIndex += 1
                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command == 'previousImage':
            action = 'setImage'

            if self.randomHistoryIndex > 0:
                self.randomHistoryIndex -= 1
                
            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):
            fullImagePath, serverImagePath = self.currentImage
                
            folder = fullImagePath[:fullImagePath.rfind('/')]
            imagesInFolder = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    if file.endswith(supportedExtensions):
                        imagesInFolder.append(os.path.join(root, file))
            sort_naturally(imagesInFolder)
            currentImageIndex = imagesInFolder.index(fullImagePath)
            if currentImageIndex >= 0:
                action = 'setImage'
                
                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)
                if nextImageIndex == len(imagesInFolder):
                    nextImageIndex = 0
                if nextImageIndex < 0:
                    nextImageIndex = len(imagesInFolder) - 1
                    
                fullImagePath = imagesInFolder[nextImageIndex]
                serverImagePath = outputPathToServerPath(fullImagePath)

        if command == 'setFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.randomImageFilter:
                self.randomImageFilter = newFilter
                self.cacheFilteredImages()

        """
         Directory browser
        """

        if command == 'setDirectoryFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.directoryFilter:
                self.directoryFilter = newFilter
                # Refresh cache with new filter
                self.changeCurrentDirectory(self.currentDirectoryPath)
                action = 'sendDirectory'

        if command == 'listCurrentDirectory':
            action = 'sendDirectory'

        if command == 'changeDirectory':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));
            action = 'sendDirectory'

        if command == 'directoryUp':
            # Don't allow going higher than output dir
            if self.currentDirectoryPath != settings.settings['Output_dir']:
                upDirectory = (settings.settings['Output_dir']  +
                               self.currentDirectoryPath[len(settings.settings['Output_dir'])
                                                         : self.currentDirectoryPath.rfind('/')])
                # Reset the filter (chances are the user only wanted to filter at one level
                self.directoryFilter = ''
                self.changeCurrentDirectory(upDirectory)
                action = 'sendDirectory'
            
        if command == 'directoryRoot':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory(settings.settings['Output_dir'])
            action = 'sendDirectory'

        """
         Actions
        """

        # Only send a response if needed
        if action == 'setImage':
            # Stupid hack
            if serverImagePath.endswith(videoExtensions):
                action = 'setVideo'
                
            self.currentImage = (fullImagePath, serverImagePath)
            responseMessage = ('{{"responseToCommand":"{}", "action":"{}", "fullImagePath":"{}", "serverImagePath":"{}"}}'
                               .format(command, action, fullImagePath, serverImagePath))
            self.write_message(responseMessage)

        if action == 'sendDirectory':
            directoryList = ''
            for path in self.currentDirectoryCache:
                isSupportedFile = path.endswith(supportedExtensions)
                isFile = '.' in path
                if path.endswith(videoExtensions):
                    fileType = 'video'
                elif isSupportedFile:
                    fileType = 'image'
                elif isFile:
                    fileType = 'file'
                else:
                    fileType = 'dir'
                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path
                directoryList += '{{"path":"{}", "type":"{}", "serverPath":"{}"}},'.format(path, fileType, serverPath)

            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it
            responseMessage = ('{{"responseToCommand":"{}", "action":"{}", "directoryList":[{}]}}'
                               .format(command, action, directoryList[:-1]))
            self.write_message(responseMessage)
            

    def on_close(self):
        self.connections.remove(self)

scriptPipeConnection = None
scriptProcess = None

def startScript():
    global scriptPipeConnection, scriptProcess
    
    # Script already running
    if scriptProcess and scriptProcess.is_alive():
        return
    
    scriptPipeConnection, childConnection = multiprocessing.Pipe()
    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,
                                            args=(childConnection,))
    scriptProcess.start()

runScriptWebSocketConnections = set()
class RunScriptWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        if not login_get_current_user(self):
            return None
        
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.add(self)

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RunScriptWebSocket: Received message ', message)

        parsedMessage = json.loads(message)
        command = parsedMessage['command']

        print('RunScriptWebSocket: Command ', command)
        
        if command == 'runScript':
            if scriptProcess and scriptProcess.is_alive():
                print('RunScriptWebSocket: Script already running')
                responseMessage = ('{{"message":"{}", "action":"{}"}}'
                                   .format('Script already running\\n', 'printMessage'))
                self.write_message(responseMessage)
                
            else:
                print('RunScriptWebSocket: Starting script')

                startScript()
                
                responseMessage = ('{{"message":"{}", "action":"{}"}}'
                                   .format('Running script\\n', 'printMessage'))
                self.write_message(responseMessage)

    def on_close(self):
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.remove(self)

def updateScriptStatus():
    # If no pipe or no data to receive from pipe, we're done
    # Poll() is non-blocking whereas recv is blocking
    if (not runScriptWebSocketConnections
        or not scriptPipeConnection
        or not scriptPipeConnection.poll()):
        return

    pipeOutput = scriptPipeConnection.recv()
    if pipeOutput:
        responseMessage = ('{{"message":"{}", "action":"{}"}}'
                           .format(pipeOutput.replace('\n', '\\n').replace('\t', ''),
                                   'printMessage'))
        
        for client in runScriptWebSocketConnections:
            client.write_message(responseMessage)

        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:
            # Script finished; refresh image cache
            print('Refreshing cache due to script finishing')
            generateSavedImagesCache(settings.settings['Output_dir'])
            responseMessage = ('{{"action":"{}"}}'
                               .format('scriptFinished'))
            
            for client in runScriptWebSocketConnections:
                client.write_message(responseMessage)

            scriptPipeConnection.close()

#
# Startup
#

def make_app():
    # Each time the server starts up, invalidate all cookies
    randomGenerator = random.SystemRandom()
    cookieSecret = str(randomGenerator.getrandbits(128))
    
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),
        
        # Login
        (r'/login', LoginHandler),
        (r'/logout', LogoutHandler),

        # Configure the script
        (r'/settings', SettingsHandler),

        # Handles messages for run script
        (r'/runScriptWebSocket', RunScriptWebSocket),

        # Handles messages for randomImageBrowser
        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),

        # Static files
        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),
        # Don't change this "output" here without changing the other places as well
        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),

        # Files served regardless of whether the user is authenticated. Only login page resources
        # should be in this folder, because anyone can see them
        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret=cookieSecret,
                                   login_url="/login")

if __name__ == '__main__':
    print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
    
    print('Loading settings...')
    settings.getSettings()

    print('Liked Saved output directory: ' + settings.settings['Output_dir'])
    if not settings.settings['Output_dir']:
        print('WARNING: No output directory specified! This will probably break things')
    
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])
    
    port = 8888
    print('\nStarting LikedSavedDownloader Server on port {}...'.format(port))
    app = make_app()

    # Generating a self-signing certificate:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={"certfile":"certificates/server_jupyter_based.crt.pem",
                                      "keyfile":"certificates/server_jupyter_based.crt.key"})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)
    updateStatusCallback.start()
    ioLoop.start()

# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir                    
import subprocess                    
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')                    

c = get_config()                    
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'                    
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)                    
c.NotebookApp.open_browser = False                    

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:                    
    if not os.path.isfile(PEM_FILE):                    
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new',                     
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',                    
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',                    
            '-keyout', PEM_FILE, '-out', PEM_FILE])                    
    c.NotebookApp.certfile = PEM_FILE                    

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:                    
    from IPython.lib import passwd                    
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])                    
    del os.environ['PASSWORD']                    

# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir                    
import subprocess                    
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')                    

c = get_config()                    
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'                    
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)                    
c.NotebookApp.open_browser = False                    

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:                    
    if not os.path.isfile(PEM_FILE):                    
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new',                     
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',                    
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',                    
            '-keyout', PEM_FILE, '-out', PEM_FILE])                    
    c.NotebookApp.certfile = PEM_FILE                    

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:                    
    from IPython.lib import passwd                    
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])                    
    del os.environ['PASSWORD']                    

from setuptools import find_packages, setup

setup(
    name='jupyter-notebook-gist',
    version='0.4.0',
    description='Create a gist from the Jupyter Notebook UI',
    author='Mozilla Firefox Data Platform',
    author_email='fx-data-platform@mozilla.com',
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    include_package_data=True,
    license='MPL2',
    install_requires=[
        'ipython >= 4',
        'notebook >= 4.2',                    
        'jupyter',
        'requests',
        'six',
        'widgetsnbextension',
    ],
    url='https://github.com/mozilla/jupyter-notebook-gist',
    zip_safe=False,
)



import scrapy
import json
# It seems like this reference is wrong but due to the different invocation of scrapy it is right
from scrapers.scrapy_couchcrawl.helpers.profileLinkExtractor import KeyExtractor
#from selenium import webdriver


class FetchProfileKeysSpider(scrapy.Spider):
    name = "fetch_profiles"
    login_url = "https://www.couchsurfing.com/users/sign_in"
    login_user = "q1686061@mvrht.net"
    login_password = "3R3fk*CP"

    login_data = {
        "user[login]": login_user,
        "user[password]": login_password,
    }

    custom_settings = {
        'ITEM_PIPELINES': {
            'scrapy_couchcrawl.pipelines.ProfilesPipeline': 400,
        },
        'AUTOTHROTTLE_ENABLED': True,
        'AUTOTHROTTLE_START_DELAY': 2,
        'AUTOTHROTTLE_MAX_DELAY': 60,
        'AUTOTHROTTLE_TARGET_CONCURRENCY': 1.0,
        'AUTOTHROTTLE_DEBUG': True,
    }

    # To be used for request debugging with local proxy; add as request parameter
    # meta={'proxy': 'http://127.0.0.1:8080'}

    # On what subject should be iterated?
    def start_requests(self):
        yield scrapy.Request(self.login_url, self.parse_login)                    

    def parse_login(self, response):
        # Send the request with our login data
        print("Login")
        print(response.url)                    
        yield scrapy.FormRequest.from_response(response, formdata=self.login_data, callback=self.start_crawl)                    

    def start_crawl(self, response):
        print("Start Crawl")
        print(response.url)                    
        key_extractor = KeyExtractor()

        # Iteration on all ProfileLinks
        # Some of these links are not accessible without login
        while key_extractor.hasMoreProfileLinks():
            links = key_extractor.getMoreProfileLinks()
            for link in links:

                about_link = link
                couch_link = link + "/couch"
                photos_link = link + "/photos"
                references_link = link + "/references"
                friends_link = link + "/friends"
                favorites_link = link + "/favorites"

                link_list = [about_link, couch_link, photos_link, references_link, friends_link, favorites_link]

                for sub_link in link_list:
                    yield scrapy.Request(url=sub_link, callback=self.parse)                    

    def parse(self, response):
        url_parts = response.url.split("/")

        if len(url_parts)==5:
            print("Mainpage")
            page_name = "Main"
            profile_name = url_parts[len(url_parts) - 1]
        else:
            print("Not Mainpage")
            page_name = url_parts[len(url_parts)-1]
            profile_name = url_parts[len(url_parts) - 2]

        websites = {"_id": profile_name, "URL":response.url, page_name:response.body.decode("utf-8")}
        yield {'websites': websites}



        #  def parse_
        #
        #       https: // www.couchsurfing.com / people / goodpennyworths / references?experience = all & per_page = 100 & type = host

import os.path
import datetime
import tornado.ioloop
import tornado.web
import motor.motor_tornado
import crawl
import slugify
import bleach
import bs4

from copy import deepcopy
from tornado import gen
from tornado import escape
from tornado.options import define, options, parse_command_line

import sys


define("port", default=8888, help="run on the given port", type=int)
define("debug", default=True, help="run in debug mode")
define("title", default="The Newsreel")


class BaseHandler(tornado.web.RequestHandler):
    @property
    def db(self):
        return self.settings['db']

    @property
    def collection(self):
        return self.settings['collection']


class MainHandler(BaseHandler):
    @gen.coroutine
    def get(self):
        check_rss_updates(self.collection)
        cursor = self.collection.find().sort([('date', -1)])
        docs = yield cursor.to_list(length=20)
        self.render("index.html", title=options.title, items=docs)


class PostHandler(BaseHandler):
    @gen.coroutine
    def get(self, slug):
        doc = yield self.collection.find_one({'slug': slug})
        # if not doc:
        #     raise tornado.web.HTTPError(404)
        self.render("post.html", title=options.title, item=doc)


class PostNewHandler(BaseHandler):
    def get(self):
        try:
            error = self.get_argument("error")
        except:
            error = "All fields are required"
        self.render("new.html", title=options.title, error=error)

    @gen.coroutine
    def post(self):
        entry = {}
        author = self.get_argument("author", "Anonymous")
        title = self.get_argument("title")
        image = validate_image(self.get_argument("image"))
        html = self.get_argument("post-text")
        text = validate_html(html)
        if not title:
            error = u"?error=" + escape.url_escape("Title must be filled.")
            self.redirect("/new" + error)
        elif not html:
            error = u"?error=" + escape.url_escape("Post cannot be empty.")
            self.redirect("/new" + error)
        elif text is None:
            error = u"?error=" + escape.url_escape("Forbidden or invalid url detected in post body.")
            self.redirect("/new" + error)
        else:
            summary = generate_summary(text)
            slug = slugify.slugify(summary[:30])
            entry["author"] = author
            entry["date"] = datetime.datetime.now().replace(microsecond=0)
            entry["image"] = image
            entry["summary"] = summary
            entry["title"] = title
            entry["text"] = text
            entry["slug"] = slug
            yield self.collection.insert_one(entry)                    
            self.redirect("/post/" + slug)


def generate_summary(text):
    soup = bs4.BeautifulSoup(text, "lxml")
    return soup.get_text()[:200]


def validate_image(image):
    checklist = ["gif", "png", "jpg"]
    if image[-3:].lower() in checklist:
        return image
    else:
        return "http://ic.pics.livejournal.com/masio/8221809/287143/287143_original.gif"


def validate_html(text):
    sites = ['youtube.com', 'play.md', 'vimeo.com']
    soup = bs4.BeautifulSoup(text, "lxml")
    sources = soup.find_all('iframe', {"src": True})
    for source in sources:
        if not any(x in source['src'] for x in sites):
            return None
    tags = ['b', 'p', 'i', 'strong', 'em', 'img', 'iframe']
    attributes = {'img': ['src'], 'iframe': ['src']}
    return bleach.clean(text, tags, attributes)


def get_datetime(date):
    sliced_date = date[5:25]
    return datetime.datetime.strptime(sliced_date, '%d %b %Y %H:%M:%S')


def build_json_from_raw_data(ch_date=datetime.datetime(2000, 1, 1)):
    raw_data = crawl.get_sslowdown_data()
    result = []
    entry = {}
    for entry_key, entry_data in raw_data.items():
        date = get_datetime(entry_data["date"])
        if date > ch_date:
            entry["author"] = entry_data["author"]
            entry["date"] = date
            entry["image"] = entry_data["image"]
            entry["summary"] = entry_data["summary"]
            entry["title"] = entry_data["title"]
            entry["text"] = entry_data["text"]
            entry["slug"] = slugify.slugify(entry_data["summary"][:30])
            result.append(deepcopy(entry))
    return result


@gen.coroutine
def bulk_insert(collection, items):
    yield collection.insert_many(items)


@gen.coroutine
def check_rss_updates(collection):
    cursor = collection.find()
    cursor.sort([('date', -1)]).limit(1)
    document = None
    while (yield cursor.fetch_next):
        document = cursor.next_object()
    if document:
        date = document['date']
        articles = build_json_from_raw_data(ch_date=date)
    else:
        articles = build_json_from_raw_data()
    if len(articles) > 0:
        bulk_insert(collection, articles)


def main():
    # sys.setrecursionlimit(10000)

    parse_command_line()
    db = motor.motor_tornado.MotorClient().news
    collection = db.articles
    app = tornado.web.Application(
        [
            (r"/", MainHandler),
            (r"/post/(.+)", PostHandler),
            (r"/new", PostNewHandler),
        ],
        cookie_secret="__THERE_IS_NO_SECRET_COOKIE__",
        template_path=os.path.join(os.path.dirname(__file__), "templates"),
        static_path=os.path.join(os.path.dirname(__file__), "static"),
        xsrf_cookies=True,
        debug=options.debug,
        db=db,
        collection=collection,
    )
    print('Listening on http://localhost:{}'.format(options.port))
    app.listen(options.port)
    tornado.ioloop.IOLoop.current().start()


if __name__ == '__main__':
    main()

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError                    
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath                    

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or "_login_disclaimer_banner.html"

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "..", "..", "..", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return ["Invalid XML template format for %s." % self._banner_filename]
        except IOError:
            return ["Disclaimer banner file %s could not be read or does not exit." % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo("/", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource                    
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource                    
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)                    

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))                    
        self.putChild('keys', KeysResource(self._services_factory))                    
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))                    
        self.putChild('contacts', ContactsResource(self._services_factory))                    
        self.putChild('features', FeaturesResource(portal))                    
        self.putChild('tags', TagsResource(self._services_factory))                    
        self.putChild('mails', MailsResource(self._services_factory))                    
        self.putChild('mail', MailResource(self._services_factory))                    
        self.putChild('feedback', FeedbackResource(self._services_factory))                    
        self.putChild('user-settings', UserSettingsResource(self._services_factory))                    
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))                    
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))                    

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):                    
        request = request_mock(path)                    
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):                    
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method="POST", body=body, headers=headers)                    
        return self._render(request)

    def put(self, path, body):                    
        request = request_mock(path=path, method="PUT", body=body, headers={'Content-Type': ['application/json']})                    
        return self._render(request)

    def delete(self, path, body=""):                    
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method="DELETE")                    
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get("/mails", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):                    
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get("/attachment/%s" % ident, params, as_json=False)                    
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post("/mail/%s/tags" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete("/mail/%s" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post("/mails/delete", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u"verysecretpassphrase"
    secret_path = os.path.join(tempdir, "secret.gpg")
    local_db_path = os.path.join(tempdir, "soledad.u1db")
    server_url = "http://provider"
    cert_file = ""

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = "123"
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b"location", url)


def request_mock(path='', method='GET', body='', headers={}):                    
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy

import unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource                    


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = "<html><head><title>$account_email</title></head></html>"
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = "<title>{0}</title>".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()                    
    proxy = Proxy(proxy_port='8889', app_port='4567')                    
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()                    

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()                    


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir("screenshots")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + ".png")
        save_source(context, 'failed ' + str(step.name) + '_' + id + ".html")
        os.chdir("../")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')                    
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError                    
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath                    

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or "_login_disclaimer_banner.html"

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "..", "..", "..", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return ["Invalid XML template format for %s." % self._banner_filename]
        except IOError:
            return ["Disclaimer banner file %s could not be read or does not exit." % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo("/", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource                    
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource                    
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)                    

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))                    
        self.putChild('keys', KeysResource(self._services_factory))                    
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))                    
        self.putChild('contacts', ContactsResource(self._services_factory))                    
        self.putChild('features', FeaturesResource(portal))                    
        self.putChild('tags', TagsResource(self._services_factory))                    
        self.putChild('mails', MailsResource(self._services_factory))                    
        self.putChild('mail', MailResource(self._services_factory))                    
        self.putChild('feedback', FeedbackResource(self._services_factory))                    
        self.putChild('user-settings', UserSettingsResource(self._services_factory))                    
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))                    
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))                    

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):                    
        request = request_mock(path)                    
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):                    
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method="POST", body=body, headers=headers)                    
        return self._render(request)

    def put(self, path, body):                    
        request = request_mock(path=path, method="PUT", body=body, headers={'Content-Type': ['application/json']})                    
        return self._render(request)

    def delete(self, path, body=""):                    
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method="DELETE")                    
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get("/mails", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):                    
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get("/attachment/%s" % ident, params, as_json=False)                    
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post("/mail/%s/tags" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete("/mail/%s" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post("/mails/delete", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u"verysecretpassphrase"
    secret_path = os.path.join(tempdir, "secret.gpg")
    local_db_path = os.path.join(tempdir, "soledad.u1db")
    server_url = "http://provider"
    cert_file = ""

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = "123"
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b"location", url)


def request_mock(path='', method='GET', body='', headers={}):                    
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy

import unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource                    


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = "<html><head><title>$account_email</title></head></html>"
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = "<title>{0}</title>".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()                    
    proxy = Proxy(proxy_port='8889', app_port='4567')                    
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()                    

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()                    


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir("screenshots")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + ".png")
        save_source(context, 'failed ' + str(step.name) + '_' + id + ".html")
        os.chdir("../")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))

#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')                    
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "..", "..", "..", "web-ui", "app"))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "..", "..", "..", "..", "web-ui", "app"))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)

# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Cornice (Sagrada)
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Tarek Ziade (tarek@mozilla.com)
#   Alexis Metaireau (alexis@mozilla.com)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
import unittest
import simplejson as json

from webtest import TestApp
from cornice.tests.validationapp import main, _json
from cornice.schemas import Errors


class TestServiceDefinition(unittest.TestCase):                    

    def test_validation(self):
        app = TestApp(main({}))
        app.get('/service', status=400)

        res = app.post('/service', params='buh', status=400)
        self.assertTrue('Not a json body' in res.body)

        res = app.post('/service', params=json.dumps('buh'))

        self.assertEqual(res.body, json.dumps({'body': '"buh"'}))

        app.get('/service?paid=yup')

        # valid = foo is one
        res = app.get('/service?foo=1&paid=yup')
        self.assertEqual(res.json['foo'], 1)

        # invalid value for foo
        res = app.get('/service?foo=buh&paid=yup', status=400)

        # check that json is returned
        errors = Errors.from_json(res.body)
        self.assertEqual(len(errors), 1)

        # the "apidocs" registry entry contains all the needed information
        # to build up documentation
        # in this case, this means the function is registered and the argument
        # of the service are defined (e.g "validator" is set)
        apidocs = app.app.registry.settings['apidocs']

        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])

    def test_accept(self):
        # tests that the accept headers are handled the proper way
        app = TestApp(main({}))

        # requesting the wrong accept header should return a 406 ...
        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)

        # ... with the list of accepted content-types
        self.assertTrue('application/json' in res.json)
        self.assertTrue('text/json' in res.json)

        app.get('/service2', headers={'Accept': 'application/*'}, status=200)

        # it should also work with multiple Accept headers
        app.get('/service2', headers={'Accept': 'audio/*, application/*'},
                status=200)

        # test that using a callable to define what's accepted works as well
        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)
        self.assertTrue('text/json' in res.json)

        app.get('/service3', headers={'Accept': 'text/*'}, status=200)

        # if we are not asking for a particular content-type, everything
        # should work just fine
        app.get('/service2', status=200)

    def test_filters(self):
        app = TestApp(main({}))

        # filters can be applied to all the methods of a service
        self.assertTrue("filtered response" in app.get('/filtered').body)
        self.assertTrue("unfiltered" in app.post('/filtered').body)

import json                    
import logging

log = logging.getLogger(__name__)                    


def filter_json_xsrf(response):
    """drops a warning if a service is returning a json array.

    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info
    on this
    """
    if response.content_type in ('application/json', 'text/json'):
        try:                    
            content = json.loads(response.body)                    
            if isinstance(content, (list, tuple)):                    
                log.warn("returning a json array is a potential security whole, "                    
                         "please ensure you really want to do this. See "
                         "http://wiki.pylonshq.com/display/pylonsfaq/Warnings "
                         "for more info")
        except:                    
            pass                    
    return response


DEFAULT_VALIDATORS = []
DEFAULT_FILTERS = [filter_json_xsrf, ]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""
    
    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):                    
        """Check non-empty body on POST for XSRF                    

        instead of checking the cookie for forms.                    
        """
        if self.request.method.upper() == 'POST' and not self.request.body:                    
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, "POST requests must have a JSON body. If no content is needed, use '{}'.")                    

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf checks when token-authenticated"""
        if self.token_authenticated:                    
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def set_attachment_header(self, filename):
        """Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            " filename*=utf-8''{utf8}"
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf cookie checks when token-authenticated"""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """APIHandler errors are JSON, not human pages"""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """Raise 403 on API handlers instead of redirecting to human login page"""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """Update last_activity of API requests"""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')                    
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument("download", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""
    
    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):                    
        """Check non-empty body on POST for XSRF                    

        instead of checking the cookie for forms.                    
        """
        if self.request.method.upper() == 'POST' and not self.request.body:                    
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, "POST requests must have a JSON body. If no content is needed, use '{}'.")                    

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf checks when token-authenticated"""
        if self.token_authenticated:                    
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def set_attachment_header(self, filename):
        """Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            " filename*=utf-8''{utf8}"
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf cookie checks when token-authenticated"""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """APIHandler errors are JSON, not human pages"""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """Raise 403 on API handlers instead of redirecting to human login page"""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """Update last_activity of API requests"""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')                    
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument("download", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""
    
    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):                    
        """Check non-empty body on POST for XSRF                    

        instead of checking the cookie for forms.                    
        """
        if self.request.method.upper() == 'POST' and not self.request.body:                    
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, "POST requests must have a JSON body. If no content is needed, use '{}'.")                    

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf checks when token-authenticated"""
        if self.token_authenticated:                    
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""
    
    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):                    
        """Check non-empty body on POST for XSRF                    

        instead of checking the cookie for forms.                    
        """
        if self.request.method.upper() == 'POST' and not self.request.body:                    
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, "POST requests must have a JSON body. If no content is needed, use '{}'.")                    

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf checks when token-authenticated"""
        if self.token_authenticated:                    
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def set_attachment_header(self, filename):
        """Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            " filename*=utf-8''{utf8}"
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf cookie checks when token-authenticated"""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """APIHandler errors are JSON, not human pages"""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """Raise 403 on API handlers instead of redirecting to human login page"""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """Update last_activity of API requests"""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')                    
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument("download", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]

# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """Secret."""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """Wraps text in minimal HTML tags."""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """Returns all the IP addressed comprised in a range."""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']                    
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),                    
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """Returns True if the provided token is valid."""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """Adds ACL to the request handler to ensure only valid users can use
  the handlers."""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message."""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """Verifies if the IP is whitelisted."""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """Verifies if the user is whitelisted."""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """Ensures the token is valid."""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name="whitelist" method="post">'
      'Domain: <input type="text" name="domain" /><br />'
      '<input type="hidden" name="token" value="%s" />'
      '<input type="submit" value="SUBMIT" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """Returns the token."""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """Adds example.com as a valid domain when testing."""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')



# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Integration with webapp2."""

# Disable 'Method could be a function.'
# pylint: disable=R0201

import functools
import json
import logging
import urllib
import webapp2

from google.appengine.api import urlfetch
from google.appengine.api import users

from components import utils

from . import api
from . import config
from . import delegation
from . import host_token
from . import ipaddr
from . import model
from . import openid
from . import tokens

# Part of public API of 'auth' component, exposed by this module.
__all__ = [
  'ApiHandler',
  'AuthenticatingHandler',
  'gae_cookie_authentication',
  'get_authenticated_routes',
  'oauth_authentication',
  'openid_cookie_authentication',
  'require_xsrf_token_request',
  'service_to_service_authentication',
]


def require_xsrf_token_request(f):
  """Use for handshaking APIs."""
  @functools.wraps(f)
  def hook(self, *args, **kwargs):
    if not self.request.headers.get('X-XSRF-Token-Request'):
      raise api.AuthorizationError('Missing required XSRF request header')
    return f(self, *args, **kwargs)
  return hook


class XSRFToken(tokens.TokenKind):
  """XSRF token parameters."""
  expiration_sec = 4 * 3600
  secret_key = api.SecretKey('xsrf_token', scope='local')
  version = 1


class AuthenticatingHandlerMetaclass(type):
  """Ensures that 'get', 'post', etc. are marked with @require or @public."""

  def __new__(mcs, name, bases, attributes):
    for method in webapp2.WSGIApplication.allowed_methods:
      func = attributes.get(method.lower())
      if func and not api.is_decorated(func):
        raise TypeError(
            'Method \'%s\' of \'%s\' is not protected by @require or @public '
            'decorator' % (method.lower(), name))
    return type.__new__(mcs, name, bases, attributes)


class AuthenticatingHandler(webapp2.RequestHandler):
  """Base class for webapp2 request handlers that use Auth system.

  Knows how to extract Identity from request data and how to initialize auth
  request context, so that get_current_identity() and is_group_member() work.

  All request handling methods (like 'get', 'post', etc) should be marked by
  either @require or @public decorators.
  """

  # Checks that all 'get', 'post', etc. are marked with @require or @public.
  __metaclass__ = AuthenticatingHandlerMetaclass

  # List of HTTP methods that trigger XSRF token validation.
  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')
  # If not None, the header to search for XSRF token.
  xsrf_token_header = 'X-XSRF-Token'
  # If not None, the request parameter (GET or POST) to search for XSRF token.
  xsrf_token_request_param = 'xsrf_token'
  # Embedded data extracted from XSRF token of current request.
  xsrf_token_data = None
  # If not None, sets X_Frame-Options on all replies.
  frame_options = 'DENY'
  # A method used to authenticate this request, see get_auth_methods().
  auth_method = None

  def dispatch(self):
    """Extracts and verifies Identity, sets up request auth context."""
    # Ensure auth component is configured before executing any code.
    conf = config.ensure_configured()
    auth_context = api.reinitialize_request_cache()

    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/
    # https://www.owasp.org/index.php/Content_Security_Policy
    # TODO(maruel): Remove 'unsafe-inline' once all inline style="foo:bar" in
    # all HTML tags were removed. Warning if seeing this post 2016, it could
    # take a while.
    # - https://www.google.com is due to Google Viz library.
    # - https://www.google-analytics.com due to Analytics.
    # - 'unsafe-eval' due to polymer.
    self.response.headers['Content-Security-Policy'] = (
        'default-src https: \'self\' \'unsafe-inline\' https://www.google.com '
        'https://www.google-analytics.com \'unsafe-eval\'')
    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.
    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security
    self.response.headers['Strict-Transport-Security'] = (
        'max-age=31536000; includeSubDomains; preload')
    # Disable frame support wholesale.
    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet
    if self.frame_options:
      self.response.headers['X-Frame-Options'] = self.frame_options

    identity = None
    for method_func in self.get_auth_methods(conf):
      try:
        identity = method_func(self.request)
        if identity:
          break
      except api.AuthenticationError as err:
        self.authentication_error(err)
        return
      except api.AuthorizationError as err:
        self.authorization_error(err)
        return
    else:
      method_func = None
    self.auth_method = method_func

    # If no authentication method is applicable, default to anonymous identity.
    identity = identity or model.Anonymous

    # XSRF token is required only if using Cookie based or IP whitelist auth.
    # A browser doesn't send Authorization: 'Bearer ...' or any other headers
    # by itself. So XSRF check is not required if header based authentication
    # is used.
    using_headers_auth = method_func in (
        oauth_authentication, service_to_service_authentication)

    # Extract caller host name from host token header, if present and valid.
    host_tok = self.request.headers.get(host_token.HTTP_HEADER)
    if host_tok:
      validated_host = host_token.validate_host_token(host_tok)
      if validated_host:
        auth_context.peer_host = validated_host

    # Verify IP is whitelisted and authenticate requests from bots.
    assert self.request.remote_addr
    ip = ipaddr.ip_from_string(self.request.remote_addr)
    auth_context.peer_ip = ip
    try:
      # 'verify_ip_whitelisted' may change identity for bots, store new one.
      auth_context.peer_identity = api.verify_ip_whitelisted(
          identity, ip, self.request.headers)
    except api.AuthorizationError as err:
      self.authorization_error(err)
      return

    # Parse delegation token, if given, to deduce end-user identity.
    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)
    if delegation_tok:
      try:
        auth_context.current_identity = delegation.check_delegation_token(
            delegation_tok, auth_context.peer_identity)
      except delegation.BadTokenError as exc:
        self.authorization_error(
            api.AuthorizationError('Bad delegation token: %s' % exc))
      except delegation.TransientError as exc:
        msg = 'Transient error while validating delegation token.\n%s' % exc
        logging.error(msg)
        self.abort(500, detail=msg)
    else:
      auth_context.current_identity = auth_context.peer_identity

    try:
      # Fail if XSRF token is required, but not provided.
      need_xsrf_token = (
          not using_headers_auth and
          self.request.method in self.xsrf_token_enforce_on)
      if need_xsrf_token and self.xsrf_token is None:
        raise api.AuthorizationError('XSRF token is missing')

      # If XSRF token is present, verify it is valid and extract its payload.
      # Do it even if XSRF token is not strictly required, since some handlers
      # use it to store session state (it is similar to a signed cookie).
      self.xsrf_token_data = {}
      if self.xsrf_token is not None:
        # This raises AuthorizationError if token is invalid.
        self.xsrf_token_data = self.verify_xsrf_token()                    

      # All other ACL checks will be performed by corresponding handlers
      # manually or via '@required' decorator. Failed ACL check raises
      # AuthorizationError.
      super(AuthenticatingHandler, self).dispatch()
    except api.AuthorizationError as err:
      self.authorization_error(err)

  @classmethod
  def get_auth_methods(cls, conf):
    """Returns an enumerable of functions to use to authenticate request.

    The handler will try to apply auth methods sequentially one by one by until
    it finds one that works.

    Each auth method is a function that accepts webapp2.Request and can finish
    with 3 outcomes:

    * Return None: authentication method is not applicable to that request
      and next method should be tried (for example cookie-based
      authentication is not applicable when there's no cookies).

    * Returns Identity associated with the request. Means authentication method
      is applicable and request authenticity is confirmed.

    * Raises AuthenticationError: authentication method is applicable, but
      request contains bad credentials or invalid token, etc. For example,
      OAuth2 token is given, but it is revoked.

    A chosen auth method function will be stored in request's auth_method field.

    Args:
      conf: components.auth GAE config, see config.py.
    """
    if conf.USE_OPENID:
      cookie_auth = openid_cookie_authentication
    else:
      cookie_auth = gae_cookie_authentication
    return oauth_authentication, cookie_auth, service_to_service_authentication

  def generate_xsrf_token(self, xsrf_token_data=None):
    """Returns new XSRF token that embeds |xsrf_token_data|.

    The token is bound to current identity and is valid only when used by same
    identity.
    """
    return XSRFToken.generate(
        [api.get_current_identity().to_bytes()], xsrf_token_data)

  @property
  def xsrf_token(self):
    """Returns XSRF token passed with the request or None if missing.

    Doesn't do any validation. Use verify_xsrf_token() instead.
    """
    token = None
    if self.xsrf_token_header:
      token = self.request.headers.get(self.xsrf_token_header)
    if not token and self.xsrf_token_request_param:
      param = self.request.get_all(self.xsrf_token_request_param)
      token = param[0] if param else None
    return token

  def verify_xsrf_token(self):
    """Grabs a token from the request, validates it and extracts embedded data.

    Current identity must be the same as one used to generate the token.

    Returns:
      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'
      method call used to generate the token.

    Raises:
      AuthorizationError if token is missing, invalid or expired.
    """
    token = self.xsrf_token
    if not token:
      raise api.AuthorizationError('XSRF token is missing')
    # Check that it was generated for the same identity.
    try:
      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])
    except tokens.InvalidTokenError as err:
      raise api.AuthorizationError(str(err))

  def authentication_error(self, error):
    """Called when authentication fails to report the error to requester.

    Authentication error means that some credentials are provided but they are
    invalid. If no credentials are provided at all, no authentication is
    attempted and current identity is just set to 'anonymous:anonymous'.

    Default behavior is to abort the request with HTTP 401 error (and human
    readable HTML body).

    Args:
      error: instance of AuthenticationError subclass.
    """
    logging.warning('Authentication error.\n%s', error)
    self.abort(401, detail=str(error))

  def authorization_error(self, error):
    """Called when authentication succeeds, but access to a resource is denied.

    Called whenever request handler raises AuthorizationError exception.
    In particular this exception is raised by method decorated with @require if
    current identity doesn't have required permission.

    Default behavior is to abort the request with HTTP 403 error (and human
    readable HTML body).

    Args:
      error: instance of AuthorizationError subclass.
    """
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort(403, detail=str(error))

  ### Wrappers around Users API or its OpenID equivalent.

  def get_current_user(self):
    """When cookie auth is used returns instance of CurrentUser or None."""
    return self._get_users_api().get_current_user(self.request)

  def is_current_user_gae_admin(self):
    """When cookie auth is used returns True if current caller is GAE admin."""
    return self._get_users_api().is_current_user_gae_admin(self.request)

  def create_login_url(self, dest_url):
    """When cookie auth is used returns URL to redirect user to login."""
    return self._get_users_api().create_login_url(self.request, dest_url)

  def create_logout_url(self, dest_url):
    """When cookie auth is used returns URL to redirect user to logout."""
    return self._get_users_api().create_logout_url(self.request, dest_url)

  def _get_users_api(self):
    """Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.

    Chooses based on what auth_method was used of what methods are available.
    """
    method = self.auth_method
    if not method:
      # Anonymous request -> pick first method that supports API.
      for method in self.get_auth_methods(config.ensure_configured()):
        if method in _METHOD_TO_USERS_API:
          break
      else:
        raise NotImplementedError('No methods support UsersAPI')
    elif method not in _METHOD_TO_USERS_API:
      raise NotImplementedError(
          '%s doesn\'t support UsersAPI' % method.__name__)
    return _METHOD_TO_USERS_API[method]


class ApiHandler(AuthenticatingHandler):
  """Parses JSON request body to a dict, serializes response to JSON."""
  CONTENT_TYPE_BASE = 'application/json'
  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'
  _json_body = None
  # Clickjacking not applicable to APIs.
  frame_options = None

  def authentication_error(self, error):
    logging.warning('Authentication error.\n%s', error)
    self.abort_with_error(401, text=str(error))

  def authorization_error(self, error):
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort_with_error(403, text=str(error))

  def send_response(self, response, http_code=200, headers=None):
    """Sends successful reply and continues execution."""
    self.response.set_status(http_code)
    self.response.headers.update(headers or {})
    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL
    self.response.write(json.dumps(response))

  def abort_with_error(self, http_code, **kwargs):
    """Sends error reply and stops execution."""
    self.abort(
        http_code,
        json=kwargs,
        headers={'Content-Type': self.CONTENT_TYPE_FULL})

  def parse_body(self):
    """Parses JSON body and verifies it's a dict.

    webob.Request doesn't cache the decoded json body, this function does.
    """
    if self._json_body is None:
      if (self.CONTENT_TYPE_BASE and
          self.request.content_type != self.CONTENT_TYPE_BASE):
        msg = (
            'Expecting JSON body with content type \'%s\'' %
            self.CONTENT_TYPE_BASE)
        self.abort_with_error(400, text=msg)
      try:
        self._json_body = self.request.json
        if not isinstance(self._json_body, dict):
          raise ValueError()
      except (LookupError, ValueError):
        self.abort_with_error(400, text='Not a valid json dict body')
    return self._json_body.copy()


def get_authenticated_routes(app):
  """Given WSGIApplication returns list of routes that use authentication.

  Intended to be used only for testing.
  """
  # This code is adapted from router's __repr__ method (that enumerate
  # all routes for pretty-printing).
  routes = list(app.router.match_routes)
  routes.extend(
      v for k, v in app.router.build_routes.iteritems()
      if v not in app.router.match_routes)
  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]


################################################################################
## All supported implementations of authentication methods for webapp2 handlers.


def gae_cookie_authentication(_request):
  """AppEngine cookie based authentication via users.get_current_user()."""
  user = users.get_current_user()
  try:
    return model.Identity(model.IDENTITY_USER, user.email()) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email())


def openid_cookie_authentication(request):
  """Cookie based authentication that uses OpenID flow for login."""
  user = openid.get_current_user(request)
  try:
    return model.Identity(model.IDENTITY_USER, user.email) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email)


def oauth_authentication(request):
  """OAuth2 based authentication via oauth.get_current_user()."""
  if not request.headers.get('Authorization'):
    return None
  if not utils.is_local_dev_server():
    return api.extract_oauth_caller_identity()

  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,
  # but real) OAuth2 API endpoint instead to validate access_token. It is also
  # what Cloud Endpoints do on a local server. For simplicity ignore client_id
  # on dev server.
  header = request.headers['Authorization'].split(' ', 1)
  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):
    raise api.AuthenticationError('Invalid authorization header')

  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.
  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'
  result = urlfetch.fetch(
      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),
      follow_redirects=False,
      validate_certificate=True)
  if result.status_code != 200:
    try:
      error = json.loads(result.content)['error_description']
    except (KeyError, ValueError):
      error = repr(result.content)
    raise api.AuthenticationError('Failed to validate the token: %s' % error)

  token_info = json.loads(result.content)
  if 'email' not in token_info:
    raise api.AuthenticationError('Token doesn\'t include an email address')
  if not token_info.get('verified_email'):
    raise api.AuthenticationError('Token email isn\'t verified')

  email = token_info['email']
  try:
    return model.Identity(model.IDENTITY_USER, email)
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % email)


def service_to_service_authentication(request):
  """Used for AppEngine <-> AppEngine communication.

  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't
  be set by external users (with exception of admins).
  """
  app_id = request.headers.get('X-Appengine-Inbound-Appid')
  try:
    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None
  except ValueError:
    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)


################################################################################
## API wrapper on top of Users API and OpenID API to make them similar.


class CurrentUser(object):
  """Mimics subset of GAE users.User object for ease of transition.

  Also adds .picture().
  """

  def __init__(self, user_id, email, picture):
    self._user_id = user_id
    self._email = email
    self._picture = picture

  def nickname(self):
    return self._email

  def email(self):
    return self._email

  def user_id(self):
    return self._user_id

  def picture(self):
    return self._picture

  def __unicode__(self):
    return unicode(self.nickname())

  def __str__(self):
    return str(self.nickname())


class GAEUsersAPI(object):
  @staticmethod
  def get_current_user(request):  # pylint: disable=unused-argument
    user = users.get_current_user()
    return CurrentUser(user.user_id(), user.email(), None) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return users.is_current_user_admin()

  @staticmethod
  def create_login_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_login_url(dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_logout_url(dest_url)


class OpenIDAPI(object):
  @staticmethod
  def get_current_user(request):
    user = openid.get_current_user(request)
    return CurrentUser(user.sub, user.email, user.picture) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return False

  @staticmethod
  def create_login_url(request, dest_url):
    return openid.create_login_url(request, dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):
    return openid.create_logout_url(request, dest_url)


# See AuthenticatingHandler._get_users_api().
_METHOD_TO_USERS_API = {
  gae_cookie_authentication: GAEUsersAPI,
  openid_cookie_authentication: OpenIDAPI,
}

#!/usr/bin/env python
# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.
# pylint: disable=W0612,W0613,R0201

import datetime
import json
import os
import sys
import unittest

from test_support import test_env
test_env.setup_test_env()

from google.appengine.api import oauth
from google.appengine.api import users

import webapp2
import webtest

from components import utils
from components.auth import api
from components.auth import delegation
from components.auth import handler
from components.auth import host_token
from components.auth import ipaddr
from components.auth import model
from components.auth.proto import delegation_pb2
from test_support import test_case


class AuthenticatingHandlerMetaclassTest(test_case.TestCase):
  """Tests for AuthenticatingHandlerMetaclass."""

  def test_good(self):
    # No request handling methods defined at all.
    class TestHandler1(handler.AuthenticatingHandler):
      def some_other_method(self):
        pass

    # @public is used.
    class TestHandler2(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        pass

    # @require is used.
    class TestHandler3(handler.AuthenticatingHandler):
      @api.require(lambda: True)
      def get(self):
        pass

  def test_bad(self):
    # @public or @require is missing.
    with self.assertRaises(TypeError):
      class TestHandler1(handler.AuthenticatingHandler):
        def get(self):
          pass


class AuthenticatingHandlerTest(test_case.TestCase):
  """Tests for AuthenticatingHandler class."""

  def setUp(self):
    super(AuthenticatingHandlerTest, self).setUp()
    # Reset global config of auth library before each test.
    api.reset_local_state()
    # Capture error and warning log messages.
    self.logged_errors = []
    self.mock(handler.logging, 'error',
        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))
    self.logged_warnings = []
    self.mock(handler.logging, 'warning',
        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))

  def make_test_app(self, path, request_handler):
    """Returns webtest.TestApp with single route."""
    return webtest.TestApp(
        webapp2.WSGIApplication([(path, request_handler)], debug=True),
        extra_environ={'REMOTE_ADDR': '127.0.0.1'})

  def test_anonymous(self):
    """If all auth methods are not applicable, identity is set to Anonymous."""
    test = self

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        non_applicable = lambda _request: None
        return [non_applicable, non_applicable]

      @api.public
      def get(self):
        test.assertEqual(model.Anonymous, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)                    

  def test_ip_whitelist_bot(self):
    """Requests from client in "bots" IP whitelist are authenticated as bot."""
    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_current_identity().to_bytes())

    app = self.make_test_app('/request', Handler)
    def call(ip):
      api.reset_local_state()
      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body

    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))                    
    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))                    

  def test_ip_whitelist(self):
    """Per-account IP whitelist works."""
    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')
    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')

    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])
    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')

    mocked_ident = [None]

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _req: mocked_ident[0]]

      @api.public
      def get(self):
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    def call(ident, ip):
      api.reset_local_state()
      mocked_ident[0] = ident
      response = app.get(
          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)
      return response.status_int

    # IP is whitelisted.
    self.assertEqual(200, call(ident1, '192.168.1.100'))                    
    # IP is NOT whitelisted.
    self.assertEqual(403, call(ident1, '127.0.0.1'))                    
    # Whitelist is not used.
    self.assertEqual(200, call(ident2, '127.0.0.1'))                    

  def test_auth_method_order(self):
    """Registered auth methods are tested in order."""
    test = self
    calls = []
    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')

    def not_applicable(request):
      self.assertEqual('/request', request.path)                    
      calls.append('not_applicable')
      return None

    def applicable(request):
      self.assertEqual('/request', request.path)                    
      calls.append('applicable')
      return ident

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [not_applicable, applicable]

      @api.public
      def get(self):
        test.assertEqual(ident, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)                    

    # Both methods should be tried.
    expected_calls = [
      'not_applicable',
      'applicable',
    ]
    self.assertEqual(expected_calls, calls)                    

  def test_authentication_error(self):
    """AuthenticationError in auth method stops request processing."""
    test = self
    calls = []

    def failing(request):
      raise api.AuthenticationError('Too bad')

    def skipped(request):
      self.fail('authenticate should not be called')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [failing, skipped]

      @api.public
      def get(self):
        test.fail('Handler code should not be called')

      def authentication_error(self, err):
        test.assertEqual('Too bad', err.message)
        calls.append('authentication_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authentication_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 401.
    self.assertEqual(['authentication_error'], calls)                    
    self.assertEqual(401, response.status_int)                    

    # Authentication error is logged.
    self.assertEqual(1, len(self.logged_warnings))                    

  def test_authorization_error(self):
    """AuthorizationError in auth method is handled."""
    test = self
    calls = []

    class Handler(handler.AuthenticatingHandler):
      @api.require(lambda: False)
      def get(self):
        test.fail('Handler code should not be called')

      def authorization_error(self, err):
        calls.append('authorization_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authorization_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 403.
    self.assertEqual(['authorization_error'], calls)                    
    self.assertEqual(403, response.status_int)                    

  def make_xsrf_handling_app(
      self,
      xsrf_token_enforce_on=None,
      xsrf_token_header=None,
      xsrf_token_request_param=None):
    """Returns webtest app with single XSRF-aware handler.

    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.
    """
    calls = []

    def record(request_handler, method):
      is_valid = request_handler.xsrf_token_data == {'some': 'data'}
      calls.append((method, is_valid))

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(self.generate_xsrf_token({'some': 'data'}))
      @api.public
      def post(self):
        record(self, 'POST')
      @api.public
      def put(self):
        record(self, 'PUT')
      @api.public
      def delete(self):
        record(self, 'DELETE')

    if xsrf_token_enforce_on is not None:
      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on
    if xsrf_token_header is not None:
      Handler.xsrf_token_header = xsrf_token_header
    if xsrf_token_request_param is not None:
      Handler.xsrf_token_request_param = xsrf_token_request_param

    app = self.make_test_app('/request', Handler)
    return app, calls

  def mock_get_current_identity(self, ident):
    """Mocks api.get_current_identity() to return |ident|."""
    self.mock(handler.api, 'get_current_identity', lambda: ident)

  def test_xsrf_token_get_param(self):
    """XSRF token works if put in GET parameters."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request?xsrf_token=%s' % token)
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_post_param(self):
    """XSRF token works if put in POST parameters."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_header(self):
    """XSRF token works if put in the headers."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', headers={'X-XSRF-Token': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_missing(self):
    """XSRF token is not given but handler requires it."""
    app, calls = self.make_xsrf_handling_app()
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)                    
    self.assertFalse(calls)

  def test_xsrf_token_uses_enforce_on(self):
    """Only methods set in |xsrf_token_enforce_on| require token validation."""
    # Validate tokens only on PUT (not on POST).
    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))
    token = app.get('/request').body
    # Both POST and PUT work when token provided, verifying it.
    app.post('/request', {'xsrf_token': token})
    app.put('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True), ('PUT', True)], calls)                    
    # POST works without a token, put PUT doesn't.
    self.assertEqual(200, app.post('/request').status_int)                    
    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)                    
    # Both fail if wrong token is provided.
    bad_token = {'xsrf_token': 'boo'}
    self.assertEqual(                    
        403, app.post('/request', bad_token, expect_errors=True).status_int)                    
    self.assertEqual(                    
        403, app.put('/request', bad_token, expect_errors=True).status_int)

  def test_xsrf_token_uses_xsrf_token_header(self):
    """Name of the header used for XSRF can be changed."""
    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')
    token = app.get('/request').body
    app.post('/request', headers={'X-Some': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_uses_xsrf_token_request_param(self):
    """Name of the request param used for XSRF can be changed."""
    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')
    token = app.get('/request').body
    app.post('/request', {'tok': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_identity_matters(self):
    app, calls = self.make_xsrf_handling_app()
    # Generate token for identity A.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'a@example.com'))
    token = app.get('/request').body
    # Try to use it by identity B.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'b@example.com'))
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)                    
    self.assertFalse(calls)

  def test_get_authenticated_routes(self):
    class Authenticated(handler.AuthenticatingHandler):
      pass

    class NotAuthenticated(webapp2.RequestHandler):
      pass

    app = webapp2.WSGIApplication([
      webapp2.Route('/authenticated', Authenticated),
      webapp2.Route('/not-authenticated', NotAuthenticated),
    ])
    routes = handler.get_authenticated_routes(app)
    self.assertEqual(1, len(routes))                    
    self.assertEqual(Authenticated, routes[0].handler)                    

  def test_get_peer_ip(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})
    self.assertEqual('192.1.2.3', response.body)                    

  def test_get_peer_host(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_peer_host() or '<none>')

    app = self.make_test_app('/request', Handler)
    def call(headers):
      api.reset_local_state()
      return app.get('/request', headers=headers).body

    # Good token.
    token = host_token.create_host_token('HOST.domain.com')
    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))                    

    # Missing or invalid tokens.
    self.assertEqual('<none>', call({}))                    
    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))                    

    # Expired token.
    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)
    self.mock_now(origin)
    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)
    self.mock_now(origin, 61)
    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))                    

  def test_delegation_token(self):
    peer_ident = model.Identity.from_bytes('user:peer@a.com')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _request: peer_ident]

      @api.public
      def get(self):
        self.response.write(json.dumps({
          'peer_id': api.get_peer_identity().to_bytes(),
          'cur_id': api.get_current_identity().to_bytes(),
        }))

    app = self.make_test_app('/request', Handler)
    def call(headers=None):
      return json.loads(app.get('/request', headers=headers).body)

    # No delegation.
    self.assertEqual(                    
        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())

    # TODO(vadimsh): Mint token via some high-level function call.
    subtokens = delegation_pb2.SubtokenList(subtokens=[
        delegation_pb2.Subtoken(
            issuer_id='user:delegated@a.com',
            creation_time=int(utils.time_time()),
            validity_duration=3600),
    ])
    tok = delegation.serialize_token(delegation.seal_token(subtokens))

    # With valid delegation token.
    self.assertEqual(                    
        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},
        call({'X-Delegation-Token-V1': tok}))

    # With invalid delegation token.
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok + 'blah'},
        expect_errors=True)
    self.assertEqual(403, r.status_int)                    

    # Transient error.
    def mocked_check(*_args):
      raise delegation.TransientError('Blah')
    self.mock(delegation, 'check_delegation_token', mocked_check)
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok},
        expect_errors=True)
    self.assertEqual(500, r.status_int)                    


class GaeCookieAuthenticationTest(test_case.TestCase):
  """Tests for gae_cookie_authentication function."""

  def test_non_applicable(self):
    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))

  def test_applicable(self):
    os.environ.update({
      'USER_EMAIL': 'joe@example.com',
      'USER_ID': '123',
      'USER_IS_ADMIN': '0',
    })
    # Actual request is not used by CookieAuthentication.
    self.assertEqual(                    
        model.Identity(model.IDENTITY_USER, 'joe@example.com'),
        handler.gae_cookie_authentication(webapp2.Request({})))


class ServiceToServiceAuthenticationTest(test_case.TestCase):
  """Tests for service_to_service_authentication."""

  def test_non_applicable(self):
    request = webapp2.Request({})
    self.assertIsNone(
        handler.service_to_service_authentication(request))

  def test_applicable(self):
    request = webapp2.Request({
      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',
    })
    self.assertEqual(                    
      model.Identity(model.IDENTITY_SERVICE, 'some-app'),
      handler.service_to_service_authentication(request))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()

# Copyright 2015 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Internal bot API handlers."""

import base64
import json
import logging
import textwrap

import webob
import webapp2

from google.appengine.api import app_identity
from google.appengine.api import datastore_errors
from google.appengine.datastore import datastore_query
from google.appengine import runtime
from google.appengine.ext import ndb

from components import auth
from components import ereporter2
from components import utils
from server import acl
from server import bot_code
from server import bot_management
from server import stats
from server import task_pack
from server import task_request
from server import task_result
from server import task_scheduler
from server import task_to_run


def has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):
  """Returns an error if unexpected keys are present or expected keys are
  missing.

  Accepts optional keys.

  This is important to catch typos.
  """
  actual_keys = frozenset(actual_keys)
  superfluous = actual_keys - expected_keys
  missing = minimum_keys - actual_keys
  if superfluous or missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    msg_superfluous = (
        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')
    return 'Unexpected %s%s%s; did you make a typo?' % (
        name, msg_missing, msg_superfluous)


def has_unexpected_keys(expected_keys, actual_keys, name):
  """Return an error if unexpected keys are present or expected keys are
  missing.
  """
  return has_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, name)


def log_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, request, source, name):
  """Logs an error if unexpected keys are present or expected keys are missing.

  Accepts optional keys.

  This is important to catch typos.
  """
  message = has_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, name)
  if message:
    ereporter2.log_request(request, source=source, message=message)
  return message


def log_unexpected_keys(expected_keys, actual_keys, request, source, name):
  """Logs an error if unexpected keys are present or expected keys are missing.
  """
  return log_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, request, source, name)


def has_missing_keys(minimum_keys, actual_keys, name):
  """Returns an error if expected keys are not present.

  Do not warn about unexpected keys.
  """
  actual_keys = frozenset(actual_keys)
  missing = minimum_keys - actual_keys
  if missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)


class BootstrapHandler(auth.AuthenticatingHandler):
  """Returns python code to run to bootstrap a swarming bot."""

  @auth.require(acl.is_bot)
  def get(self):
    self.response.headers['Content-Type'] = 'text/x-python'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename="swarming_bot_bootstrap.py"')
    self.response.out.write(
        bot_code.get_bootstrap(self.request.host_url).content)


class BotCodeHandler(auth.AuthenticatingHandler):
  """Returns a zip file with all the files required by a bot.

  Optionally specify the hash version to download. If so, the returned data is
  cacheable.
  """

  @auth.require(acl.is_bot)
  def get(self, version=None):
    if version:
      expected = bot_code.get_bot_version(self.request.host_url)
      if version != expected:
        # This can happen when the server is rapidly updated.
        logging.error('Requested Swarming bot %s, have %s', version, expected)
        self.abort(404)
      self.response.headers['Cache-Control'] = 'public, max-age=3600'
    else:
      self.response.headers['Cache-Control'] = 'no-cache, no-store'
    self.response.headers['Content-Type'] = 'application/octet-stream'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename="swarming_bot.zip"')
    self.response.out.write(
        bot_code.get_swarming_bot_zip(self.request.host_url))


class _BotBaseHandler(auth.ApiHandler):
  """
  Request body is a JSON dict:
    {
      "dimensions": <dict of properties>,
      "state": <dict of properties>,
      "version": <sha-1 of swarming_bot.zip uncompressed content>,
    }
  """

  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}
  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  def _process(self):
    """Returns True if the bot has invalid parameter and should be automatically
    quarantined.

    Does one DB synchronous GET.

    Returns:
      tuple(request, bot_id, version, state, dimensions, quarantined_msg)
    """
    request = self.parse_body()
    version = request.get('version', None)

    dimensions = request.get('dimensions', {})
    state = request.get('state', {})
    bot_id = None
    if dimensions.get('id'):
      dimension_id = dimensions['id']
      if (isinstance(dimension_id, list) and len(dimension_id) == 1
          and isinstance(dimension_id[0], unicode)):
        bot_id = dimensions['id'][0]

    # The bot may decide to "self-quarantine" itself. Accept both via
    # dimensions or via state. See bot_management._BotCommon.quarantined for
    # more details.
    if (bool(dimensions.get('quarantined')) or
        bool(state.get('quarantined'))):
      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'

    quarantined_msg = None
    # Use a dummy 'for' to be able to break early from the block.
    for _ in [0]:

      quarantined_msg = has_unexpected_keys(
          self.EXPECTED_KEYS, request, 'keys')
      if quarantined_msg:
        break

      quarantined_msg = has_missing_keys(
          self.REQUIRED_STATE_KEYS, state, 'state')
      if quarantined_msg:
        break

      if not bot_id:
        quarantined_msg = 'Missing bot id'
        break

      if not all(
          isinstance(key, unicode) and
          isinstance(values, list) and
          all(isinstance(value, unicode) for value in values)
          for key, values in dimensions.iteritems()):
        quarantined_msg = (
            'Invalid dimensions type:\n%s' % json.dumps(dimensions,
              sort_keys=True, indent=2, separators=(',', ': ')))
        break

      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)
      if dimensions_count > task_to_run.MAX_DIMENSIONS:
        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count
        break

      if not isinstance(
          state.get('lease_expiration_ts'), (None.__class__, int)):
        quarantined_msg = (
            'lease_expiration_ts (%r) must be int or None' % (
                state['lease_expiration_ts']))
        break

    if quarantined_msg:
      line = 'Quarantined Bot\nhttps://%s/restricted/bot/%s\n%s' % (
          app_identity.get_default_version_hostname(), bot_id,
          quarantined_msg)
      ereporter2.log_request(self.request, source='bot', message=line)
      return request, bot_id, version, state, dimensions, quarantined_msg

    # Look for admin enforced quarantine.
    bot_settings = bot_management.get_settings_key(bot_id).get()
    if bool(bot_settings and bot_settings.quarantined):
      return request, bot_id, version, state, dimensions, 'Quarantined by admin'

    return request, bot_id, version, state, dimensions, None


class BotHandshakeHandler(_BotBaseHandler):
  """First request to be called to get initial data like XSRF token.

  The bot is server-controled so the server doesn't have to support multiple API
  version. When running a task, the bot sync the the version specific URL. Once
  abot finished its currently running task, it'll be immediately be upgraded
  after on its next poll.

  This endpoint does not return commands to the bot, for example to upgrade
  itself. It'll be told so when it does its first poll.

  Response body is a JSON dict:
    {
      "bot_version": <sha-1 of swarming_bot.zip uncompressed content>,
      "server_version": "138-193f1f3",
      "xsrf_token": "......",                    
    }
  """

  # This handler is called to get XSRF token, there's nothing to enforce yet.
  xsrf_token_enforce_on = ()                    

  @auth.require_xsrf_token_request                    
  @auth.require(acl.is_bot)
  def post(self):
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    bot_management.bot_event(
        event_type='bot_connected', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=dimensions,
        state=state, version=version, quarantined=bool(quarantined_msg),
        task_id='', task_name=None, message=quarantined_msg)

    data = {
      # This access token will be used to validate each subsequent request.
      'bot_version': bot_code.get_bot_version(self.request.host_url),
      'expiration_sec': auth.handler.XSRFToken.expiration_sec,
      'server_version': utils.get_app_version(),
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.send_response(data)


class BotPollHandler(_BotBaseHandler):
  """The bot polls for a task; returns either a task, update command or sleep.

  In case of exception on the bot, this is enough to get it just far enough to
  eventually self-update to a working version. This is to ensure that coding
  errors in bot code doesn't kill all the fleet at once, they should still be up
  just enough to be able to self-update again even if they don't get task
  assigned anymore.
  """

  @auth.require(acl.is_bot)
  def post(self):
    """Handles a polling request.

    Be very permissive on missing values. This can happen because of errors
    on the bot, *we don't want to deny them the capacity to update*, so that the
    bot code is eventually fixed and the bot self-update to this working code.

    It makes recovery of the fleet in case of catastrophic failure much easier.
    """
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    sleep_streak = state.get('sleep_streak', 0)
    quarantined = bool(quarantined_msg)

    # Note bot existence at two places, one for stats at 1 minute resolution,
    # the other for the list of known bots.
    action = 'bot_inactive' if quarantined else 'bot_active'
    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)

    def bot_event(event_type, task_id=None, task_name=None):
      bot_management.bot_event(
          event_type=event_type, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=dimensions,
          state=state, version=version, quarantined=quarantined,
          task_id=task_id, task_name=task_name, message=quarantined_msg)

    # Bot version is host-specific because the host URL is embedded in
    # swarming_bot.zip
    expected_version = bot_code.get_bot_version(self.request.host_url)
    if version != expected_version:
      bot_event('request_update')
      self._cmd_update(expected_version)
      return
    if quarantined:
      bot_event('request_sleep')
      self._cmd_sleep(sleep_streak, quarantined)
      return

    #
    # At that point, the bot should be in relatively good shape since it's
    # running the right version. It is still possible that invalid code was
    # pushed to the server, so be diligent about it.
    #

    # Bot may need a reboot if it is running for too long. We do not reboot
    # quarantined bots.
    needs_restart, restart_message = bot_management.should_restart_bot(
        bot_id, state)
    if needs_restart:
      bot_event('request_restart')
      self._cmd_restart(restart_message)
      return

    # The bot is in good shape. Try to grab a task.
    try:
      # This is a fairly complex function call, exceptions are expected.
      request, run_result = task_scheduler.bot_reap_task(
          dimensions, bot_id, version, state.get('lease_expiration_ts'))
      if not request:
        # No task found, tell it to sleep a bit.
        bot_event('request_sleep')
        self._cmd_sleep(sleep_streak, quarantined)
        return

      try:
        # This part is tricky since it intentionally runs a transaction after
        # another one.
        if request.properties.is_terminate:
          bot_event('bot_terminate', task_id=run_result.task_id)
          self._cmd_terminate(run_result.task_id)
        else:
          bot_event(
              'request_task', task_id=run_result.task_id,
              task_name=request.name)
          self._cmd_run(request, run_result.key, bot_id)
      except:
        logging.exception('Dang, exception after reaping')
        raise
    except runtime.DeadlineExceededError:
      # If the timeout happened before a task was assigned there is no problems.
      # If the timeout occurred after a task was assigned, that task will
      # timeout (BOT_DIED) since the bot didn't get the details required to
      # run it) and it will automatically get retried (TODO) when the task times
      # out.
      # TODO(maruel): Note the task if possible and hand it out on next poll.
      # https://code.google.com/p/swarming/issues/detail?id=130
      self.abort(500, 'Deadline')

  def _cmd_run(self, request, run_result_key, bot_id):
    cmd = None
    if request.properties.commands:
      cmd = request.properties.commands[0]
    elif request.properties.command:
      cmd = request.properties.command
    out = {
      'cmd': 'run',
      'manifest': {
        'bot_id': bot_id,
        'command': cmd,
        'dimensions': request.properties.dimensions,
        'env': request.properties.env,
        'extra_args': request.properties.extra_args,
        'grace_period': request.properties.grace_period_secs,
        'hard_timeout': request.properties.execution_timeout_secs,
        'host': utils.get_versioned_hosturl(),
        'io_timeout': request.properties.io_timeout_secs,
        'inputs_ref': request.properties.inputs_ref,
        'task_id': task_pack.pack_run_result_key(run_result_key),
      },
    }
    self.send_response(utils.to_json_encodable(out))

  def _cmd_sleep(self, sleep_streak, quarantined):
    out = {
      'cmd': 'sleep',
      'duration': task_scheduler.exponential_backoff(sleep_streak),
      'quarantined': quarantined,
    }
    self.send_response(out)

  def _cmd_terminate(self, task_id):
    out = {
      'cmd': 'terminate',
      'task_id': task_id,
    }
    self.send_response(out)

  def _cmd_update(self, expected_version):
    out = {
      'cmd': 'update',
      'version': expected_version,
    }
    self.send_response(out)

  def _cmd_restart(self, message):
    logging.info('Rebooting bot: %s', message)
    out = {
      'cmd': 'restart',
      'message': message,
    }
    self.send_response(out)


class BotEventHandler(_BotBaseHandler):
  """On signal that a bot had an event worth logging."""

  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}

  @auth.require(acl.is_bot)
  def post(self):
    (request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    event = request.get('event')
    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):
      self.abort_with_error(400, error='Unsupported event type')
    message = request.get('message')
    bot_management.bot_event(
        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,
        dimensions=dimensions, state=state, version=version,
        quarantined=bool(quarantined_msg), task_id=None, task_name=None,
        message=message)

    if event == 'bot_error':
      line = (
          'Bot: https://%s/restricted/bot/%s\n'
          'Bot error:\n'
          '%s') % (
          app_identity.get_default_version_hostname(), bot_id, message)
      ereporter2.log_request(self.request, source='bot', message=line)
    self.send_response({})


class BotTaskUpdateHandler(auth.ApiHandler):
  """Receives updates from a Bot for a task.

  The handler verifies packets are processed in order and will refuse
  out-of-order packets.
  """
  ACCEPTED_KEYS = {
    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',
    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',
    u'output_chunk_start', u'outputs_ref', u'task_id',
  }
  REQUIRED_KEYS = {u'id', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    # Unlike handshake and poll, we do not accept invalid keys here. This code
    # path is much more strict.
    request = self.parse_body()
    msg = log_unexpected_subset_keys(
        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',
        'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    bot_id = request['id']
    cost_usd = request['cost_usd']
    task_id = request['task_id']

    bot_overhead = request.get('bot_overhead')
    duration = request.get('duration')
    exit_code = request.get('exit_code')
    hard_timeout = request.get('hard_timeout')
    io_timeout = request.get('io_timeout')
    isolated_stats = request.get('isolated_stats')
    output = request.get('output')
    output_chunk_start = request.get('output_chunk_start')
    outputs_ref = request.get('outputs_ref')

    if bool(isolated_stats) != (bot_overhead is not None):
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % task_id)
      self.abort_with_error(
          400,
          error='Both bot_overhead and isolated_stats must be set '
                'simultaneously\nbot_overhead: %s\nisolated_stats: %s' %
                (bot_overhead, isolated_stats))

    run_result_key = task_pack.unpack_run_result_key(task_id)
    performance_stats = None
    if isolated_stats:
      download = isolated_stats['download']
      upload = isolated_stats['upload']
      performance_stats = task_result.PerformanceStats(
          bot_overhead=bot_overhead,
          isolated_download=task_result.IsolatedOperation(
              duration=download['duration'],
              initial_number_items=download['initial_number_items'],
              initial_size=download['initial_size'],
              items_cold=base64.b64decode(download['items_cold']),
              items_hot=base64.b64decode(download['items_hot'])),
          isolated_upload=task_result.IsolatedOperation(
              duration=upload['duration'],
              items_cold=base64.b64decode(upload['items_cold']),
              items_hot=base64.b64decode(upload['items_hot'])))

    if output is not None:
      try:
        output = base64.b64decode(output)
      except UnicodeEncodeError as e:
        logging.error('Failed to decode output\n%s\n%r', e, output)
        output = output.encode('ascii', 'replace')
      except TypeError as e:
        # Save the output as-is instead. The error will be logged in ereporter2
        # and returning a HTTP 500 would only force the bot to stay in a retry
        # loop.
        logging.error('Failed to decode output\n%s\n%r', e, output)
    if outputs_ref:
      outputs_ref = task_request.FilesRef(**outputs_ref)

    try:
      state = task_scheduler.bot_update_task(
          run_result_key=run_result_key,
          bot_id=bot_id,
          output=output,
          output_chunk_start=output_chunk_start,
          exit_code=exit_code,
          duration=duration,
          hard_timeout=hard_timeout,
          io_timeout=io_timeout,
          cost_usd=cost_usd,
          outputs_ref=outputs_ref,
          performance_stats=performance_stats)
      if not state:
        logging.info('Failed to update, please retry')
        self.abort_with_error(500, error='Failed to update, please retry')

      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):
        action = 'task_completed'
      else:
        assert state == task_result.State.RUNNING, state
        action = 'task_update'
      bot_management.bot_event(
          event_type=action, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=None, state=None,
          version=None, quarantined=None, task_id=task_id, task_name=None)
    except ValueError as e:
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % e)
      self.abort_with_error(400, error=str(e))
    except webob.exc.HTTPException:
      raise
    except Exception as e:
      logging.exception('Internal error: %s', e)
      self.abort_with_error(500, error=str(e))

    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot
    # reboots itself to abort the task abruptly. It is useful when a task hangs
    # and the timeout was set too long or the task was superseded by a newer
    # task with more recent executable (e.g. a new Try Server job on a newer
    # patchset on Rietveld).
    self.send_response({'ok': True})


class BotTaskErrorHandler(auth.ApiHandler):
  """It is a specialized version of ereporter2's /ereporter2/api/v1/on_error
  that also attaches a task id to it.

  This formally kills the task, marking it as an internal failure. This can be
  used by bot_main.py to kill the task when task_runner misbehaved.
  """

  EXPECTED_KEYS = {u'id', u'message', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    request = self.parse_body()
    bot_id = request.get('id')
    task_id = request.get('task_id', '')
    message = request.get('message', 'unknown')

    bot_management.bot_event(
        event_type='task_error', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=None, state=None,
        version=None, quarantined=None, task_id=task_id, task_name=None,
        message=message)
    line = (
        'Bot: https://%s/restricted/bot/%s\n'
        'Task failed: https://%s/user/task/%s\n'
        '%s') % (
        app_identity.get_default_version_hostname(), bot_id,
        app_identity.get_default_version_hostname(), task_id,
        message)
    ereporter2.log_request(self.request, source='bot', message=line)

    msg = log_unexpected_keys(
        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    msg = task_scheduler.bot_kill_task(
        task_pack.unpack_run_result_key(task_id), bot_id)
    if msg:
      logging.error(msg)
      self.abort_with_error(400, error=msg)
    self.send_response({})


class ServerPingHandler(webapp2.RequestHandler):
  """Handler to ping when checking if the server is up.

  This handler should be extremely lightweight. It shouldn't do any
  computations, it should just state that the server is up. It's open to
  everyone for simplicity and performance.
  """

  def get(self):
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.out.write('Server up')


def get_routes():
  routes = [
      ('/bootstrap', BootstrapHandler),
      ('/bot_code', BotCodeHandler),
      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),
      ('/swarming/api/v1/bot/event', BotEventHandler),
      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),
      ('/swarming/api/v1/bot/poll', BotPollHandler),
      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),
      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',
          BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),
      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',
          BotTaskErrorHandler),
  ]
  return [webapp2.Route(*i) for i in routes]

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Generates the swarming_bot.zip archive for the bot.

Unlike the other source files, this file can be run from ../tools/bot_archive.py
stand-alone to generate a swarming_bot.zip for local testing so it doesn't
import anything from the AppEngine SDK.

The hash of the content of the files in the archive is used to define the
current version of the swarming bot code.
"""

import hashlib
import json
import logging
import os
import StringIO
import zipfile


# List of files needed by the swarming bot.
# TODO(maruel): Make the list automatically generated?
FILES = (
    '__main__.py',
    'api/__init__.py',
    'api/bot.py',
    'api/parallel.py',
    'api/os_utilities.py',
    'api/platforms/__init__.py',
    'api/platforms/android.py',
    'api/platforms/common.py',
    'api/platforms/gce.py',
    'api/platforms/linux.py',
    'api/platforms/osx.py',
    'api/platforms/posix.py',
    'api/platforms/win.py',
    'bot_code/__init__.py',
    'bot_code/bot_main.py',
    'bot_code/common.py',
    'bot_code/singleton.py',
    'bot_code/task_runner.py',
    'bot_code/xsrf_client.py',                    
    'client/auth.py',
    'client/isolated_format.py',
    'client/isolateserver.py',
    'client/run_isolated.py',
    'config/__init__.py',
    'third_party/__init__.py',
    'third_party/colorama/__init__.py',
    'third_party/colorama/ansi.py',
    'third_party/colorama/ansitowin32.py',
    'third_party/colorama/initialise.py',
    'third_party/colorama/win32.py',
    'third_party/colorama/winterm.py',
    'third_party/depot_tools/__init__.py',
    'third_party/depot_tools/fix_encoding.py',
    'third_party/depot_tools/subcommand.py',
    'third_party/httplib2/__init__.py',
    'third_party/httplib2/cacerts.txt',
    'third_party/httplib2/iri2uri.py',
    'third_party/httplib2/socks.py',
    'third_party/oauth2client/__init__.py',
    'third_party/oauth2client/_helpers.py',
    'third_party/oauth2client/_openssl_crypt.py',
    'third_party/oauth2client/_pycrypto_crypt.py',
    'third_party/oauth2client/client.py',
    'third_party/oauth2client/clientsecrets.py',
    'third_party/oauth2client/crypt.py',
    'third_party/oauth2client/file.py',
    'third_party/oauth2client/gce.py',
    'third_party/oauth2client/keyring_storage.py',
    'third_party/oauth2client/locked_file.py',
    'third_party/oauth2client/multistore_file.py',
    'third_party/oauth2client/service_account.py',
    'third_party/oauth2client/tools.py',
    'third_party/oauth2client/util.py',
    'third_party/oauth2client/xsrfutil.py',
    'third_party/pyasn1/pyasn1/__init__.py',
    'third_party/pyasn1/pyasn1/codec/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',
    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',
    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',
    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',
    'third_party/pyasn1/pyasn1/codec/der/__init__.py',
    'third_party/pyasn1/pyasn1/codec/der/decoder.py',
    'third_party/pyasn1/pyasn1/codec/der/encoder.py',
    'third_party/pyasn1/pyasn1/compat/__init__.py',
    'third_party/pyasn1/pyasn1/compat/binary.py',
    'third_party/pyasn1/pyasn1/compat/octets.py',
    'third_party/pyasn1/pyasn1/debug.py',
    'third_party/pyasn1/pyasn1/error.py',
    'third_party/pyasn1/pyasn1/type/__init__.py',
    'third_party/pyasn1/pyasn1/type/base.py',
    'third_party/pyasn1/pyasn1/type/char.py',
    'third_party/pyasn1/pyasn1/type/constraint.py',
    'third_party/pyasn1/pyasn1/type/error.py',
    'third_party/pyasn1/pyasn1/type/namedtype.py',
    'third_party/pyasn1/pyasn1/type/namedval.py',
    'third_party/pyasn1/pyasn1/type/tag.py',
    'third_party/pyasn1/pyasn1/type/tagmap.py',
    'third_party/pyasn1/pyasn1/type/univ.py',
    'third_party/pyasn1/pyasn1/type/useful.py',
    'third_party/requests/__init__.py',
    'third_party/requests/adapters.py',
    'third_party/requests/api.py',
    'third_party/requests/auth.py',
    'third_party/requests/certs.py',
    'third_party/requests/compat.py',
    'third_party/requests/cookies.py',
    'third_party/requests/exceptions.py',
    'third_party/requests/hooks.py',
    'third_party/requests/models.py',
    'third_party/requests/packages/__init__.py',
    'third_party/requests/packages/urllib3/__init__.py',
    'third_party/requests/packages/urllib3/_collections.py',
    'third_party/requests/packages/urllib3/connection.py',
    'third_party/requests/packages/urllib3/connectionpool.py',
    'third_party/requests/packages/urllib3/contrib/__init__.py',
    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',
    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',
    'third_party/requests/packages/urllib3/exceptions.py',
    'third_party/requests/packages/urllib3/fields.py',
    'third_party/requests/packages/urllib3/filepost.py',
    'third_party/requests/packages/urllib3/packages/__init__.py',
    'third_party/requests/packages/urllib3/packages/ordered_dict.py',
    'third_party/requests/packages/urllib3/packages/six.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '__init__.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '_implementation.py',
    'third_party/requests/packages/urllib3/poolmanager.py',
    'third_party/requests/packages/urllib3/request.py',
    'third_party/requests/packages/urllib3/response.py',
    'third_party/requests/packages/urllib3/util/__init__.py',
    'third_party/requests/packages/urllib3/util/connection.py',
    'third_party/requests/packages/urllib3/util/request.py',
    'third_party/requests/packages/urllib3/util/response.py',
    'third_party/requests/packages/urllib3/util/retry.py',
    'third_party/requests/packages/urllib3/util/ssl_.py',
    'third_party/requests/packages/urllib3/util/timeout.py',
    'third_party/requests/packages/urllib3/util/url.py',
    'third_party/requests/sessions.py',
    'third_party/requests/status_codes.py',
    'third_party/requests/structures.py',
    'third_party/requests/utils.py',
    'third_party/rsa/rsa/__init__.py',
    'third_party/rsa/rsa/_compat.py',
    'third_party/rsa/rsa/_version133.py',
    'third_party/rsa/rsa/_version200.py',
    'third_party/rsa/rsa/asn1.py',
    'third_party/rsa/rsa/bigfile.py',
    'third_party/rsa/rsa/cli.py',
    'third_party/rsa/rsa/common.py',
    'third_party/rsa/rsa/core.py',
    'third_party/rsa/rsa/key.py',
    'third_party/rsa/rsa/parallel.py',
    'third_party/rsa/rsa/pem.py',
    'third_party/rsa/rsa/pkcs1.py',
    'third_party/rsa/rsa/prime.py',
    'third_party/rsa/rsa/randnum.py',
    'third_party/rsa/rsa/transform.py',
    'third_party/rsa/rsa/util.py',
    'third_party/rsa/rsa/varblock.py',
    'third_party/six/__init__.py',
    'utils/__init__.py',
    'utils/cacert.pem',
    'utils/file_path.py',
    'utils/fs.py',
    'utils/large.py',
    'utils/logging_utils.py',
    'utils/lru.py',
    'utils/net.py',
    'utils/oauth.py',
    'utils/on_error.py',
    'utils/subprocess42.py',
    'utils/threading_utils.py',
    'utils/tools.py',
    'utils/zip_package.py',
    'adb/__init__.py',
    'adb/adb_commands.py',
    'adb/adb_protocol.py',
    'adb/common.py',
    'adb/contrib/__init__.py',
    'adb/contrib/adb_commands_safe.py',
    'adb/contrib/high.py',
    'adb/contrib/parallel.py',
    'adb/fastboot.py',
    'adb/filesync_protocol.py',
    'adb/sign_pythonrsa.py',
    'adb/usb_exceptions.py',
    'python_libusb1/__init__.py',
    'python_libusb1/libusb1.py',
    'python_libusb1/usb1.py',
)


def is_windows():
  """Returns True if this code is running under Windows."""
  return os.__file__[0] != '/'


def resolve_symlink(path):
  """Processes path containing symlink on Windows.

  This is needed to make ../swarming_bot/main_test.py pass on Windows because
  git on Windows renders symlinks as normal files.
  """
  if not is_windows():
    # Only does this dance on Windows.
    return path
  parts = os.path.normpath(path).split(os.path.sep)
  for i in xrange(2, len(parts)):
    partial = os.path.sep.join(parts[:i])
    if os.path.isfile(partial):
      with open(partial) as f:
        link = f.read()
      assert '\n' not in link and link, link
      parts[i-1] = link
  return os.path.normpath(os.path.sep.join(parts))


def yield_swarming_bot_files(root_dir, host, host_version, additionals):
  """Yields all the files to map as tuple(filename, content).

  config.json is injected with json data about the server.

  This function guarantees that the output is sorted by filename.
  """
  items = {i: None for i in FILES}
  items.update(additionals)
  config = {
    'server': host.rstrip('/'),
    'server_version': host_version,
  }
  items['config/config.json'] = json.dumps(config)
  for item, content in sorted(items.iteritems()):
    if content is not None:
      yield item, content
    else:
      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:
        yield item, f.read()


def get_swarming_bot_zip(root_dir, host, host_version, additionals):
  """Returns a zipped file of all the files a bot needs to run.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: dict(filepath: content) of additional items to put into the zip
        file, in addition to FILES and MAPPED. In practice, it's going to be a
        custom bot_config.py.
  Returns:
    Tuple(str being the zipped file's content, bot version (SHA-1) it
    represents).
  """
  zip_memory_file = StringIO.StringIO()
  h = hashlib.sha1()
  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      zip_file.writestr(name, content)
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)

  data = zip_memory_file.getvalue()
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_zip(%s) is %d bytes; %s',
      additionals.keys(), len(data), bot_version)
  return data, bot_version


def get_swarming_bot_version(root_dir, host, host_version, additionals):
  """Returns the SHA1 hash of the bot code, representing the version.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: See get_swarming_bot_zip's doc.

  Returns:
    The SHA1 hash of the bot code.
  """
  h = hashlib.sha1()
  try:
    # TODO(maruel): Deduplicate from zip_package.genereate_version().
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)
  except IOError:
    logging.warning('Missing expected file. Hash will be invalid.')
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)
  return bot_version

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Runs either task_runner.py, bot_main.py or bot_config.py.

The imports are done late so if an ImportError occurs, it is localized to this
command only.
"""

import code
import json
import logging
import os
import optparse
import shutil
import sys
import zipfile

from bot_code import common                    

# That's from ../../../client/
from third_party.depot_tools import fix_encoding
from utils import logging_utils
from utils import zip_package

# This file can only be run as a zip.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# libusb1 expects to be directly in sys.path.
sys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))


# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the
# sub commands packed into the single .zip file as a swiss army knife (think
# busybox but worse).


def CMDattributes(_args):
  """Prints out the bot's attributes."""
  from bot_code import bot_main
  json.dump(
      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,
      sort_keys=True, separators=(',', ': '))
  print('')
  return 0


def CMDconfig(_args):
  """Prints the config.json embedded in this zip."""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)
  print('')
  return 0


def CMDis_fine(_args):
  """Just reports that the code doesn't throw.

  That ensures that the bot has minimal viability before transfering control to
  it. For now, it just imports bot_main but later it'll check the config, etc.
  """
  # pylint: disable=unused-variable
  from bot_code import bot_main
  from config import bot_config
  # We're #goodenough.
  return 0


def CMDrestart(_args):
  """Utility subcommand that hides the difference between each OS to reboot
  the host."""
  logging_utils.prepare_logging(None)
  import os_utilities
  # This function doesn't return.
  os_utilities.restart()
  # Should never reach here.
  return 1


def CMDrun_isolated(args):
  """Internal command to run an isolated command."""
  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))
  # run_isolated setups logging by itself.
  import run_isolated
  return run_isolated.main(args)


def CMDsetup(_args):
  """Setup the bot to auto-start but doesn't start the bot."""
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))
  from bot_code import bot_main
  bot_main.setup_bot(True)
  return 0


def CMDserver(_args):
  """Prints the server url. It's like 'config' but easier to parse."""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  print bot_main.get_config()['server']
  return 0


def CMDshell(args):
  """Starts a shell with api.* in.."""
  logging_utils.prepare_logging(None)
  logging_utils.set_console_level(logging.DEBUG)

  from bot_code import bot_main
  from api import os_utilities
  from api import platforms
  local_vars = {
    'bot_main': bot_main,
    'json': json,
    'os_utilities': os_utilities,
    'platforms': platforms,
  }
  # Can't use: from api.platforms import *
  local_vars.update(
      (k, v) for k, v in platforms.__dict__.iteritems()
      if not k.startswith('_'))

  if args:
    for arg in args:
      exec code.compile_command(arg) in local_vars
  else:
    code.interact(
        'Locals:\n  ' + '\n  '.join( sorted(local_vars)), None, local_vars)
  return 0


def CMDstart_bot(args):
  """Starts the swarming bot."""
  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))
  logging.info(
      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())
  from bot_code import bot_main
  result = bot_main.main(args)
  logging.info('bot_main exit code: %d', result)
  return result


def CMDstart_slave(args):
  """Ill named command that actually sets up the bot then start it."""
  # TODO(maruel): Rename function.
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))

  parser = optparse.OptionParser()
  parser.add_option(
      '--survive', action='store_true',
      help='Do not reboot the host even if bot_config.setup_bot() asked to')
  options, args = parser.parse_args(args)

  try:
    from bot_code import bot_main
    bot_main.setup_bot(options.survive)
  except Exception:
    logging.exception('bot_main.py failed.')

  logging.info('Starting the bot: %s', THIS_FILE)
  return common.exec_python([THIS_FILE, 'start_bot'])


def CMDtask_runner(args):
  """Internal command to run a swarming task."""
  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))
  from bot_code import task_runner
  return task_runner.main(args)


def CMDversion(_args):
  """Prints the version of this file and the hash of the code."""
  logging_utils.prepare_logging(None)
  print zip_package.generate_version()
  return 0


def main():
  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':
    # Disable itself when run under Google Chrome Remote Desktop, as it's
    # normally started at the console and starting up via Remote Desktop would
    # cause multiple bots to run concurrently on the host.
    print >> sys.stderr, (
        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')
    return 0

  # Always make the current working directory the directory containing this
  # file. It simplifies assumptions.
  os.chdir(os.path.dirname(THIS_FILE))
  # Always create the logs dir first thing, before printing anything out.
  if not os.path.isdir('logs'):
    os.mkdir('logs')

  # This is necessary so os.path.join() works with unicode path. No kidding.
  # This must be done here as each of the command take wildly different code
  # path and this must be run in every case, as it causes really unexpected
  # issues otherwise, especially in module os.path.
  fix_encoding.fix_encoding()

  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':
    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.
    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()
    if os.path.isfile('swarming_bot.1.zip'):
      os.remove('swarming_bot.1.zip')
    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')
    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]
    print >> sys.stderr, 'cmd: %s' % cmd
    return common.exec_python(cmd)

  # sys.argv[0] is the zip file itself.
  cmd = 'start_slave'
  args = []
  if len(sys.argv) > 1:
    cmd = sys.argv[1]
    args = sys.argv[2:]

  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)
  if fn:
    try:
      return fn(args)
    except ImportError:
      logging.exception('Failed to run %s', cmd)
      with zipfile.ZipFile(THIS_FILE, 'r') as f:
        logging.error('Files in %s:\n%s', THIS_FILE, f.namelist())
      return 1

  print >> sys.stderr, 'Unknown command %s' % cmd
  return 1


if __name__ == '__main__':
  sys.exit(main())

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Bot interface used in bot_config.py."""

import logging
import os
import threading
import time

import os_utilities
from utils import zip_package

THIS_FILE = os.path.abspath(zip_package.get_main_script_path())

# Method could be a function - pylint: disable=R0201


class Bot(object):
  def __init__(
      self, remote, attributes, server, server_version, base_dir,                    
      shutdown_hook):                    
    # Do not expose attributes nor remote for now, as attributes will be
    # refactored soon and remote would have a lot of side effects if used by
    # bot_config.
    self._attributes = attributes
    self._base_dir = base_dir
    self._remote = remote                    
    self._server = server
    self._server_version = server_version
    self._shutdown_hook = shutdown_hook
    self._timers = []
    self._timers_dying = False
    self._timers_lock = threading.Lock()

  @property                    
  def base_dir(self):
    """Returns the working directory.

    It is normally the current workind directory, e.g. os.getcwd() but it is
    preferable to not assume that.
    """
    return self._base_dir

  @property                    
  def dimensions(self):
    """The bot's current dimensions.

    Dimensions are relatively static and not expected to change much. They
    should change only when it effectively affects the bot's capacity to execute
    tasks.
    """
    return self._attributes.get('dimensions', {}).copy()

  @property                    
  def id(self):
    """Returns the bot's ID."""
    return self.dimensions.get('id', ['unknown'])[0]

  @property                    
  def remote(self):                    
    """XsrfClient instance to talk to the server.                    

    Should not be normally used by bot_config.py for now.                    
    """
    return self._remote                    

  @property                    
  def server(self):
    """URL of the swarming server this bot is connected to.

    It includes the https:// prefix but without trailing /, so it looks like
    "https://foo-bar.appspot.com".
    """
    return self._server

  @property                    
  def server_version(self):
    """Version of the server's implementation.

    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu
    for non-upstreamed code base:
      nnn: revision pseudo number
      hhhhhhh: git commit hash
      uuuu: username
    """
    return self._server_version

  @property                    
  def state(self):
    return self._attributes['state']

  @property                    
  def swarming_bot_zip(self):
    """Absolute path to the swarming_bot.zip file.

    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always
    return swarming_bot.zip since this is the script that must be used when
    starting up.
    """
    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')

  def post_event(self, event_type, message):
    """Posts an event to the server."""
    data = self._attributes.copy()
    data['event'] = event_type
    data['message'] = message
    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)                    

  def post_error(self, message):
    """Posts given string as a failure.

    This is used in case of internal code error. It traps exception.
    """
    logging.error('Error: %s\n%s', self._attributes, message)
    try:
      self.post_event('bot_error', message)
    except Exception:
      logging.exception('post_error(%s) failed.', message)

  def restart(self, message):
    """Reboots the machine.

    If the reboot is successful, never returns: the process should just be
    killed by OS.

    If reboot fails, logs the error to the server and moves the bot to
    quarantined mode.
    """
    self.post_event('bot_rebooting', message)
    self.cancel_all_timers()
    if self._shutdown_hook:
      try:
        self._shutdown_hook(self)
      except Exception as e:
        logging.exception('shutdown hook failed: %s', e)
    # os_utilities.restart should never return, unless restart is not happening.
    # If restart is taking longer than N minutes, it probably not going to
    # finish at all. Report this to the server.
    try:
      os_utilities.restart(message, timeout=15*60)
    except LookupError:
      # This is a special case where OSX is deeply hosed. In that case the disk
      # is likely in read-only mode and there isn't much that can be done. This
      # exception is deep inside pickle.py. So notify the server then hang in
      # there.
      self.post_error('This host partition is bad; please fix the host')
      while True:
        time.sleep(1)
    self.post_error('Bot is stuck restarting for: %s' % message)

  def call_later(self, delay_sec, callback):
    """Schedules a function to be called later (if bot is still running).

    All calls are executed in a separate internal thread, be careful with what
    you call from there (Bot object is generally not thread safe).

    Multiple callbacks can be executed concurrently. It is safe to call
    'call_later' from the callback.
    """
    timer = None

    def call_wrapper():
      with self._timers_lock:
        # Canceled already?
        if timer not in self._timers:
          return
        self._timers.remove(timer)
      try:
        callback()
      except Exception:
        logging.exception('Timer callback failed')

    with self._timers_lock:
      if not self._timers_dying:
        timer = threading.Timer(delay_sec, call_wrapper)
        self._timers.append(timer)
        timer.daemon = True
        timer.start()

  def cancel_all_timers(self):
    """Cancels all pending 'call_later' calls and forbids adding new ones."""
    timers = None
    with self._timers_lock:
      self._timers_dying = True
      for t in self._timers:
        t.cancel()
      timers, self._timers = self._timers, []
    for t in timers:
      t.join(timeout=5)
      if t.isAlive():
        logging.error('Timer thread did not terminate fast enough: %s', t)

  def update_dimensions(self, new_dimensions):
    """Called internally to update Bot.dimensions."""
    self._attributes['dimensions'] = new_dimensions

  def update_state(self, new_state):
    """Called internally to update Bot.state."""
    self._attributes['state'] = new_state



# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Runs a Swarming task.

Downloads all the necessary files to run the task, executes the command and
streams results back to the Swarming server.

The process exit code is 0 when the task was executed, even if the task itself
failed. If there's any failure in the setup or teardown, like invalid packet
response, failure to contact the server, etc, a non zero exit code is used. It's
up to the calling process (bot_main.py) to signal that there was an internal
failure and to cancel this task run and ask the server to retry it.
"""

import base64
import json
import logging
import optparse
import os
import signal
import sys
import time

import xsrf_client                    
from utils import net
from utils import on_error
from utils import subprocess42
from utils import zip_package


# Path to this file or the zip containing this file.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# Sends a maximum of 100kb of stdout per task_update packet.
MAX_CHUNK_SIZE = 102400


# Maximum wait between task_update packet when there's no output.
MAX_PACKET_INTERVAL = 30


# Minimum wait between task_update packet when there's output.
MIN_PACKET_INTERNAL = 10


# Current task_runner_out version.
OUT_VERSION = 3


# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real
# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.
SIG_BREAK_OR_TERM = (
    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)


# Used to implement monotonic_time for a clock that never goes backward.
_last_now = 0


def monotonic_time():
  """Returns monotonically increasing time."""
  global _last_now
  now = time.time()
  if now > _last_now:
    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.
    _last_now = now
  return _last_now


def get_run_isolated():
  """Returns the path to itself to run run_isolated.

  Mocked in test to point to the real run_isolated.py script.
  """
  return [sys.executable, THIS_FILE, 'run_isolated']


def get_isolated_cmd(
    work_dir, task_details, isolated_result, min_free_space):
  """Returns the command to call run_isolated. Mocked in tests."""
  bot_dir = os.path.dirname(work_dir)
  if os.path.isfile(isolated_result):
    os.remove(isolated_result)
  cmd = get_run_isolated()
  cmd.extend(
      [
        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),
        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),
        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),
        '--json', isolated_result,
        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),
        '--cache', os.path.join(bot_dir, 'cache'),
        '--root-dir', os.path.join(work_dir, 'isolated'),
      ])
  if min_free_space:
    cmd.extend(('--min-free-space', str(min_free_space)))

  if task_details.hard_timeout:
    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))
  if task_details.grace_period:
    cmd.extend(('--grace-period', str(task_details.grace_period)))
  if task_details.extra_args:
    cmd.append('--')
    cmd.extend(task_details.extra_args)
  return cmd


class TaskDetails(object):
  def __init__(self, data):
    """Loads the raw data.

    It is expected to have at least:
     - bot_id
     - command as a list of str
     - data as a list of urls
     - env as a dict
     - hard_timeout
     - io_timeout
     - task_id
    """
    logging.info('TaskDetails(%s)', data)
    if not isinstance(data, dict):
      raise ValueError('Expected dict, got %r' % data)

    # Get all the data first so it fails early if the task details is invalid.
    self.bot_id = data['bot_id']

    # Raw command. Only self.command or self.inputs_ref can be set.
    self.command = data['command'] or []

    # Isolated command. Is a serialized version of task_request.FilesRef.
    self.inputs_ref = data['inputs_ref']
    self.extra_args = data['extra_args']

    self.env = {
      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()
    }
    self.grace_period = data['grace_period']
    self.hard_timeout = data['hard_timeout']
    self.io_timeout = data['io_timeout']
    self.task_id = data['task_id']


class MustExit(Exception):
  """Raised on signal that the process must exit immediately."""
  def __init__(self, sig):
    super(MustExit, self).__init__()
    self.signal = sig


def load_and_run(
    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):
  """Loads the task's metadata and execute it.

  This may throw all sorts of exceptions in case of failure. It's up to the
  caller to trap them. These shall be considered 'internal_failure' instead of
  'failure' from a TaskRunResult standpoint.
  """
  # The work directory is guaranteed to exist since it was created by
  # bot_main.py and contains the manifest. Temporary files will be downloaded
  # there. It's bot_main.py that will delete the directory afterward. Tests are
  # not run from there.
  task_result = None
  def handler(sig, _):
    logging.info('Got signal %s', sig)
    raise MustExit(sig)
  work_dir = os.path.dirname(out_file)
  try:
    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):
      if not os.path.isdir(work_dir):
        raise ValueError('%s expected to exist' % work_dir)

      with open(in_file, 'rb') as f:
        task_details = TaskDetails(json.load(f))

      task_result = run_command(
          swarming_server, task_details, work_dir, cost_usd_hour, start,
          min_free_space)
  except MustExit as e:
    # This normally means run_command() didn't get the chance to run, as it
    # itself trap MustExit and will report accordingly. In this case, we want
    # the parent process to send the message instead.
    if not task_result:
      task_result = {
        u'exit_code': None,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure':
            u'task_runner received signal %s' % e.signal,
        u'version': OUT_VERSION,
      }
  finally:
    # We've found tests to delete 'work' when quitting, causing an exception
    # here. Try to recreate the directory if necessary.
    if not os.path.isdir(work_dir):
      os.mkdir(work_dir)
    with open(out_file, 'wb') as f:
      json.dump(task_result, f)


def post_update(swarming_server, params, exit_code, stdout, output_chunk_start):
  """Posts task update to task_update.

  Arguments:
    swarming_server: XsrfRemote instance.                    
    params: Default JSON parameters for the POST.
    exit_code: Process exit code, only when a command completed.
    stdout: Incremental output since last call, if any.
    output_chunk_start: Total number of stdout previously sent, for coherency
        with the server.
  """
  params = params.copy()
  if exit_code is not None:
    params['exit_code'] = exit_code
  if stdout:
    # The output_chunk_start is used by the server to make sure that the stdout
    # chunks are processed and saved in the DB in order.
    params['output'] = base64.b64encode(stdout)
    params['output_chunk_start'] = output_chunk_start
  # TODO(maruel): Support early cancellation.
  # https://code.google.com/p/swarming/issues/detail?id=62
  resp = swarming_server.url_read_json(                    
      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)                    
  logging.debug('post_update() = %s', resp)
  if resp.get('error'):
    # Abandon it. This will force a process exit.
    raise ValueError(resp.get('error'))


def should_post_update(stdout, now, last_packet):
  """Returns True if it's time to send a task_update packet via post_update().

  Sends a packet when one of this condition is met:
  - more than MAX_CHUNK_SIZE of stdout is buffered.
  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was
    stdout.
  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.
  """
  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval


def calc_yield_wait(task_details, start, last_io, timed_out, stdout):
  """Calculates the maximum number of seconds to wait in yield_any()."""
  now = monotonic_time()
  if timed_out:
    # Give a |grace_period| seconds delay.
    if task_details.grace_period:
      return max(now - timed_out - task_details.grace_period, 0.)
    return 0.

  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  if task_details.hard_timeout:
    out = min(out, start + task_details.hard_timeout - now)
  if task_details.io_timeout:
    out = min(out, last_io + task_details.io_timeout - now)
  out = max(out, 0)
  logging.debug('calc_yield_wait() = %d', out)
  return out


def kill_and_wait(proc, grace_period, reason):
  logging.warning('SIGTERM finally due to %s', reason)
  proc.terminate()
  try:
    proc.wait(grace_period)
  except subprocess42.TimeoutError:
    logging.warning('SIGKILL finally due to %s', reason)
    proc.kill()
  exit_code = proc.wait()
  logging.info('Waiting for proces exit in finally - done')
  return exit_code


def run_command(
    swarming_server, task_details, work_dir, cost_usd_hour, task_start,
    min_free_space):
  """Runs a command and sends packets to the server to stream results back.

  Implements both I/O and hard timeouts. Sends the packets numbered, so the
  server can ensure they are processed in order.

  Returns:
    Metadata about the command.
  """
  # TODO(maruel): This function is incomprehensible, split and refactor.
  # Signal the command is about to be started.
  last_packet = start = now = monotonic_time()
  params = {
    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,
    'id': task_details.bot_id,
    'task_id': task_details.task_id,
  }
  post_update(swarming_server, params, None, '', 0)

  if task_details.command:
    # Raw command.
    cmd = task_details.command
    isolated_result = None
  else:
    # Isolated task.
    isolated_result = os.path.join(work_dir, 'isolated_result.json')
    cmd = get_isolated_cmd(
        work_dir, task_details, isolated_result, min_free_space)
    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to
    # give one 'grace_period' slot to the child process and one slot to upload
    # the results back.
    task_details.hard_timeout = 0
    if task_details.grace_period:
      task_details.grace_period *= 2

  try:
    # TODO(maruel): Support both channels independently and display stderr in
    # red.
    env = None
    if task_details.env:
      env = os.environ.copy()
      for key, value in task_details.env.iteritems():
        if not value:
          env.pop(key, None)
        else:
          env[key] = value
    logging.info('cmd=%s', cmd)
    logging.info('env=%s', env)
    try:
      proc = subprocess42.Popen(
          cmd,
          env=env,
          cwd=work_dir,
          detached=True,
          stdout=subprocess42.PIPE,
          stderr=subprocess42.STDOUT,
          stdin=subprocess42.PIPE)
    except OSError as e:
      stdout = 'Command "%s" failed to start.\nError: %s' % (' '.join(cmd), e)
      now = monotonic_time()
      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
      params['duration'] = now - start
      params['io_timeout'] = False
      params['hard_timeout'] = False
      post_update(swarming_server, params, 1, stdout, 0)
      return {
        u'exit_code': -1,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': OUT_VERSION,
      }

    output_chunk_start = 0
    stdout = ''
    exit_code = None
    had_hard_timeout = False
    had_io_timeout = False
    must_signal_internal_failure = None
    kill_sent = False
    timed_out = None
    try:
      calc = lambda: calc_yield_wait(
          task_details, start, last_io, timed_out, stdout)
      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)
      last_io = monotonic_time()
      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):
        now = monotonic_time()
        if new_data:
          stdout += new_data
          last_io = now

        # Post update if necessary.
        if should_post_update(stdout, now, last_packet):
          last_packet = monotonic_time()
          params['cost_usd'] = (
              cost_usd_hour * (last_packet - task_start) / 60. / 60.)
          post_update(swarming_server, params, None, stdout, output_chunk_start)
          output_chunk_start += len(stdout)
          stdout = ''

        # Send signal on timeout if necessary. Both are failures, not
        # internal_failures.
        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.
        if not timed_out:
          if (task_details.io_timeout and
              now - last_io > task_details.io_timeout):
            had_io_timeout = True
            logging.warning('I/O timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
          elif (task_details.hard_timeout and
              now - start > task_details.hard_timeout):
            had_hard_timeout = True
            logging.warning('Hard timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
        else:
          # During grace period.
          if not kill_sent and now >= timed_out + task_details.grace_period:
            # Now kill for real. The user can distinguish between the following
            # states:
            # - signal but process exited within grace period,
            #   (hard_|io_)_timed_out will be set but the process exit code will
            #   be script provided.
            # - processed exited late, exit code will be -9 on posix.
            logging.warning('Grace exhausted; sending SIGKILL')
            proc.kill()
            kill_sent = True
      logging.info('Waiting for proces exit')
      exit_code = proc.wait()
    except MustExit as e:
      # TODO(maruel): Do the send SIGTERM to child process and give it
      # task_details.grace_period to terminate.
      must_signal_internal_failure = (
          u'task_runner received signal %s' % e.signal)
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'signal %d' % e.signal)
    except (IOError, OSError):
      # Something wrong happened, try to kill the child process.
      had_hard_timeout = True
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'exception %s' % e)

    # This is the very last packet for this command. It if was an isolated task,
    # include the output reference to the archived .isolated file.
    now = monotonic_time()
    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
    params['duration'] = now - start
    params['io_timeout'] = had_io_timeout
    params['hard_timeout'] = had_hard_timeout
    if isolated_result:
      try:
        if ((had_io_timeout or had_hard_timeout) and
            not os.path.isfile(isolated_result)):
          # It's possible that run_isolated failed to quit quickly enough; it
          # could be because there was too much data to upload back or something
          # else. Do not create an internal error, just send back the (partial)
          # view as task_runner saw it, for example the real exit_code is
          # unknown.
          logging.warning('TIMED_OUT and there\'s no result file')
          exit_code = -1
        else:
          # See run_isolated.py for the format.
          with open(isolated_result, 'rb') as f:
            run_isolated_result = json.load(f)
          logging.debug('run_isolated:\n%s', run_isolated_result)
          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,
          # mapping time, etc) from run_isolated and push them to the server.
          if run_isolated_result['outputs_ref']:
            params['outputs_ref'] = run_isolated_result['outputs_ref']
          had_hard_timeout = (
              had_hard_timeout or run_isolated_result['had_hard_timeout'])
          params['hard_timeout'] = had_hard_timeout
          if not had_io_timeout and not had_hard_timeout:
            if run_isolated_result['internal_failure']:
              must_signal_internal_failure = (
                  run_isolated_result['internal_failure'])
              logging.error('%s', must_signal_internal_failure)
            elif exit_code:
              # TODO(maruel): Grab stdout from run_isolated.
              must_signal_internal_failure = (
                  'run_isolated internal failure %d' % exit_code)
              logging.error('%s', must_signal_internal_failure)
          exit_code = run_isolated_result['exit_code']
          if run_isolated_result.get('duration') is not None:
            # Calculate the real task duration as measured by run_isolated and
            # calculate the remaining overhead.
            params['bot_overhead'] = params['duration']
            params['duration'] = run_isolated_result['duration']
            params['bot_overhead'] -= params['duration']
            params['bot_overhead'] -= run_isolated_result.get(
                'download', {}).get('duration', 0)
            params['bot_overhead'] -= run_isolated_result.get(
                'upload', {}).get('duration', 0)
            if params['bot_overhead'] < 0:
              params['bot_overhead'] = 0
          stats = run_isolated_result.get('stats')
          if stats:
            params['isolated_stats'] = stats
      except (IOError, OSError, ValueError) as e:
        logging.error('Swallowing error: %s', e)
        if not must_signal_internal_failure:
          must_signal_internal_failure = str(e)
    # TODO(maruel): Send the internal failure here instead of sending it through
    # bot_main, this causes a race condition.
    if exit_code is None:
      exit_code = -1
    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)
    return {
      u'exit_code': exit_code,
      u'hard_timeout': had_hard_timeout,
      u'io_timeout': had_io_timeout,
      u'must_signal_internal_failure': must_signal_internal_failure,
      u'version': OUT_VERSION,
    }
  finally:
    if isolated_result:
      try:
        os.remove(isolated_result)
      except OSError:
        pass


def main(args):
  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
  parser.add_option('--in-file', help='Name of the request file')
  parser.add_option(
      '--out-file', help='Name of the JSON file to write a task summary to')
  parser.add_option(
      '--swarming-server', help='Swarming server to send data back')
  parser.add_option(
      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')
  parser.add_option('--start', type='float', help='Time this task was started')
  parser.add_option(
      '--min-free-space', type='int',
      help='Value to send down to run_isolated')

  options, args = parser.parse_args(args)
  if not options.in_file or not options.out_file or args:
    parser.error('task_runner is meant to be used by swarming_bot.')

  on_error.report_on_exception_exit(options.swarming_server)

  logging.info('starting')
  remote = xsrf_client.XsrfRemote(options.swarming_server)                    

  now = monotonic_time()
  if options.start > now:
    options.start = now

  try:
    load_and_run(
        options.in_file, remote, options.cost_usd_hour, options.start,                    
        options.out_file, options.min_free_space)                    
    return 0
  finally:
    logging.info('quitting')



# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Auth management UI handlers."""

import functools
import json
import os
import re
import webapp2

from components import template
from components import utils

from . import acl
from . import rest_api

from .. import api
from .. import change_log
from .. import handler
from .. import model
from .. import replication


# templates/.
TEMPLATES_DIR = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), 'templates')


# Global static configuration set in 'configure_ui'.
_ui_app_name = 'Unknown'
_ui_data_callback = None
_ui_navbar_tabs = ()


def configure_ui(app_name, ui_tabs=None, ui_data_callback=None):
  """Modifies global configuration of Auth UI.

  Args:
    app_name: name of the service (visible in page headers, titles, etc.)
    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or
        None to show the standard set of tabs.
    ui_data_callback: an argumentless callable that returns a dict with
        additional data to return to authenticated users. It can be used by
        server and client side code to render templates. Used by auth_service.
  """
  global _ui_app_name
  global _ui_data_callback
  global _ui_navbar_tabs
  _ui_app_name = app_name
  _ui_data_callback = ui_data_callback
  if ui_tabs is not None:
    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)
    _ui_navbar_tabs = tuple(ui_tabs)
  template.bootstrap({'auth': TEMPLATES_DIR})


def get_ui_routes():
  """Returns a list of routes with auth UI handlers."""
  # Routes for registered navbar tabs.
  routes = []
  for cls in _ui_navbar_tabs:                    
    routes.extend(cls.get_webapp2_routes())                    
  # Routes for everything else.
  routes.extend([                    
    webapp2.Route(r'/auth', MainHandler),                    
    webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),                    
    webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),                    
    webapp2.Route(r'/auth/link', LinkToPrimaryHandler),                    
  ])                    
  return routes


def forbid_ui_on_replica(method):
  """Decorator for methods that are not allowed to be called on Replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 405 "Method Not Allowed".
  """
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      self.abort(
          405,
          detail='Not allowed on a replica, see primary at %s' % primary_url)
    return method(self, *args, **kwargs)
  return wrapper


def redirect_ui_on_replica(method):
  """Decorator for methods that redirect to Primary when called on replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 302 redirect to corresponding method on Primary.
  """
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    assert self.request.method == 'GET'
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      protocol = 'http://' if utils.is_local_dev_server() else 'https://'
      assert primary_url and primary_url.startswith(protocol), primary_url
      assert self.request.path_qs.startswith('/'), self.request.path_qs
      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)
    return method(self, *args, **kwargs)
  return wrapper


################################################################################
## Admin routes. The use cookies and GAE's "is_current_user_admin" for authn.


class AdminPageHandler(handler.AuthenticatingHandler):
  """Base class for handlers involved in bootstrap processes."""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  @classmethod
  def get_auth_methods(cls, conf):
    # This method sets 'is_superuser' bit for GAE-level admins.
    return [handler.gae_cookie_authentication]

  def reply(self, path, env=None, status=200):
    """Render template |path| to response using given environment.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """
    full_env = {
      'app_name': _ui_app_name,
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html
      'xsrf_token': self.generate_xsrf_token(),
    }
    full_env.update(env or {})
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """Shows 'Access denied' page."""
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """Redirects to login or shows 'Access Denied' page."""
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=403)


class BootstrapHandler(AdminPageHandler):
  """Creates Administrators group (if necessary) and adds current caller to it.

  Requires Appengine level Admin access for its handlers, since Administrators
  group may not exist yet.

  Used during bootstrap of a new service instance.
  """

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'return_url': self.request.get('r') or '',
    }
    self.reply('auth/admin/bootstrap.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    added = model.bootstrap_group(
        model.ADMIN_GROUP, [api.get_current_identity()],
        'Users that can manage groups')
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'added': added,
      'return_url': self.request.get('return_url') or '',
    }
    self.reply('auth/admin/bootstrap_done.html', env)


class BootstrapOAuthHandler(AdminPageHandler):
  """Page to set OAuth2 client ID used by the main web UI.

  Requires Appengine level Admin access for its handlers, since without client
  ID there's no UI yet to configure Administrators group.

  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is
  also available after the service is linked to some primary Auth service.
  """

  @api.require(api.is_superuser)
  def get(self):
    self.show_page(web_client_id=api.get_web_client_id_uncached())

  @api.require(api.is_superuser)
  def post(self):
    web_client_id = self.request.POST['web_client_id']
    api.set_web_client_id(web_client_id)
    self.show_page(web_client_id=web_client_id, saved=True)

  def show_page(self, web_client_id, saved=False):
    env = {
      'page_title': 'OAuth2 web client ID',
      'web_client_id': web_client_id or '',
      'saved': saved,
    }
    self.reply('auth/admin/bootstrap_oauth.html', env)


class LinkToPrimaryHandler(AdminPageHandler):
  """A page with confirmation of Primary <-> Replica linking request.

  URL to that page is generated by a Primary service.
  """

  def decode_link_ticket(self):
    """Extracts ServiceLinkTicket from 't' GET parameter."""
    try:
      return replication.decode_link_ticket(
          self.request.get('t').encode('ascii'))
    except (KeyError, ValueError):
      self.abort(400)
      return

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    ticket = self.decode_link_ticket()
    env = {
      'generated_by': ticket.generated_by,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
    }
    self.reply('auth/admin/linking.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    ticket = self.decode_link_ticket()
    success = True
    error_msg = None
    try:
      replication.become_replica(ticket, api.get_current_identity())
    except replication.ProtocolError as exc:
      success = False
      error_msg = exc.message
    env = {
      'error_msg': error_msg,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
      'success': success,
    }
    self.reply('auth/admin/linking_done.html', env)


################################################################################
## Web UI routes.

# TODO(vadimsh): Switch them to use OAuth for authentication.


class UIHandler(handler.AuthenticatingHandler):
  """Renders Jinja templates extending base.html."""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  def reply(self, path, env=None, status=200):
    """Renders template |path| to the HTTP response using given environment.

    Optional keys from |env| that base.html uses:
      css_file: URL to a file with page specific styles, relative to site root.
      js_file: URL to a file with page specific Javascript code, relative to
          site root. File should define global object named same as a filename,
          i.e. '/auth/static/js/api.js' should define global object 'api' that
          incapsulates functionality implemented in the module.
      navbar_tab_id: id of a navbar tab to highlight.
      page_title: title of an HTML page.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """
    env = (env or {}).copy()
    env.setdefault('css_file', None)
    env.setdefault('js_file', None)
    env.setdefault('navbar_tab_id', None)
    env.setdefault('page_title', 'Untitled')

    # This goes to both Jinja2 env and Javascript config object.
    user = self.get_current_user()
    common = {
      'account_picture': user.picture() if user else None,
      'auth_service_config_locked': False, # overridden in auth_service
      'is_admin': api.is_admin(),
      'login_url': self.create_login_url(self.request.url),
      'logout_url': self.create_logout_url('/'),
      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,
      'xsrf_token': self.generate_xsrf_token(),
    }
    if _ui_data_callback:
      common.update(_ui_data_callback())

    # Name of Javascript module with page code.
    js_module_name = None
    if env['js_file']:
      assert env['js_file'].endswith('.js')
      js_module_name = os.path.basename(env['js_file'])[:-3]                    

    # This will be accessible from Javascript as global 'config' variable.
    js_config = {
      'identity': api.get_current_identity().to_bytes(),
    }
    js_config.update(common)

    # Jinja2 environment to use to render a template.
    full_env = {
      'app_name': _ui_app_name,
      'app_revision_url': utils.get_app_revision_url(),
      'app_version': utils.get_app_version(),
      'config': json.dumps(js_config),
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'js_module_name': js_module_name,
      'navbar': [
        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)
        for cls in _ui_navbar_tabs
        if cls.is_visible()
      ],
    }
    full_env.update(common)
    full_env.update(env)

    # Render it.
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """Shows 'Access denied' page."""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """Redirects to login or shows 'Access Denied' page."""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=403)


class MainHandler(UIHandler):
  """Redirects to first navbar tab."""
  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    assert _ui_navbar_tabs
    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)


class UINavbarTabHandler(UIHandler):
  """Handler for a navbar tab page."""
  # List of routes to register, default is [navbar_tab_url].
  routes = []
  # URL to the tab (relative to site root).
  navbar_tab_url = None
  # ID of the tab, will be used in DOM.
  navbar_tab_id = None
  # Title of the tab, will be used in tab title and page title.
  navbar_tab_title = None
  # Relative URL to CSS file with tab's styles.
  css_file = None
  # Relative URL to javascript file with tab's logic.
  js_file_url = None
  # Path to a Jinja2 template with tab's markup.
  template_file = None

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self, **_params):
    """Renders page HTML to HTTP response stream."""
    env = {
      'css_file': self.css_file,
      'js_file': self.js_file_url,
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
    }
    self.reply(self.template_file, env)

  @classmethod
  def get_webapp2_routes(cls):
    routes = cls.routes or [cls.navbar_tab_url]
    return [webapp2.Route(r, cls) for r in routes]

  @classmethod
  def is_visible(cls):
    """Subclasses may return False to hide the tab from tab bar."""
    return True


################################################################################
## Default tabs.


class GroupsHandler(UINavbarTabHandler):
  """Page with Groups management."""
  routes = [
    '/auth/groups',
    '/auth/groups/<group:.*>',  # 'group' is handled by js code
  ]
  navbar_tab_url = '/auth/groups'
  navbar_tab_id = 'groups'
  navbar_tab_title = 'Groups'
  css_file = '/auth/static/css/groups.css'
  js_file_url = '/auth/static/js/groups.js'
  template_file = 'auth/groups.html'


class ChangeLogHandler(UINavbarTabHandler):
  """Page with a log of changes to some groups."""
  navbar_tab_url = '/auth/change_log'
  navbar_tab_id = 'change_log'
  navbar_tab_title = 'Change Log'
  js_file_url = '/auth/static/js/change_log.js'
  template_file = 'auth/change_log.html'

  @classmethod
  def is_visible(cls):
    # Hide 'Change Log' tab if there are no change log indexes in the datastore.
    # It happens on services that use components.auth, but do not modify
    # index.yaml. Don't try too hard to hide the log though. If user happes to
    # stumble on Change log page (e.g. by using direct URL), it handles
    # NeedIndexError gracefully (explaining how to configure indexes).
    return change_log.is_changle_log_indexed()


class OAuthConfigHandler(UINavbarTabHandler):
  """Page with OAuth configuration."""
  navbar_tab_url = '/auth/oauth_config'
  navbar_tab_id = 'oauth_config'
  navbar_tab_title = 'OAuth'
  js_file_url = '/auth/static/js/oauth_config.js'
  template_file = 'auth/oauth_config.html'


class IPWhitelistsHandler(UINavbarTabHandler):
  """Page with IP whitelists configuration."""
  navbar_tab_url = '/auth/ip_whitelists'
  navbar_tab_id = 'ip_whitelists'
  navbar_tab_title = 'IP Whitelists'
  js_file_url = '/auth/static/js/ip_whitelists.js'
  template_file = 'auth/ip_whitelists.html'


class ApiDocHandler(UINavbarTabHandler):
  """Page with API documentation extracted from rest_api.py."""
  navbar_tab_url = '/auth/api'
  navbar_tab_id = 'api'
  navbar_tab_title = 'API'

  # These can be used as 'request_type' and 'response_type' in api_doc.
  doc_types = [
    {
      'name': 'Status',
      'doc': 'Outcome of some operation.',
      'example': {'ok': True},
    },
    {
      'name': 'Self info',
      'doc': 'Information about the requester.',
      'example': {
        'identity': 'user:someone@example.com',
        'ip': '192.168.0.1',
      },
    },
    {
      'name': 'Group',
      'doc': 'Represents a group, as stored in the database.',
      'example': {
        'group': {
          'caller_can_modify': True,
          'created_by': 'user:someone@example.com',
          'created_ts': 1409250754978540,
          'description': 'Some free form description',
          'globs': ['user:*@example.com'],
          'members': ['user:a@example.com', 'anonymous:anonymous'],
          'modified_by': 'user:someone@example.com',
          'modified_ts': 1470871200558130,
          'name': 'Some group',
          'nested': ['Some nested group', 'Another nested group'],
          'owners': 'Owning group',
        },
      },
    },
    {
      'name': 'Group listing',
      'doc':
        'All groups, along with their metadata. Does not include members '
        'listings.',
      'example': {
        'groups': [
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Some free form description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Some group',
            'owners': 'Owning group',
          },
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Another description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Another group',
            'owners': 'Owning group',
          },
        ],
      },
    },
  ]

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    """Extracts API doc for registered webapp2 API routes."""
    doc_types = []

    def add_doc_type(tp):
      """Adds a request or response format definition to the documentation page.

      'tp' can either reference a globally known doc type by name
      (see ApiDocHandler.doc_types), or can itself be a dict with doc type
      definition.

      Returns the name of the doc type.
      """
      if not tp:
        return None
      # If referenced by name, try to find it among globally known types.
      if isinstance(tp, basestring):
        for d in self.doc_types:
          if d['name'] == tp:
            tp = d
            break
        else:
          return tp  # not found, return original name as is
      # Add, if not already there. Serialize the example first, since doing it
      # from Jinja is a bit more complicated.
      if not any(d['name'] == tp['name'] for d in doc_types):
        tp = tp.copy()
        tp['example'] = json.dumps(
            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)
        doc_types.append(tp)
      return tp['name']

    api_methods = []
    for route in rest_api.get_rest_api_routes():
      # Remove API parameter regexps from route template, they are mostly noise.
      simplified = re.sub(r'\:.*\>', '>', route.template)
      for doc in getattr(route.handler, 'api_doc', []):                    
        path = simplified
        if 'params' in doc:
          path += '?' + doc['params']
        api_methods.append({
          'verb': doc['verb'],
          'path': path,
          'doc': doc['doc'],
          'request_type': add_doc_type(doc.get('request_type')),
          'response_type': add_doc_type(doc.get('response_type')),
        })

    env = {
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
      'api_methods': api_methods,
      'doc_types': doc_types,
    }
    self.reply('auth/api.html', env)


# Register them as default tabs. Order is important.
_ui_navbar_tabs = (
  GroupsHandler,
  ChangeLogHandler,
  OAuthConfigHandler,
  IPWhitelistsHandler,
  ApiDocHandler,
)

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""HTTP Handlers."""

import datetime
import itertools
import json
import time

import webapp2

from google.appengine.api import app_identity
from google.appengine.datastore import datastore_query
from google.appengine.ext import ndb

from components import auth
from components import decorators
from components import template
from components import utils

from . import acl
from . import logscraper
from . import models
from . import on_error
from . import ui


# Access to a protected member XXX of a client class - pylint: disable=W0212


### Admin pages.


class RestrictedEreporter2Report(auth.AuthenticatingHandler):
  """Returns all the recent errors as a web page."""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    """Reports the errors logged and ignored.

    Arguments:
      start: epoch time to start looking at. Defaults to the messages since the
             last email.
      end: epoch time to stop looking at. Defaults to now.
      modules: comma separated modules to look at.
      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.
    """
    # TODO(maruel): Be consistent about using either epoch or human readable
    # formatted datetime.
    end = int(float(self.request.get('end', 0)) or time.time())
    start = int(
        float(self.request.get('start', 0)) or
        ui._get_default_start_time() or 0)
    modules = self.request.get('modules')
    if modules:
      modules = modules.split(',')
    tainted = bool(int(self.request.get('tainted', '1')))
    module_versions = utils.get_module_version_list(modules, tainted)
    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(
        start, end, module_versions)

    params = {
      'errors': errors,
      'errors_count': sum(len(e.events) for e in errors),
      'errors_version_count':
          len(set(itertools.chain.from_iterable(e.versions for e in errors))),
      'ignored': ignored,
      'ignored_count': sum(len(i.events) for i in ignored),
      'ignored_version_count':
          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),
      'xsrf_token': self.generate_xsrf_token(),
    }
    params.update(ui._get_template_env(start, end, module_versions))
    self.response.write(template.render('ereporter2/requests.html', params))


class RestrictedEreporter2Request(auth.AuthenticatingHandler):
  """Dumps information about single logged request."""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, request_id):
    data = logscraper._log_request_id(request_id)
    if not data:
      self.abort(404, detail='Request id was not found.')
    self.response.write(
        template.render('ereporter2/request.html', {'request': data}))


class RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):
  """Dumps information about reported client side errors."""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    limit = int(self.request.get('limit', 100))
    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))
    errors_found, cursor, more = models.Error.query().order(
        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)
    params = {
      'cursor': cursor.urlsafe() if cursor and more else None,
      'errors': errors_found,
      'limit': limit,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/errors.html', params))


class RestrictedEreporter2Error(auth.AuthenticatingHandler):
  """Dumps information about reported client side errors."""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, error_id):
    error = models.Error.get_by_id(int(error_id))
    if not error:
      self.abort(404, 'Error not found')
    params = {
      'error': error,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/error.html', params))


class RestrictedEreporter2Silence(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    # Due to historical reasons where created_ts had indexed=False,, do not use
    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all
    # objects have been updated.
    items = models.ErrorReportingMonitoring.query().fetch()
    items.sort(key=lambda x: x.created_ts)
    params = {
      'silenced': items,
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.out.write(template.render('ereporter2/silence.html', params))

  @auth.require(acl.is_ereporter2_editor)
  def post(self):
    to_delete = self.request.get('to_delete')
    if to_delete:
      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()
    else:
      mute_type = self.request.get('mute_type')
      error = None
      if mute_type in ('exception_type', 'signature'):
        error = self.request.get(mute_type)
      if not error:
        self.abort(400)
      silenced = self.request.get('silenced')
      silenced_until = self.request.get('silenced_until')
      if silenced_until == 'T':
        silenced_until = ''
      threshold = self.request.get('threshold')
      key = models.ErrorReportingMonitoring.error_to_key(error)
      if not silenced and not silenced_until and not threshold:
        key.delete()
      else:
        item = models.ErrorReportingMonitoring(key=key, error=error)
        if silenced:
          item.silenced = True
        if silenced_until:
          item.silenced_until = datetime.datetime.strptime(
              silenced_until, '%Y-%m-%dT%H:%M')
        if threshold:
          item.threshold = int(threshold)
        item.put()

    self.get()


### Cron jobs.


class CronEreporter2Mail(webapp2.RequestHandler):
  """Generate and emails an exception report."""
  @decorators.require_cronjob
  def get(self):
    """Sends email(s) containing the errors logged."""
    # Do not use self.request.host_url because it will be http:// and will point
    # to the backend, with an host format that breaks the SSL certificate.
    # TODO(maruel): On the other hand, Google Apps instances are not hosted on
    # appspot.com.
    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()
    request_id_url = host_url + '/restricted/ereporter2/request/'
    report_url = host_url + '/restricted/ereporter2/report'
    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())
    result = ui._generate_and_email_report(
        utils.get_module_version_list(None, False),
        recipients,
        request_id_url,
        report_url,
        {})
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    if result:
      self.response.write('Success.')
    else:
      # Do not HTTP 500 since we do not want it to be retried.
      self.response.write('Failed.')


class CronEreporter2Cleanup(webapp2.RequestHandler):
  """Deletes old error reports."""
  @decorators.require_cronjob
  def get(self):
    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE
    items = models.Error.query(
        models.Error.created_ts < old_cutoff,
        default_options=ndb.QueryOptions(keys_only=True))
    out = len(ndb.delete_multi(items))
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write(str(out))


### Public API.


class OnErrorHandler(auth.AuthenticatingHandler):
  """Adds an error report.

  This one is open so errors like authentication reports are logged in too.
  This means we could get spammed a lot about it. Implement DDoS protection by
  rate limiting once a kid figures out.
  """
  xsrf_token_enforce_on = ()

  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be
  # factored out.
  def parse_body(self):
    """Parse JSON body and verifies it's a dict."""
    expected = ('application/json', 'application/json; charset=utf-8')
    if self.request.headers.get('Content-Type').lower() not in expected:
      msg = 'Expecting JSON body with content type \'application/json\''
      self.abort(400, msg)
    try:
      body = json.loads(self.request.body)
      if not isinstance(body, dict):
        raise ValueError()
    except ValueError:
      self.abort(400, 'Not a valid json dict body')
    return body

  @auth.public
  def post(self):
    body = self.parse_body()
    version = body.get('v')
    # Do not enforce version for now, just assert it is present.
    if not version:
      self.abort(400, 'Missing version')

    report = body.get('r')
    if not report:
      self.abort(400, 'Missing report')

    kwargs = dict(
        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))
    report_id = on_error.log_request(self.request, add_params=False, **kwargs)
    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'
    body = {
      'id': report_id,
      'url':
          '%s/restricted/ereporter2/errors/%d' %
          (self.request.host_url, report_id),
    }
    self.response.write(utils.encode_to_json(body))


def get_frontend_routes():
  return [
    webapp2.Route(                    
        r'/restricted/ereporter2/errors',
        RestrictedEreporter2ErrorsList),
    webapp2.Route(                    
        r'/restricted/ereporter2/errors/<error_id:\d+>',
        RestrictedEreporter2Error),
    webapp2.Route(                    
        r'/restricted/ereporter2/report',
        RestrictedEreporter2Report),
    webapp2.Route(                    
        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',
        RestrictedEreporter2Request),
    webapp2.Route(                    
        r'/restricted/ereporter2/silence',
        RestrictedEreporter2Silence),

    # Public API.
    webapp2.Route(                    
      '/ereporter2/api/v1/on_error', OnErrorHandler),                    
  ]


def get_backend_routes():
  # This requires a cron job to this URL.
  return [
    webapp2.Route(                    
        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),
    webapp2.Route(                    
        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),
  ]

# Copyright 2012 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""This module defines Isolate Server frontend url handlers."""

import collections
import datetime
import json
import logging

import webapp2

import cloudstorage
from google.appengine.api import modules

import acl
import config
import gcs
import handlers_endpoints_v1
import mapreduce_jobs
import model
import stats
import template
from components import auth
from components import stats_framework
from components import stats_framework_gviz
from components import utils
from gviz import gviz_api


# GViz data description.
_GVIZ_DESCRIPTION = {
  'failures': ('number', 'Failures'),
  'requests': ('number', 'Total'),
  'other_requests': ('number', 'Other'),
  'uploads': ('number', 'Uploads'),
  'uploads_bytes': ('number', 'Uploaded'),
  'downloads': ('number', 'Downloads'),
  'downloads_bytes': ('number', 'Downloaded'),
  'contains_requests': ('number', 'Lookups'),
  'contains_lookups': ('number', 'Items looked up'),
}

# Warning: modifying the order here requires updating templates/stats.html.
_GVIZ_COLUMNS_ORDER = (
  'key',
  'requests',
  'other_requests',
  'failures',
  'uploads',
  'downloads',
  'contains_requests',
  'uploads_bytes',
  'downloads_bytes',
  'contains_lookups',
)

_ISOLATED_ROOT_MEMBERS = (
  'algo',
  'command',
  'files',
  'includes',
  'read_only',
  'relative_cwd',
  'version',
)


### Restricted handlers


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    self.common(None)

  @staticmethod
  def cast_to_type(param_name, value):
    def to_bool(value):
      if type(value) is bool:
        return value
      return {'True': True, 'False': False}.get(value, False)

    cast = {
        'enable_ts_monitoring': to_bool,
    }.get(param_name, str)
    return cast(value)

  @auth.require(auth.is_admin)
  def post(self):
    # Convert MultiDict into a dict.
    params = {
      k: self.cast_to_type(k, self.request.params.getone(k))
      for k in self.request.params
      if k not in ('keyid', 'xsrf_token')
    }
    cfg = config.settings(fresh=True)
    keyid = int(self.request.get('keyid', '0'))
    if cfg.key.integer_id() != keyid:
      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))
      return
    cfg.populate(**params)
    try:
      # Ensure key is correct, it's easy to make a mistake when creating it.
      gcs.URLSigner.load_private_key(cfg.gs_private_key)
    except Exception as exc:
      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)
      self.response.write('Bad private key: %s' % exc)
      return
    cfg.store(updated_by=auth.get_current_identity().to_bytes())
    self.common('Settings updated')

  def common(self, note):
    params = config.settings_info()
    params.update({
        'note': note,
        'path': self.request.path,
        'xsrf_token': self.generate_xsrf_token(),
    })
    self.response.write(
        template.render('isolate/restricted_config.html', params))


class RestrictedPurgeHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    params = {
      'digest': '',
      'message': '',
      'namespace': '',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('isolate/restricted_purge.html', params))

  @auth.require(auth.is_admin)
  def post(self):
    namespace = self.request.get('namespace')
    digest = self.request.get('digest')
    params = {
      'digest': digest,
      'message': '',
      'namespace': namespace,
      'xsrf_token': self.generate_xsrf_token(),
    }
    try:
      key = model.get_entry_key(namespace, digest)
    except ValueError as e:
      params['message'] = 'Invalid entry: %s' % e
      key = None
    if key:
      model.delete_entry_and_gs_entry([key])
      params['message'] = 'Done'
    self.response.write(
        template.render('isolate/restricted_purge.html', params))


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """

  @auth.require(auth.is_admin)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    # Do not use 'backend' module when running from dev appserver. Mapreduce
    # generates URLs that are incompatible with dev appserver URL routing when
    # using custom modules.
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=not utils.is_local_dev_server())
    # New tasks should show up on the status page.
    if success:
      self.redirect('/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Non-restricted handlers


class BrowseHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    # Support 'hash' for compatibility with old links. To remove eventually.
    digest = self.request.get('digest', '') or self.request.get('hash', '')
    save_as = self.request.get('as', '')
    params = {
      u'as': unicode(save_as),
      u'digest': unicode(digest),
      u'namespace': unicode(namespace),
    }
    # Check for existence of element, so we can 400/404
    if digest and namespace:
      try:
        model.get_content(namespace, digest)
      except ValueError:
        self.abort(400, 'Invalid key')
      except LookupError:
        self.abort(404, 'Unable to retrieve the entry')
    self.response.write(template.render('isolate/browse.html', params))

  def get_content_security_policy(self):
    csp = super(BrowseHandler, self).get_content_security_policy()
    csp.setdefault('child-src', []).append("'self'")
    return csp


class ContentHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    digest = self.request.get('digest', '')
    content = None
    if not digest:
      self.abort(400, 'Missing digest')
    if not namespace:
      self.abort(400, 'Missing namespace')

    try:
      raw_data, entity = model.get_content(namespace, digest)
    except ValueError:
      self.abort(400, 'Invalid key')
    except LookupError:
      self.abort(404, 'Unable to retrieve the entry')

    logging.info('%s', entity)
    if not raw_data:
      try:
        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())
        content = ''.join(model.expand_content(namespace, stream))
      except cloudstorage.NotFoundError:
        logging.error('Entity in DB but not in GCS: deleting entity in DB')
        entity.key.delete()
        self.abort(404, 'Unable to retrieve the file from GCS')
    else:
      content = ''.join(model.expand_content(namespace, [raw_data]))

    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    # We delete Content-Type before storing to it to avoid having two (yes,
    # two) Content-Type headers.
    del self.response.headers['Content-Type']

    # Apparently, setting the content type to text/plain encourages the
    # browser (Chrome, at least) to sniff the mime type and display
    # things like images.  Images are autowrapped in <img> and text is
    # wrapped in <pre>.
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'

    # App Engine puts a limit of 33554432 bytes on a request, which includes
    # headers. Headers are ~150 bytes.  If the content + headers might
    # exceed that limit, we give the user an option to workround getting
    # their file.
    if len(content) > 33554000:
      host = modules.get_hostname(module='default', version='default')
      # host is something like default.default.myisolateserver.appspot.com
      host = host.replace('default.default.','')
      sizeInMib = len(content) / (1024.0 * 1024.0)
      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'
      ' App Engine limit.\nTo work around this, run the following command:\n'
      '    python isolateserver.py download -I %s --namespace %s -f %s %s'
      % (sizeInMib, host, namespace, digest, digest))
    else:
      self.response.headers['Content-Disposition'] = str(
        'filename=%s' % self.request.get('as') or digest)
      try:
        json_data = json.loads(content)
        if self._is_isolated_format(json_data):
          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
          json_data['files'] = collections.OrderedDict(
            sorted(
              json_data['files'].items(),
              key=lambda (filepath, data): filepath))
          params = {
            'namespace': namespace,
            'isolated': json_data,
          }
          content = template.render('isolate/isolated.html', params)
      except ValueError:
        pass

    self.response.write(content)

  @staticmethod
  def _is_isolated_format(json_data):
    """Checks if json_data is a valid .isolated format."""
    if not isinstance(json_data, dict):
      return False
    actual = set(json_data)
    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual


class StatsHandler(webapp2.RequestHandler):
  """Returns the statistics web page."""
  def get(self):
    """Presents nice recent statistics.

    It fetches data from the 'JSON' API.
    """
    # Preloads the data to save a complete request.
    resolution = self.request.params.get('resolution', 'hours')
    if resolution not in ('days', 'hours', 'minutes'):
      resolution = 'hours'
    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)

    description = _GVIZ_DESCRIPTION.copy()
    description.update(stats_framework_gviz.get_description_key(resolution))
    table = stats_framework.get_stats(
        stats.STATS_HANDLER, resolution, None, duration, True)
    params = {
      'duration': duration,
      'initial_data': gviz_api.DataTable(description, table).ToJSon(
          columns_order=_GVIZ_COLUMNS_ORDER),
      'now': datetime.datetime.utcnow(),
      'resolution': resolution,
    }
    self.response.write(template.render('isolate/stats.html', params))


class StatsGvizHandlerBase(webapp2.RequestHandler):
  RESOLUTION = None

  def get(self):
    description = _GVIZ_DESCRIPTION.copy()
    description.update(
        stats_framework_gviz.get_description_key(self.RESOLUTION))
    try:
      stats_framework_gviz.get_json(
          self.request,
          self.response,
          stats.STATS_HANDLER,
          self.RESOLUTION,
          description,
          _GVIZ_COLUMNS_ORDER)
    except ValueError as e:
      self.abort(400, str(e))


class StatsGvizDaysHandler(StatsGvizHandlerBase):
  RESOLUTION = 'days'


class StatsGvizHoursHandler(StatsGvizHandlerBase):
  RESOLUTION = 'hours'


class StatsGvizMinutesHandler(StatsGvizHandlerBase):
  RESOLUTION = 'minutes'


###  Public pages.


class RootHandler(auth.AuthenticatingHandler):
  """Tells the user to RTM."""

  @auth.public
  def get(self):
    params = {
      'is_admin': auth.is_admin(),
      'is_user': acl.isolate_readable(),
      'mapreduce_jobs': [],
      'user_type': acl.get_user_type(),
    }
    if auth.is_admin():
      params['mapreduce_jobs'] = [
        {'id': job_id, 'name': job_def['job_name']}
        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()
      ]
      params['xsrf_token'] = self.generate_xsrf_token()
    self.response.write(template.render('isolate/root.html', params))


class UIHandler(auth.AuthenticatingHandler):
  """Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.
  """
  @auth.public
  def get(self):
    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'isolate/public_isolate_index.html', params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    config.warmup()
    auth.warmup()
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """Blackhole any email sent."""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Administrative urls.
      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),
      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),

      # Mapreduce related urls.
      webapp2.Route(
          r'/restricted/launch_mapreduce',
          RestrictedLaunchMapReduceJob),

      # User web pages.
      webapp2.Route(r'/browse', BrowseHandler),
      webapp2.Route(r'/content', ContentHandler),
      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz
      # is just too sorry.
      #webapp2.Route(r'/stats', StatsHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),
      webapp2.Route(r'/', RootHandler),
      webapp2.Route(r'/newui', UIHandler),

      # AppEngine-specific urls:
      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),                    
      webapp2.Route(r'/_ah/warmup', WarmupHandler),                    
  ]
  routes.extend(handlers_endpoints_v1.get_routes())
  return routes


def create_application(debug):
  """Creates the url router.

  The basic layouts is as follow:
  - /restricted/.* requires being an instance administrator.
  - /stats/.* has statistics.
  """
  acl.bootstrap()
  template.bootstrap()
  return webapp2.WSGIApplication(get_routes(), debug=debug)

# Copyright 2016 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Front-end UI."""

import logging
import os

import webapp2

from components import auth
from components import datastore_utils
from components import template
from components import utils

import handlers_endpoints
import models


THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class CatalogHandler(auth.AuthenticatingHandler):
  """Catalog handler."""

  @auth.require(auth.is_admin)
  def get(self, machine_id=None):
    params = {
        'machines': [],
        'next_page_token': None,
    }
    if machine_id:
      machine = models.CatalogMachineEntry.get_by_id(machine_id)
      if not machine:
        self.abort(404)
      params['machines'] = [machine]
    else:
      query = models.CatalogMachineEntry.query().order(
          models.CatalogMachineEntry.dimensions.hostname)
      page_token = self.request.get('page_token') or ''
      params['machines'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(
        template.render('templates/catalog.html', params=params))


class LeaseRequestHandler(auth.AuthenticatingHandler):
  """Lease request handler."""

  @auth.require(auth.is_admin)
  def get(self, lease_id=None):
    params = {
        'lease_requests': [],
        'next_page_token': None,
        'now_ts': utils.time_time(),
    }
    if lease_id:
      lease_request = models.LeaseRequest.get_by_id(lease_id)
      if not lease_request:
        self.abort(404)
      params['lease_requests'] = [lease_request]
    else:
      query = models.LeaseRequest.query().order(
          -models.LeaseRequest.last_modified_ts)
      page_token = self.request.get('page_token') or ''
      params['lease_requests'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(template.render('templates/leases.html', params=params))


class RootHandler(auth.AuthenticatingHandler):
  """Root handler."""

  @auth.public
  def get(self):
    params = {
        'is_admin': auth.is_admin(),
    }

    self.response.write(template.render('templates/root.html', params=params))


def get_routes():
  return [
      webapp2.Route('/', handler=RootHandler),
      webapp2.Route('/catalog', handler=CatalogHandler),
      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),
      webapp2.Route('/leases', handler=LeaseRequestHandler),
      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),
  ]


def create_frontend_app():
  template.bootstrap({
      'templates': os.path.join(THIS_DIR, 'templates'),
  })
  routes = get_routes()                    
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes)

# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Main entry point for Swarming service.

This file contains the URL handlers for all the Swarming service URLs,
implemented using the webapp2 framework.
"""

import collections
import os

import webapp2

import handlers_bot
import handlers_endpoints
import mapreduce_jobs
import template
from components import auth
from components import utils
from server import acl
from server import bot_code
from server import config


ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


# Helper class for displaying the sort options in html templates.
SortOptions = collections.namedtuple('SortOptions', ['key', 'name'])


### is_admin pages.


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    # Template parameters schema matches settings_info() return value.
    self.response.write(template.render(
        'swarming/restricted_config.html', config.settings_info()))


class UploadBotConfigHandler(auth.AuthenticatingHandler):
  """Stores a new bot_config.py script."""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bot_config = bot_code.get_bot_config()
    params = {
      'content': bot_config.content.decode('utf-8'),
      'path': self.request.path,
      'version': bot_config.version,
      'when': bot_config.when,
      'who': bot_config.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bot_config.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bot_config(self.request.host_url, script)
    self.get()


class UploadBootstrapHandler(auth.AuthenticatingHandler):
  """Stores a new bootstrap.py script."""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bootstrap = bot_code.get_bootstrap(self.request.host_url)
    params = {
      'content': bootstrap.content.decode('utf-8'),
      'path': self.request.path,
      'version': bootstrap.version,
      'when': bootstrap.when,
      'who': bootstrap.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bootstrap.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bootstrap(script)
    self.get()


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """

  @auth.require(acl.can_edit_config)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=False)
    # New tasks should show up on the status page.
    if success:
      self.redirect('/restricted/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Redirectors.


class BotsListHandler(auth.AuthenticatingHandler):
  """Redirects to a list of known bots."""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))

    dimensions = (
      l.strip() for l in self.request.get('dimensions', '').splitlines()
    )
    dimensions = [i for i in dimensions if i]

    new_ui_link = '/botlist?l=%d' % limit
    if dimensions:
      new_ui_link += '&f=' + '&f='.join(dimensions)

    self.redirect(new_ui_link)


class BotHandler(auth.AuthenticatingHandler):
  """Redirects to a page about the bot, including last tasks and events."""

  @auth.public
  def get(self, bot_id):
    self.redirect('/bot?id=%s' % bot_id)


class TasksHandler(auth.AuthenticatingHandler):
  """Redirects to a list of all task requests."""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))
    task_tags = [
      line for line in self.request.get('task_tag', '').splitlines() if line
    ]

    new_ui_link = '/tasklist?l=%d' % limit
    if task_tags:
      new_ui_link += '&f=' + '&f='.join(task_tags)

    self.redirect(new_ui_link)


class TaskHandler(auth.AuthenticatingHandler):
  """Redirects to a page containing task request and result."""

  @auth.public
  def get(self, task_id):
    self.redirect('/task?id=%s' % task_id)


### Public pages.


class UIHandler(auth.AuthenticatingHandler):
  """Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration."""
  @auth.public
  def get(self, page):
    if not page:
      page = 'swarming'

    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'swarming/public_%s_index.html' % page, params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')

  def get_content_security_policy(self):
    # We use iframes to display pages at display_server_url_template. Need to
    # allow it in CSP.
    csp = super(UIHandler, self).get_content_security_policy()
    tmpl = config.settings().display_server_url_template
    if tmpl:
      if tmpl.startswith('/'):
        csp['child-src'].append("'self'")
      else:
        # We assume the template specifies '%s' in its last path component.
        # We strip it to get a "parent" path that we can put into CSP. Note that
        # whitelisting an entire display server domain is unnecessary wide.
        assert tmpl.startswith('https://'), tmpl
        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])
    return csp


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    auth.warmup()
    bot_code.get_swarming_bot_zip(self.request.host_url)
    utils.get_module_version_list(None, None)
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """Blackhole any email sent."""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Frontend pages. They return HTML.
      # Public pages.
      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),

      # Redirects to Polymer UI
      ('/user/tasks', TasksHandler),
      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),
      ('/restricted/bots', BotsListHandler),
      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),

      # Admin pages.
      # TODO(maruel): Get rid of them.
      ('/restricted/config', RestrictedConfigHandler),
      ('/restricted/upload/bot_config', UploadBotConfigHandler),
      ('/restricted/upload/bootstrap', UploadBootstrapHandler),

      # Mapreduce related urls.
      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),

      ('/_ah/mail/<to:.+>', EmailHandler),                    
      ('/_ah/warmup', WarmupHandler),                    
  ]
  return [webapp2.Route(*i) for i in routes]


def create_application(debug):
  routes = []
  routes.extend(get_routes())
  routes.extend(handlers_bot.get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes, debug=debug)

from __future__ import unicode_literals, print_function, division
import logging
import threading
import time
import traceback
import lxml.html
import os.path
import spynner
import selenium.webdriver
import os
from veil.utility.path import *
from veil.development.test import *
from veil.profile.web import *
from veil.frontend.web.static_file import *

LOGGER = logging.getLogger(__name__)

def start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):
    @route('POST', '/-test/stop', website=website)
    def stop_test():
        stop_browser()

    @route('POST', '/-test/fail', website=website)
    def fail_test():
        message = get_http_argument('message')
        LOGGER.error(message)
        get_executing_test().error = message

    @route('POST', '/-test/log', website=website)
    def log_from_test():
        LOGGER.info(get_http_argument('message'))

    @route('GET', '/-test/veil-test.js', website=website)
    def veil_test_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil-test.js').text()

    @route('GET', '/-test/jquery.js', website=website)
    def jquery_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery.js').text()

    @route('GET', '/-test/jquery-cookie.js', website=website)
    def jquery_cookie_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()

    @route('GET', '/-test/veil.js', website=website)
    def veil_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil.js').text()

    page_interactions = list(reversed(page_interactions))
    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))
    http_server = start_test_website(website)
    domain = get_website_option(website, 'domain')
    if domain:
        url = 'http://{}{}'.format(domain, path)
    else:
        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)
    threading.Thread(target=lambda: execute_io_loop(timeout)).start()
    start_browser(url, browser)


def execute_io_loop(timeout):
    get_executing_test().addCleanup(require_io_loop_executor().stop)
    try:
        require_io_loop_executor().execute(timeout=timeout)
    except:
        get_executing_test().error = traceback.format_exc()
        raise


def start_browser(url, browser_type):
    if os.getenv('VEIL_REMOTE_BROWSER'):
        browser_type = 'remote'
    get_executing_test().browser_type = browser_type
    test = get_executing_test()
    test.addCleanup(stop_browser)
    if 'spynner' == browser_type:
        start_spynner_browser(url)
    elif 'chrome' == browser_type:
        start_chrome_browser(url)
    elif 'remote' == browser_type:
        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))
        start_remote_browser(url, command_executor)
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def start_spynner_browser(url, visible=False):
    test = get_executing_test()
    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)
    if visible:
        test.spynner_browser.show(maximized=False)
    try:
        test.spynner_browser.load(url)
    except:
        pass
    while test.spynner_browser:
        try:
            test.spynner_browser._events_loop()
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_chrome_browser(url):
    test = get_executing_test()
    old_cwd = os.getcwd()
    os.chdir('/tmp')
    test.webdriver = selenium.webdriver.Chrome()
    os.chdir(old_cwd)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_remote_browser(url, command_executor):
    test = get_executing_test()
    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER
    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def check_is_test_failed(test):
    message = getattr(test, 'error', None)
    if message is not None:
        stop_browser()
        test.fail(message)


def stop_browser():
    test = get_executing_test()
    if 'spynner' == test.browser_type:
        stop_spynner_browser()
    elif test.browser_type in ['chrome', 'remote']:
        stop_webdriver()
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def stop_spynner_browser():
    test = get_executing_test()
    browser = test.spynner_browser
    if browser:
        test.spynner_browser = None
        browser.close()


def stop_webdriver():
    test = get_executing_test()
    webdriver = getattr(test, 'webdriver', None)
    if webdriver:
        test.webdriver = None
        webdriver.close()


def inject_page_interaction(html, page_interactions):
    request = get_current_http_request()
    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):
        return html
    if request.path.startswith('/-test/'):
        return html
    if not page_interactions:
        return html
    fragment = lxml.html.document_fromstring(html)
    script = fragment.makeelement(
        'script', attrib={
            'type': 'text/javascript',
            'src': '/-test/veil-test.js'
        })
    fragment.find('body').append(script)
    script = fragment.makeelement(
        'script', attrib={'type': 'text/javascript'})
    script.text =\
    """
    $(document).ready(function() {
        %s
    });
    """ % page_interactions.pop()
    fragment.find('body').append(script)
    return open_closed_tags(lxml.html.tostring(fragment, method='xml'))                    

from __future__ import unicode_literals, print_function, division
import logging
import argparse
from jinja2.loaders import FileSystemLoader
from veil.frontend.template import *
from veil.frontend.cli import *
from veil.environment import *
from veil.environment.setting import *
from .tornado import *
from .locale import *
from .routing import  *
from .static_file import *
from .xsrf import *
from .web_installer import load_website_config

LOGGER = logging.getLogger(__name__)

additional_context_managers = {}

def register_website_context_manager(website, context_manager):
    additional_context_managers.setdefault(website.lower(), []).append(context_manager)


@script('up')
def bring_up_website(*argv):
    argument_parser = argparse.ArgumentParser('Website')
    argument_parser.add_argument('purpose', help='which website to bring up')
    argument_parser.add_argument('--dependency', type=str,
        help='where @periodic_job is defined', nargs='+', dest='dependencies')
    args = argument_parser.parse_args(argv)
    for dependency in args.dependencies:
        __import__(dependency)
    start_website(args.purpose)


def start_test_website(purpose, **kwargs):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, **kwargs)                    
    http_server = start_test_http_server(
        http_handler,
        host=config.host,
        port=config.port)
    http_server.purpose = purpose
    return http_server


def start_website(purpose):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config)
    io_loop = IOLoop.instance()
    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))
    start_http_server(
        http_handler, io_loop=io_loop,
        host=config.host, port=config.port)


def create_website_http_handler(purpose, config):
    locale_provider = lambda: None
    if config.secure_cookie_salt:
        set_secure_cookie_salt(config.secure_cookie_salt)
    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')
    set_external_static_files_directory(VEIL_HOME / 'static')
    master_template_directory = config.master_template_directory
    if master_template_directory:
        register_template_loader('master', FileSystemLoader(master_template_directory))
    website_context_managers = [create_stack_context(install_translations, locale_provider)]
    if config.prevents_xsrf:
        register_page_post_processor(set_xsrf_cookie_for_page)
        website_context_managers.append(prevent_xsrf)
    if config.recalculates_static_file_hash:
        website_context_managers.append(clear_static_file_hashes)
    if config.clears_template_cache:
        website_context_managers.append(clear_template_caches)
    website_context_managers.extend(additional_context_managers.get(purpose, []))
    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)

import veil_component

with veil_component.init_component(__name__):
    from .website_launcher import start_website
    from .website_launcher import start_test_website
    from .website_launcher import register_website_context_manager
    from .website_installer import get_website_url_prefix
    from .website_installer import website_resource
    from .client import start_website_and_client
    from .routing import route
    from .routing import route_for
    from .routing import async_route
    from .routing import public_route
    from .routing import is_public_route
    from .routing import RoutingHTTPHandler
    from .routing import get_routes
    from .routing import register_page_post_processor
    from .routing import TAG_NO_POST_PROCESS
    from .routing import publish_new_website_event
    from .static_file import static_url
    from .static_file import process_script_elements
    from .tornado import get_current_http_context
    from .tornado import get_current_http_request
    from .tornado import get_current_http_response
    from .tornado import start_http_server
    from .tornado import start_test_http_server
    from .tornado import create_stack_context
    from .tornado import set_http_status_code
    from .tornado import HTTPError
    from .tornado import end_http_request_processing
    from .tornado import get_secure_cookie
    from .tornado import set_secure_cookie
    from .tornado import get_cookies
    from .tornado import get_cookie
    from .tornado import clear_cookies
    from .tornado import clear_cookie
    from .tornado import set_cookie
    from .tornado import redirect_to
    from .tornado import get_http_argument
    from .tornado import get_http_arguments
    from .tornado import get_http_file
    from .tornado import get_http_files
    from .tornado import delete_http_argument
    from .tornado import clear_http_arguments
    from .tornado import require_io_loop_executor
    from .xsrf import xsrf_token

    __all__ = [
        # from website
        start_website.__name__,
        start_test_website.__name__,
        register_website_context_manager.__name__,
        # from website_installer
        get_website_url_prefix.__name__,
        website_resource.__name__,
        # from client
        start_website_and_client.__name__,
        # from routing
        route.__name__,
        route_for.__name__,
        async_route.__name__,
        public_route.__name__,
        is_public_route.__name__,
        RoutingHTTPHandler.__name__,
        get_routes.__name__,
        register_page_post_processor.__name__,
        'TAG_NO_POST_PROCESS',
        publish_new_website_event.__name__,
        # from static_file
        static_url.__name__,
        process_script_elements.__name__,
        # from tornado
        get_current_http_context.__name__,
        get_current_http_request.__name__,
        get_current_http_response.__name__,
        start_http_server.__name__,
        start_test_http_server.__name__,
        create_stack_context.__name__,
        set_http_status_code.__name__,
        HTTPError.__name__,
        end_http_request_processing.__name__,
        get_secure_cookie.__name__,
        set_secure_cookie.__name__,
        get_cookies.__name__,
        get_cookie.__name__,
        clear_cookies.__name__,
        clear_cookie.__name__,
        set_cookie.__name__,
        redirect_to.__name__,
        get_http_argument.__name__,
        get_http_arguments.__name__,
        get_http_file.__name__,
        get_http_files.__name__,
        delete_http_argument.__name__,
        clear_http_arguments.__name__,
        require_io_loop_executor.__name__,
        # from xsrf
        xsrf_token.__name__                    
    ]

import veil_component

with veil_component.init_component(__name__):
    from .xsrf import xsrf_token
    from .xsrf import prevent_xsrf
    from .xsrf import set_xsrf_cookie_for_page

    __all__ = [
        # from xsrf
        xsrf_token.__name__,
        prevent_xsrf.__name__,
        set_xsrf_cookie_for_page.__name__                    
    ]

from __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from tornado.escape import xhtml_escape
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *

LOGGER = getLogger(__name__)

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        request.is_new_xsrf_token = False
        if not token:
            request.is_new_xsrf_token = True
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {
                'token': token,
                'method': request.method,
                'path': request.path
            })
        request._xsrf_token = token
    if 'GET' != request.method.upper():                    
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {
                'request': request,
                'expected_token': expected_token,
                'token': token
            })
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


def set_xsrf_cookie_for_page(route_handler, data):
    if get_current_http_request().is_new_xsrf_token:
        if data and '<html' in data.lower():
            # only set to page to avoid concurrent http request issue
            set_cookie(name='_xsrf', value=xsrf_token())
    return data


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type="hidden" name="_xsrf" value="{}"/>'.format(xhtml_escape(xsrf_token())))

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS-schoolcms-init."""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

# version is a human-readable version number.

# version_info is a four-tuple for programmatic comparison. The first
# three numbers are the components of the version number.  The fourth
# is zero for an official release, positive for a development branch,
# or negative for a release candidate or beta (after the base version
# number has been incremented)
version = "0.0.3dev2"                    
version_info = (0, 0, 3, 12)                    

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS-handler-init.

route.
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

from ..import version as system_version
from ..db import SQL_Session, User, GroupList, Login_Session
from ..util  import webassets_react

import functools
import os
from webassets import Environment, Bundle

import tornado.web
from tornado.escape import json_encode
from tornado.options import options


class BaseHandler(tornado.web.RequestHandler):
    def initialize(self, is_api=True):
        self.is_api = is_api

        self.assets = Environment(                    
                os.path.join(os.path.dirname(__file__), '../static'),'/static')                    
        css_all = Bundle(                    
                'css/bootstrap.min.css',                    
                'css/material.min.css',                    
                Bundle('css/schoolcms.css','css/dropdown.css', filters='cssmin'),                    
                'outdatedbrowser/outdatedbrowser.min.css',                    
                output='dict/plugin.min.css')                    
        js_all = Bundle(                    
                Bundle(
                    'outdatedbrowser/outdatedbrowser.min.js',                    
                    'react-0.13.2/react-with-addons.min.js',                    
                    'js/jquery-2.1.3.min.js',                    
                    'js/bootstrap.min.js',                    
                    'js/react-bootstrap.min.js',                    
                    'js/react-mini-router.min.js',                    
                    'js/marked.min.js',                    
                    'js/material.min.js',                    
                    'js/isMobile.min.js',                    
                    'js/moment-with-locales.min.js',                    
                    'js/dropdown.js',filters='jsmin'),                    
                Bundle(
                    'schoolcms/init.jsx',                    
                    'schoolcms/mixin/*.jsx',                    
                    'schoolcms/component/*.jsx',                    
                    'schoolcms/page/*.jsx', filters=('react','jsmin')),                    
                output='dict/plugin.min.js')                    
        self.assets.register('css_all', css_all)                    
        self.assets.register('js_all', js_all)                    

    def prepare(self):
        """This method is executed at the beginning of each request.

        """
        self.sql_session = SQL_Session()

    def on_finish(self):
        """Finish this response, ending the HTTP request 
        and properly close the database.
        """
        try:
            self.sql_session.close()
        except AttributeError:
            pass

    def get_current_user(self):
        """Gets the current user logged in from the cookies
        If a valid cookie is retrieved, return a User object.
        Otherwise, return None.
        """
        session_key = self.get_secure_cookie('session_key')
        if not session_key:
            return None
        login_session = Login_Session.get_by_key(session_key, self.sql_session)
        if not login_session:
            return None
        return User.by_key(login_session.userkey, self.sql_session).scalar()

    def get_template_namespace(self):
        _ = super(BaseHandler, self).get_template_namespace()
        _['css_urls'] = self.assets['css_all'].urls()
        _['js_urls'] = self.assets['js_all'].urls()
        _['system_name'] = options.system_name
        _['SERVER_DEBUG'] = options.server_debug
        _['ip'] = self.request.remote_ip
        _['system_version'] = system_version
        _['_host'] = self.request.host
        _['_protocol'] = self.request.protocol
        
        if self.current_user:
            groups = GroupList.get_user_groups(self.current_user.key, self.sql_session)
        else:
            groups = []
        _['current_user'] = self.current_user.to_dict() if self.current_user else None
        _['current_groups'] = groups
        return _

    def page_render(self, page_json, template='app.html', **kw):
        if self.is_api:
            self.write(page_json)
        else:
            self.render(template, page_json=page_json, **kw)

    @property
    def HTTPError(self):
        return tornado.web.HTTPError
    
    def write_error(self, error, **kargs):
        self.render('app.html', page_json={})

    @staticmethod
    def authenticated(method):
        return tornado.web.authenticated(method)

    @staticmethod
    def check_is_admin_user(method):
        def wrapper(self, *args, **kwargs):
            if not self.current_user or not self.current_user.admin:
                raise self.HTTPError(403)
            return method(self, *args, **kwargs)
        return wrapper

    @staticmethod
    def check_is_group_user(group):
        def decorator(method):
            def wrapper(self, *args, **kwargs):
                if not self.is_group_user(group):
                    raise self.HTTPError(403)
                return method(self, *args, **kwargs)
            return wrapper
        return decorator

    def is_group_user(self, group):
        if not self.current_user:
            return False
        if self.current_user.admin:
            return True
        group = GroupList.check(self.current_user.key,
                                group, self.sql_session)
        return bool(group)


class AppHandler(BaseHandler):
    def get(self,  *a, **kwargs):
        self.render('app.html', page_json={})


from .indexhandler import IndexHandler
from .announcehandler import AnnounceHandler, EditAnnHandler
from .signhandler import LoginHandler, LogoutHandler
from .userhandler import GroupHandler, UserHandler
from .filehandler import FileHandler, TempUploadHandler
from .recordhandler import RecordHandler

print(os.path.join(os.path.dirname(__file__), '../../file'))

route = [
    # (r'/', AppHandler),
    # (r'/login/?', AppHandler),
    # (r'/logout/?', AppHandler),
    (r'/announce(?:/([0-9]+))?/?', AnnounceHandler, {'is_api': False}),
    (r'/announce/edit(?:/([0-9]+))?/?', EditAnnHandler, {'is_api': False}),

    # Admin
    (r'/admin/user/?', UserHandler, {'is_api': False}),

    # API
    (r'/api/?', IndexHandler),
    (r'/api/login/?', LoginHandler),
    (r'/api/logout/?', LogoutHandler),
    (r'/api/announce(?:/([0-9]+))?/?', AnnounceHandler),
    (r'/api/announce/edit(?:/([0-9]+))?/?', EditAnnHandler),
    (r'/api/announce/record/?', RecordHandler),

    # Admin API
    (r'/api/admin/group/?', GroupHandler),
    (r'/api/admin/user/?', UserHandler),

    # Att and File
    (r'/file/(.*)', FileHandler, {"path": os.path.join(os.path.dirname(__file__), '../../file')}),
    (r'/fileupload(?:/([a-zA-Z0-9]+))?/?', TempUploadHandler),
]

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS announce handlers.

handlers.
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

from . import BaseHandler
from ..db import Announce, AnnTag, TempFileList, AttachmentList, Record, GroupList

import os
import shutil
import re
from markdown import markdown
from bs4 import BeautifulSoup
from datetime import datetime, timedelta

from sqlalchemy import desc

try:
    xrange
except NameError:
    xrange = range


def _to_int(s, default, mi=None, mx=None):
    if not s.isdigit():
        return default
    _n = int(s)
    if mi != None and _n < mi:
        return default
    if mx != None and _n > mx:
        return default
    return _n


class AnnounceHandler(BaseHandler):
    def get(self, ann_id):
        # Ann Page
        if ann_id:
            ann = Announce.by_id(ann_id, self.sql_session).scalar()
            if not ann:
                raise self.HTTPError(404)
            if ann.is_private and not self.is_group_user('Announcement Manager'):
                raise self.HTTPError(404)

            atts = AttachmentList.by_ann_id(ann_id, self.sql_session).all()

            self.ann_d = ann.to_dict()
            self.ann_d['tags'] = AnnTag.get_ann_tags(ann_id, self.sql_session)
            self.ann_d['atts'] = [att.to_dict() for att in atts]
            
            meta = {
                'title': self.ann_d['title'],
                'uri': '/announce/%s' % self.ann_d['id'],
                'content': BeautifulSoup(markdown(self.ann_d['content']), 'html.parser').text,
            }
            self.set_header('Cache-Control', 'max-age=300')
            self.page_render(self.ann_d, 'announce.html', meta=meta)

        # AnnIndex Page
        else:
            start = _to_int(self.get_argument('start', '0'), -1, 0, 10000000000000000000)
            step = _to_int(self.get_argument('step', '12'), 0, 1, 20)
            search = self.get_argument('search', '')
            group = self.get_argument('group', '')
            author = self.get_argument('author', '')
            hours = _to_int(self.get_argument('hours', ''), 0, 1, 23999999976)

            if start == -1 or step == 0:
                raise self.HTTPError(400)

            q = self.sql_session.query(Announce)
            if search:
                q = q.filter(Announce.full_text_search(search))
            else:
                q = q.order_by(Announce.created.desc())                    

            if author:
                q = q.filter(Announce.author_name == author)
            if group:
                q = q.filter(Announce.author_group_name == group)

            if hours:
                start_time = datetime.utcnow() - timedelta(hours=hours)
                q = q.filter(Announce.created >= start_time)                    

            if not self.is_group_user('Announcement Manager'):
                q = q.filter(Announce.is_private == False)

            total = q.count()
            q = q.offset(start).limit(step)
            anns = q.all()

            groups = self.sql_session.query(Announce.author_group_name).group_by(Announce.author_group_name).all()
            authors = self.sql_session.query(Announce.author_name).group_by(Announce.author_name).all()

            def _make_ann(ann):
                _d = ann.to_dict()
                del _d['content']
                _d['tags'] = AnnTag.get_ann_tags(ann.id, self.sql_session)
                return _d
            self.set_header('Cache-Control', 'max-age=300')
            self.page_render({
                    'anns' : [_make_ann(ann) for ann in anns],
                    'search' : search,
                    'start' : start,
                    'groups' : groups,
                    'authors' : authors,
                    'total' : total,
                })

    @BaseHandler.check_is_group_user('Announcement Manager')
    def delete(self, ann_id):
        if not ann_id:
            raise self.HTTPError(404)
        if not Announce.by_id(ann_id, self.sql_session).scalar():
            raise self.HTTPError(404)

        q = AttachmentList.by_ann_id(ann_id, self.sql_session)
        old_atts = q.all()
        for old_att in old_atts:
            shutil.rmtree('file/%s' % old_att.key)
        q.delete()
        Announce.by_id(ann_id, self.sql_session).delete()

        self.write({'success':True})


tag_re = re.compile(r'^[^\s,][^,]*[^\s,]$')

class EditAnnHandler(BaseHandler):
    def prepare(self):
        super(EditAnnHandler, self).prepare()
        self._ = {
            'id': '',
            'title': '',
            'content': '',
            'is_private': False,
            'group': '',
            'tmpatts': [],
            'atts': [],
            'tags': [],
            'alert': '',
        }

    @BaseHandler.check_is_group_user('Announcement Manager')
    def get(self, ann_id):
        if ann_id:
            ann = Announce.by_id(ann_id, self.sql_session).scalar()
            if not ann:
                raise self.HTTPError(404)
            self._['ann_id'] = ann_id
            self._['title'] = ann.title
            self._['content'] = ann.content
            self._['is_private'] = ann.is_private
            atts = AttachmentList.by_ann_id(ann_id, self.sql_session).all()
            self._['tags'] = AnnTag.get_ann_tags(ann_id, self.sql_session)
            self._['atts'] = [att.to_dict() for att in atts]
            if self.is_group_user(ann.author_group_name):
                self._['group'] = ann.author_group_name

        self._['user_groups'] = GroupList.get_user_groups(self.current_user.key, self.sql_session)

        self.page_render(self._)

    @BaseHandler.check_is_group_user('Announcement Manager')
    def post(self, ann_id):
        self.ann_id = ann_id if ann_id else ''
        del ann_id
        del self._['atts']
        self._['id'] = self.ann_id
        self._['title'] = self.get_argument('title', '')
        self._['content'] = self.get_argument('content', '')
        self.group = self.get_argument('group', '')
        self._['is_private'] = bool(self.get_argument('is_private', ''))
        self._['tags'] = self.get_arguments('tag')
        self.attkeys = self.get_arguments('attachment')

        # check ann and att
        if not self.check_ann():
            self._['tmpatts'] = [att.to_dict() for att in self._['tmpatts']]
            return self.write(self._)

        self._['author_name'] = self.current_user.name

        if self.ann_id:
            Announce.by_id(self.ann_id, self.sql_session).update({
                    'title' : self._['title'],
                    'content' : self._['content'],
                    'author_group_name' : self._['author_group_name'],
                    'author_name' : self._['author_name'],
                    'is_private' : self._['is_private'],
                })
            Record.add('update', self.ann_id, self.sql_session)
        else:
            new_ann = Announce(**self._)
            self.sql_session.add(new_ann)
            self.sql_session.flush()
            self.sql_session.refresh(new_ann)
            self.ann_id = new_ann.id
            Record.add('new', self.ann_id, self.sql_session)

        self.parse_att()
        self.parse_tag()

        self.sql_session.commit()
        self.write({'success': True,'id': self.ann_id})

    def check_ann(self):
        for i in xrange(len(self.attkeys)):
            if self.attkeys[i]:
                q = self.sql_session.query(TempFileList)
                q = q.filter(TempFileList.key == self.attkeys[i])
                try:
                    new_tmpatt = q.one()
                    if new_tmpatt.author_key != self.current_user.key:
                        raise ValueError('user key error!')
                    if not os.path.exists('file/tmp/%s' % new_tmpatt.key):
                        raise ValueError('att lost!')
                    self._['tmpatts'].append(new_tmpatt)
                except ValueError:
                    self._['alert'] = '!'
        if self._['alert']:
            return False

        if not self._['title']:
            self._['alert'] = ''
            return False
        elif not self._['content']:
            self._['alert'] = ''
            return False
        elif not self.group or not GroupList.check(self.current_user.key, self.group, self.sql_session):
            self._['alert'] = ''
            return False

        self._['author_group_name'] = self.group

        return True

    def parse_att(self):
        for att in self._['tmpatts']:
            os.makedirs('file/%s' % att.key)
            os.rename('file/tmp/%s' % att.key, 'file/%s/%s' % (att.key, att.filename))
            new_att = AttachmentList(key=att.key, ann_id=self.ann_id, 
                                    content_type=att.content_type, filename=att.filename)
            self.sql_session.add(new_att)
            TempFileList.by_key(att.key, self.sql_session).delete()

    def parse_tag(self):
        for i in xrange(len(self._['tags'])):
            self._['tags'][i] = self._['tags'][i][:40:]
            if not tag_re.match(self._['tags'][i]):
                del self._['tags'][i]

        old_tags = AnnTag.get_ann_tags(self.ann_id, self.sql_session)
        new_tag_set = set(self._['tags'])
        old_tag_set = set(old_tags)

        add_set = new_tag_set - old_tag_set
        delete_set = old_tag_set - new_tag_set

        for tag in add_set:
            self.sql_session.add(AnnTag(self.ann_id, tag))
        for tag in delete_set:
            AnnTag.by_tag(self.ann_id, tag, self.sql_session).delete()

# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """Secret."""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """Wraps text in minimal HTML tags."""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """Returns all the IP addressed comprised in a range."""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']                    
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),                    
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """Returns True if the provided token is valid."""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """Adds ACL to the request handler to ensure only valid users can use
  the handlers."""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message."""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """Verifies if the IP is whitelisted."""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """Verifies if the user is whitelisted."""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """Ensures the token is valid."""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name="whitelist" method="post">'
      'Domain: <input type="text" name="domain" /><br />'
      '<input type="hidden" name="token" value="%s" />'
      '<input type="submit" value="SUBMIT" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """Returns the token."""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """Adds example.com as a valid domain when testing."""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')



# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Integration with webapp2."""

# Disable 'Method could be a function.'
# pylint: disable=R0201

import functools
import json
import logging
import urllib
import webapp2

from google.appengine.api import urlfetch
from google.appengine.api import users

from components import utils

from . import api
from . import config
from . import delegation
from . import host_token
from . import ipaddr
from . import model
from . import openid
from . import tokens

# Part of public API of 'auth' component, exposed by this module.
__all__ = [
  'ApiHandler',
  'AuthenticatingHandler',
  'gae_cookie_authentication',
  'get_authenticated_routes',
  'oauth_authentication',
  'openid_cookie_authentication',
  'require_xsrf_token_request',
  'service_to_service_authentication',
]


def require_xsrf_token_request(f):
  """Use for handshaking APIs."""
  @functools.wraps(f)
  def hook(self, *args, **kwargs):
    if not self.request.headers.get('X-XSRF-Token-Request'):
      raise api.AuthorizationError('Missing required XSRF request header')
    return f(self, *args, **kwargs)
  return hook


class XSRFToken(tokens.TokenKind):
  """XSRF token parameters."""
  expiration_sec = 4 * 3600
  secret_key = api.SecretKey('xsrf_token', scope='local')
  version = 1


class AuthenticatingHandlerMetaclass(type):
  """Ensures that 'get', 'post', etc. are marked with @require or @public."""

  def __new__(mcs, name, bases, attributes):
    for method in webapp2.WSGIApplication.allowed_methods:
      func = attributes.get(method.lower())
      if func and not api.is_decorated(func):
        raise TypeError(
            'Method \'%s\' of \'%s\' is not protected by @require or @public '
            'decorator' % (method.lower(), name))
    return type.__new__(mcs, name, bases, attributes)


class AuthenticatingHandler(webapp2.RequestHandler):
  """Base class for webapp2 request handlers that use Auth system.

  Knows how to extract Identity from request data and how to initialize auth
  request context, so that get_current_identity() and is_group_member() work.

  All request handling methods (like 'get', 'post', etc) should be marked by
  either @require or @public decorators.
  """

  # Checks that all 'get', 'post', etc. are marked with @require or @public.
  __metaclass__ = AuthenticatingHandlerMetaclass

  # List of HTTP methods that trigger XSRF token validation.
  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')
  # If not None, the header to search for XSRF token.
  xsrf_token_header = 'X-XSRF-Token'
  # If not None, the request parameter (GET or POST) to search for XSRF token.
  xsrf_token_request_param = 'xsrf_token'
  # Embedded data extracted from XSRF token of current request.
  xsrf_token_data = None
  # If not None, sets X_Frame-Options on all replies.
  frame_options = 'DENY'
  # A method used to authenticate this request, see get_auth_methods().
  auth_method = None

  def dispatch(self):
    """Extracts and verifies Identity, sets up request auth context."""
    # Ensure auth component is configured before executing any code.
    conf = config.ensure_configured()
    auth_context = api.reinitialize_request_cache()

    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/
    # https://www.owasp.org/index.php/Content_Security_Policy
    # TODO(maruel): Remove 'unsafe-inline' once all inline style="foo:bar" in
    # all HTML tags were removed. Warning if seeing this post 2016, it could
    # take a while.
    # - https://www.google.com is due to Google Viz library.
    # - https://www.google-analytics.com due to Analytics.
    # - 'unsafe-eval' due to polymer.
    self.response.headers['Content-Security-Policy'] = (
        'default-src https: \'self\' \'unsafe-inline\' https://www.google.com '
        'https://www.google-analytics.com \'unsafe-eval\'')
    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.
    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security
    self.response.headers['Strict-Transport-Security'] = (
        'max-age=31536000; includeSubDomains; preload')
    # Disable frame support wholesale.
    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet
    if self.frame_options:
      self.response.headers['X-Frame-Options'] = self.frame_options

    identity = None
    for method_func in self.get_auth_methods(conf):
      try:
        identity = method_func(self.request)
        if identity:
          break
      except api.AuthenticationError as err:
        self.authentication_error(err)
        return
      except api.AuthorizationError as err:
        self.authorization_error(err)
        return
    else:
      method_func = None
    self.auth_method = method_func

    # If no authentication method is applicable, default to anonymous identity.
    identity = identity or model.Anonymous

    # XSRF token is required only if using Cookie based or IP whitelist auth.
    # A browser doesn't send Authorization: 'Bearer ...' or any other headers
    # by itself. So XSRF check is not required if header based authentication
    # is used.
    using_headers_auth = method_func in (
        oauth_authentication, service_to_service_authentication)

    # Extract caller host name from host token header, if present and valid.
    host_tok = self.request.headers.get(host_token.HTTP_HEADER)
    if host_tok:
      validated_host = host_token.validate_host_token(host_tok)
      if validated_host:
        auth_context.peer_host = validated_host

    # Verify IP is whitelisted and authenticate requests from bots.
    assert self.request.remote_addr
    ip = ipaddr.ip_from_string(self.request.remote_addr)
    auth_context.peer_ip = ip
    try:
      # 'verify_ip_whitelisted' may change identity for bots, store new one.
      auth_context.peer_identity = api.verify_ip_whitelisted(
          identity, ip, self.request.headers)
    except api.AuthorizationError as err:
      self.authorization_error(err)
      return

    # Parse delegation token, if given, to deduce end-user identity.
    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)
    if delegation_tok:
      try:
        auth_context.current_identity = delegation.check_delegation_token(
            delegation_tok, auth_context.peer_identity)
      except delegation.BadTokenError as exc:
        self.authorization_error(
            api.AuthorizationError('Bad delegation token: %s' % exc))
      except delegation.TransientError as exc:
        msg = 'Transient error while validating delegation token.\n%s' % exc
        logging.error(msg)
        self.abort(500, detail=msg)
    else:
      auth_context.current_identity = auth_context.peer_identity

    try:
      # Fail if XSRF token is required, but not provided.
      need_xsrf_token = (
          not using_headers_auth and
          self.request.method in self.xsrf_token_enforce_on)
      if need_xsrf_token and self.xsrf_token is None:
        raise api.AuthorizationError('XSRF token is missing')

      # If XSRF token is present, verify it is valid and extract its payload.
      # Do it even if XSRF token is not strictly required, since some handlers
      # use it to store session state (it is similar to a signed cookie).
      self.xsrf_token_data = {}
      if self.xsrf_token is not None:
        # This raises AuthorizationError if token is invalid.
        self.xsrf_token_data = self.verify_xsrf_token()                    

      # All other ACL checks will be performed by corresponding handlers
      # manually or via '@required' decorator. Failed ACL check raises
      # AuthorizationError.
      super(AuthenticatingHandler, self).dispatch()
    except api.AuthorizationError as err:
      self.authorization_error(err)

  @classmethod
  def get_auth_methods(cls, conf):
    """Returns an enumerable of functions to use to authenticate request.

    The handler will try to apply auth methods sequentially one by one by until
    it finds one that works.

    Each auth method is a function that accepts webapp2.Request and can finish
    with 3 outcomes:

    * Return None: authentication method is not applicable to that request
      and next method should be tried (for example cookie-based
      authentication is not applicable when there's no cookies).

    * Returns Identity associated with the request. Means authentication method
      is applicable and request authenticity is confirmed.

    * Raises AuthenticationError: authentication method is applicable, but
      request contains bad credentials or invalid token, etc. For example,
      OAuth2 token is given, but it is revoked.

    A chosen auth method function will be stored in request's auth_method field.

    Args:
      conf: components.auth GAE config, see config.py.
    """
    if conf.USE_OPENID:
      cookie_auth = openid_cookie_authentication
    else:
      cookie_auth = gae_cookie_authentication
    return oauth_authentication, cookie_auth, service_to_service_authentication

  def generate_xsrf_token(self, xsrf_token_data=None):
    """Returns new XSRF token that embeds |xsrf_token_data|.

    The token is bound to current identity and is valid only when used by same
    identity.
    """
    return XSRFToken.generate(
        [api.get_current_identity().to_bytes()], xsrf_token_data)

  @property
  def xsrf_token(self):
    """Returns XSRF token passed with the request or None if missing.

    Doesn't do any validation. Use verify_xsrf_token() instead.
    """
    token = None
    if self.xsrf_token_header:
      token = self.request.headers.get(self.xsrf_token_header)
    if not token and self.xsrf_token_request_param:
      param = self.request.get_all(self.xsrf_token_request_param)
      token = param[0] if param else None
    return token

  def verify_xsrf_token(self):
    """Grabs a token from the request, validates it and extracts embedded data.

    Current identity must be the same as one used to generate the token.

    Returns:
      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'
      method call used to generate the token.

    Raises:
      AuthorizationError if token is missing, invalid or expired.
    """
    token = self.xsrf_token
    if not token:
      raise api.AuthorizationError('XSRF token is missing')
    # Check that it was generated for the same identity.
    try:
      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])
    except tokens.InvalidTokenError as err:
      raise api.AuthorizationError(str(err))

  def authentication_error(self, error):
    """Called when authentication fails to report the error to requester.

    Authentication error means that some credentials are provided but they are
    invalid. If no credentials are provided at all, no authentication is
    attempted and current identity is just set to 'anonymous:anonymous'.

    Default behavior is to abort the request with HTTP 401 error (and human
    readable HTML body).

    Args:
      error: instance of AuthenticationError subclass.
    """
    logging.warning('Authentication error.\n%s', error)
    self.abort(401, detail=str(error))

  def authorization_error(self, error):
    """Called when authentication succeeds, but access to a resource is denied.

    Called whenever request handler raises AuthorizationError exception.
    In particular this exception is raised by method decorated with @require if
    current identity doesn't have required permission.

    Default behavior is to abort the request with HTTP 403 error (and human
    readable HTML body).

    Args:
      error: instance of AuthorizationError subclass.
    """
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort(403, detail=str(error))

  ### Wrappers around Users API or its OpenID equivalent.

  def get_current_user(self):
    """When cookie auth is used returns instance of CurrentUser or None."""
    return self._get_users_api().get_current_user(self.request)

  def is_current_user_gae_admin(self):
    """When cookie auth is used returns True if current caller is GAE admin."""
    return self._get_users_api().is_current_user_gae_admin(self.request)

  def create_login_url(self, dest_url):
    """When cookie auth is used returns URL to redirect user to login."""
    return self._get_users_api().create_login_url(self.request, dest_url)

  def create_logout_url(self, dest_url):
    """When cookie auth is used returns URL to redirect user to logout."""
    return self._get_users_api().create_logout_url(self.request, dest_url)

  def _get_users_api(self):
    """Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.

    Chooses based on what auth_method was used of what methods are available.
    """
    method = self.auth_method
    if not method:
      # Anonymous request -> pick first method that supports API.
      for method in self.get_auth_methods(config.ensure_configured()):
        if method in _METHOD_TO_USERS_API:
          break
      else:
        raise NotImplementedError('No methods support UsersAPI')
    elif method not in _METHOD_TO_USERS_API:
      raise NotImplementedError(
          '%s doesn\'t support UsersAPI' % method.__name__)
    return _METHOD_TO_USERS_API[method]


class ApiHandler(AuthenticatingHandler):
  """Parses JSON request body to a dict, serializes response to JSON."""
  CONTENT_TYPE_BASE = 'application/json'
  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'
  _json_body = None
  # Clickjacking not applicable to APIs.
  frame_options = None

  def authentication_error(self, error):
    logging.warning('Authentication error.\n%s', error)
    self.abort_with_error(401, text=str(error))

  def authorization_error(self, error):
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort_with_error(403, text=str(error))

  def send_response(self, response, http_code=200, headers=None):
    """Sends successful reply and continues execution."""
    self.response.set_status(http_code)
    self.response.headers.update(headers or {})
    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL
    self.response.write(json.dumps(response))

  def abort_with_error(self, http_code, **kwargs):
    """Sends error reply and stops execution."""
    self.abort(
        http_code,
        json=kwargs,
        headers={'Content-Type': self.CONTENT_TYPE_FULL})

  def parse_body(self):
    """Parses JSON body and verifies it's a dict.

    webob.Request doesn't cache the decoded json body, this function does.
    """
    if self._json_body is None:
      if (self.CONTENT_TYPE_BASE and
          self.request.content_type != self.CONTENT_TYPE_BASE):
        msg = (
            'Expecting JSON body with content type \'%s\'' %
            self.CONTENT_TYPE_BASE)
        self.abort_with_error(400, text=msg)
      try:
        self._json_body = self.request.json
        if not isinstance(self._json_body, dict):
          raise ValueError()
      except (LookupError, ValueError):
        self.abort_with_error(400, text='Not a valid json dict body')
    return self._json_body.copy()


def get_authenticated_routes(app):
  """Given WSGIApplication returns list of routes that use authentication.

  Intended to be used only for testing.
  """
  # This code is adapted from router's __repr__ method (that enumerate
  # all routes for pretty-printing).
  routes = list(app.router.match_routes)
  routes.extend(
      v for k, v in app.router.build_routes.iteritems()
      if v not in app.router.match_routes)
  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]


################################################################################
## All supported implementations of authentication methods for webapp2 handlers.


def gae_cookie_authentication(_request):
  """AppEngine cookie based authentication via users.get_current_user()."""
  user = users.get_current_user()
  try:
    return model.Identity(model.IDENTITY_USER, user.email()) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email())


def openid_cookie_authentication(request):
  """Cookie based authentication that uses OpenID flow for login."""
  user = openid.get_current_user(request)
  try:
    return model.Identity(model.IDENTITY_USER, user.email) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email)


def oauth_authentication(request):
  """OAuth2 based authentication via oauth.get_current_user()."""
  if not request.headers.get('Authorization'):
    return None
  if not utils.is_local_dev_server():
    return api.extract_oauth_caller_identity()

  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,
  # but real) OAuth2 API endpoint instead to validate access_token. It is also
  # what Cloud Endpoints do on a local server. For simplicity ignore client_id
  # on dev server.
  header = request.headers['Authorization'].split(' ', 1)
  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):
    raise api.AuthenticationError('Invalid authorization header')

  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.
  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'
  result = urlfetch.fetch(
      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),
      follow_redirects=False,
      validate_certificate=True)
  if result.status_code != 200:
    try:
      error = json.loads(result.content)['error_description']
    except (KeyError, ValueError):
      error = repr(result.content)
    raise api.AuthenticationError('Failed to validate the token: %s' % error)

  token_info = json.loads(result.content)
  if 'email' not in token_info:
    raise api.AuthenticationError('Token doesn\'t include an email address')
  if not token_info.get('verified_email'):
    raise api.AuthenticationError('Token email isn\'t verified')

  email = token_info['email']
  try:
    return model.Identity(model.IDENTITY_USER, email)
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % email)


def service_to_service_authentication(request):
  """Used for AppEngine <-> AppEngine communication.

  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't
  be set by external users (with exception of admins).
  """
  app_id = request.headers.get('X-Appengine-Inbound-Appid')
  try:
    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None
  except ValueError:
    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)


################################################################################
## API wrapper on top of Users API and OpenID API to make them similar.


class CurrentUser(object):
  """Mimics subset of GAE users.User object for ease of transition.

  Also adds .picture().
  """

  def __init__(self, user_id, email, picture):
    self._user_id = user_id
    self._email = email
    self._picture = picture

  def nickname(self):
    return self._email

  def email(self):
    return self._email

  def user_id(self):
    return self._user_id

  def picture(self):
    return self._picture

  def __unicode__(self):
    return unicode(self.nickname())

  def __str__(self):
    return str(self.nickname())


class GAEUsersAPI(object):
  @staticmethod
  def get_current_user(request):  # pylint: disable=unused-argument
    user = users.get_current_user()
    return CurrentUser(user.user_id(), user.email(), None) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return users.is_current_user_admin()

  @staticmethod
  def create_login_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_login_url(dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_logout_url(dest_url)


class OpenIDAPI(object):
  @staticmethod
  def get_current_user(request):
    user = openid.get_current_user(request)
    return CurrentUser(user.sub, user.email, user.picture) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return False

  @staticmethod
  def create_login_url(request, dest_url):
    return openid.create_login_url(request, dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):
    return openid.create_logout_url(request, dest_url)


# See AuthenticatingHandler._get_users_api().
_METHOD_TO_USERS_API = {
  gae_cookie_authentication: GAEUsersAPI,
  openid_cookie_authentication: OpenIDAPI,
}

#!/usr/bin/env python
# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.
# pylint: disable=W0612,W0613,R0201

import datetime
import json
import os
import sys
import unittest

from test_support import test_env
test_env.setup_test_env()

from google.appengine.api import oauth
from google.appengine.api import users

import webapp2
import webtest

from components import utils
from components.auth import api
from components.auth import delegation
from components.auth import handler
from components.auth import host_token
from components.auth import ipaddr
from components.auth import model
from components.auth.proto import delegation_pb2
from test_support import test_case


class AuthenticatingHandlerMetaclassTest(test_case.TestCase):
  """Tests for AuthenticatingHandlerMetaclass."""

  def test_good(self):
    # No request handling methods defined at all.
    class TestHandler1(handler.AuthenticatingHandler):
      def some_other_method(self):
        pass

    # @public is used.
    class TestHandler2(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        pass

    # @require is used.
    class TestHandler3(handler.AuthenticatingHandler):
      @api.require(lambda: True)
      def get(self):
        pass

  def test_bad(self):
    # @public or @require is missing.
    with self.assertRaises(TypeError):
      class TestHandler1(handler.AuthenticatingHandler):
        def get(self):
          pass


class AuthenticatingHandlerTest(test_case.TestCase):
  """Tests for AuthenticatingHandler class."""

  def setUp(self):
    super(AuthenticatingHandlerTest, self).setUp()
    # Reset global config of auth library before each test.
    api.reset_local_state()
    # Capture error and warning log messages.
    self.logged_errors = []
    self.mock(handler.logging, 'error',
        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))
    self.logged_warnings = []
    self.mock(handler.logging, 'warning',
        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))

  def make_test_app(self, path, request_handler):
    """Returns webtest.TestApp with single route."""
    return webtest.TestApp(
        webapp2.WSGIApplication([(path, request_handler)], debug=True),
        extra_environ={'REMOTE_ADDR': '127.0.0.1'})

  def test_anonymous(self):
    """If all auth methods are not applicable, identity is set to Anonymous."""
    test = self

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        non_applicable = lambda _request: None
        return [non_applicable, non_applicable]

      @api.public
      def get(self):
        test.assertEqual(model.Anonymous, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)                    

  def test_ip_whitelist_bot(self):
    """Requests from client in "bots" IP whitelist are authenticated as bot."""
    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_current_identity().to_bytes())

    app = self.make_test_app('/request', Handler)
    def call(ip):
      api.reset_local_state()
      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body

    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))                    
    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))                    

  def test_ip_whitelist(self):
    """Per-account IP whitelist works."""
    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')
    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')

    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])
    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')

    mocked_ident = [None]

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _req: mocked_ident[0]]

      @api.public
      def get(self):
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    def call(ident, ip):
      api.reset_local_state()
      mocked_ident[0] = ident
      response = app.get(
          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)
      return response.status_int

    # IP is whitelisted.
    self.assertEqual(200, call(ident1, '192.168.1.100'))                    
    # IP is NOT whitelisted.
    self.assertEqual(403, call(ident1, '127.0.0.1'))                    
    # Whitelist is not used.
    self.assertEqual(200, call(ident2, '127.0.0.1'))                    

  def test_auth_method_order(self):
    """Registered auth methods are tested in order."""
    test = self
    calls = []
    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')

    def not_applicable(request):
      self.assertEqual('/request', request.path)                    
      calls.append('not_applicable')
      return None

    def applicable(request):
      self.assertEqual('/request', request.path)                    
      calls.append('applicable')
      return ident

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [not_applicable, applicable]

      @api.public
      def get(self):
        test.assertEqual(ident, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)                    

    # Both methods should be tried.
    expected_calls = [
      'not_applicable',
      'applicable',
    ]
    self.assertEqual(expected_calls, calls)                    

  def test_authentication_error(self):
    """AuthenticationError in auth method stops request processing."""
    test = self
    calls = []

    def failing(request):
      raise api.AuthenticationError('Too bad')

    def skipped(request):
      self.fail('authenticate should not be called')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [failing, skipped]

      @api.public
      def get(self):
        test.fail('Handler code should not be called')

      def authentication_error(self, err):
        test.assertEqual('Too bad', err.message)
        calls.append('authentication_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authentication_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 401.
    self.assertEqual(['authentication_error'], calls)                    
    self.assertEqual(401, response.status_int)                    

    # Authentication error is logged.
    self.assertEqual(1, len(self.logged_warnings))                    

  def test_authorization_error(self):
    """AuthorizationError in auth method is handled."""
    test = self
    calls = []

    class Handler(handler.AuthenticatingHandler):
      @api.require(lambda: False)
      def get(self):
        test.fail('Handler code should not be called')

      def authorization_error(self, err):
        calls.append('authorization_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authorization_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 403.
    self.assertEqual(['authorization_error'], calls)                    
    self.assertEqual(403, response.status_int)                    

  def make_xsrf_handling_app(
      self,
      xsrf_token_enforce_on=None,
      xsrf_token_header=None,
      xsrf_token_request_param=None):
    """Returns webtest app with single XSRF-aware handler.

    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.
    """
    calls = []

    def record(request_handler, method):
      is_valid = request_handler.xsrf_token_data == {'some': 'data'}
      calls.append((method, is_valid))

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(self.generate_xsrf_token({'some': 'data'}))
      @api.public
      def post(self):
        record(self, 'POST')
      @api.public
      def put(self):
        record(self, 'PUT')
      @api.public
      def delete(self):
        record(self, 'DELETE')

    if xsrf_token_enforce_on is not None:
      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on
    if xsrf_token_header is not None:
      Handler.xsrf_token_header = xsrf_token_header
    if xsrf_token_request_param is not None:
      Handler.xsrf_token_request_param = xsrf_token_request_param

    app = self.make_test_app('/request', Handler)
    return app, calls

  def mock_get_current_identity(self, ident):
    """Mocks api.get_current_identity() to return |ident|."""
    self.mock(handler.api, 'get_current_identity', lambda: ident)

  def test_xsrf_token_get_param(self):
    """XSRF token works if put in GET parameters."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request?xsrf_token=%s' % token)
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_post_param(self):
    """XSRF token works if put in POST parameters."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_header(self):
    """XSRF token works if put in the headers."""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', headers={'X-XSRF-Token': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_missing(self):
    """XSRF token is not given but handler requires it."""
    app, calls = self.make_xsrf_handling_app()
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)                    
    self.assertFalse(calls)

  def test_xsrf_token_uses_enforce_on(self):
    """Only methods set in |xsrf_token_enforce_on| require token validation."""
    # Validate tokens only on PUT (not on POST).
    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))
    token = app.get('/request').body
    # Both POST and PUT work when token provided, verifying it.
    app.post('/request', {'xsrf_token': token})
    app.put('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True), ('PUT', True)], calls)                    
    # POST works without a token, put PUT doesn't.
    self.assertEqual(200, app.post('/request').status_int)                    
    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)                    
    # Both fail if wrong token is provided.
    bad_token = {'xsrf_token': 'boo'}
    self.assertEqual(                    
        403, app.post('/request', bad_token, expect_errors=True).status_int)                    
    self.assertEqual(                    
        403, app.put('/request', bad_token, expect_errors=True).status_int)

  def test_xsrf_token_uses_xsrf_token_header(self):
    """Name of the header used for XSRF can be changed."""
    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')
    token = app.get('/request').body
    app.post('/request', headers={'X-Some': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_uses_xsrf_token_request_param(self):
    """Name of the request param used for XSRF can be changed."""
    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')
    token = app.get('/request').body
    app.post('/request', {'tok': token})
    self.assertEqual([('POST', True)], calls)                    

  def test_xsrf_token_identity_matters(self):
    app, calls = self.make_xsrf_handling_app()
    # Generate token for identity A.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'a@example.com'))
    token = app.get('/request').body
    # Try to use it by identity B.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'b@example.com'))
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)                    
    self.assertFalse(calls)

  def test_get_authenticated_routes(self):
    class Authenticated(handler.AuthenticatingHandler):
      pass

    class NotAuthenticated(webapp2.RequestHandler):
      pass

    app = webapp2.WSGIApplication([
      webapp2.Route('/authenticated', Authenticated),
      webapp2.Route('/not-authenticated', NotAuthenticated),
    ])
    routes = handler.get_authenticated_routes(app)
    self.assertEqual(1, len(routes))                    
    self.assertEqual(Authenticated, routes[0].handler)                    

  def test_get_peer_ip(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})
    self.assertEqual('192.1.2.3', response.body)                    

  def test_get_peer_host(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_peer_host() or '<none>')

    app = self.make_test_app('/request', Handler)
    def call(headers):
      api.reset_local_state()
      return app.get('/request', headers=headers).body

    # Good token.
    token = host_token.create_host_token('HOST.domain.com')
    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))                    

    # Missing or invalid tokens.
    self.assertEqual('<none>', call({}))                    
    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))                    

    # Expired token.
    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)
    self.mock_now(origin)
    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)
    self.mock_now(origin, 61)
    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))                    

  def test_delegation_token(self):
    peer_ident = model.Identity.from_bytes('user:peer@a.com')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _request: peer_ident]

      @api.public
      def get(self):
        self.response.write(json.dumps({
          'peer_id': api.get_peer_identity().to_bytes(),
          'cur_id': api.get_current_identity().to_bytes(),
        }))

    app = self.make_test_app('/request', Handler)
    def call(headers=None):
      return json.loads(app.get('/request', headers=headers).body)

    # No delegation.
    self.assertEqual(                    
        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())

    # TODO(vadimsh): Mint token via some high-level function call.
    subtokens = delegation_pb2.SubtokenList(subtokens=[
        delegation_pb2.Subtoken(
            issuer_id='user:delegated@a.com',
            creation_time=int(utils.time_time()),
            validity_duration=3600),
    ])
    tok = delegation.serialize_token(delegation.seal_token(subtokens))

    # With valid delegation token.
    self.assertEqual(                    
        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},
        call({'X-Delegation-Token-V1': tok}))

    # With invalid delegation token.
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok + 'blah'},
        expect_errors=True)
    self.assertEqual(403, r.status_int)                    

    # Transient error.
    def mocked_check(*_args):
      raise delegation.TransientError('Blah')
    self.mock(delegation, 'check_delegation_token', mocked_check)
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok},
        expect_errors=True)
    self.assertEqual(500, r.status_int)                    


class GaeCookieAuthenticationTest(test_case.TestCase):
  """Tests for gae_cookie_authentication function."""

  def test_non_applicable(self):
    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))

  def test_applicable(self):
    os.environ.update({
      'USER_EMAIL': 'joe@example.com',
      'USER_ID': '123',
      'USER_IS_ADMIN': '0',
    })
    # Actual request is not used by CookieAuthentication.
    self.assertEqual(                    
        model.Identity(model.IDENTITY_USER, 'joe@example.com'),
        handler.gae_cookie_authentication(webapp2.Request({})))


class ServiceToServiceAuthenticationTest(test_case.TestCase):
  """Tests for service_to_service_authentication."""

  def test_non_applicable(self):
    request = webapp2.Request({})
    self.assertIsNone(
        handler.service_to_service_authentication(request))

  def test_applicable(self):
    request = webapp2.Request({
      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',
    })
    self.assertEqual(                    
      model.Identity(model.IDENTITY_SERVICE, 'some-app'),
      handler.service_to_service_authentication(request))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()

# Copyright 2015 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Internal bot API handlers."""

import base64
import json
import logging
import textwrap

import webob
import webapp2

from google.appengine.api import app_identity
from google.appengine.api import datastore_errors
from google.appengine.datastore import datastore_query
from google.appengine import runtime
from google.appengine.ext import ndb

from components import auth
from components import ereporter2
from components import utils
from server import acl
from server import bot_code
from server import bot_management
from server import stats
from server import task_pack
from server import task_request
from server import task_result
from server import task_scheduler
from server import task_to_run


def has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):
  """Returns an error if unexpected keys are present or expected keys are
  missing.

  Accepts optional keys.

  This is important to catch typos.
  """
  actual_keys = frozenset(actual_keys)
  superfluous = actual_keys - expected_keys
  missing = minimum_keys - actual_keys
  if superfluous or missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    msg_superfluous = (
        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')
    return 'Unexpected %s%s%s; did you make a typo?' % (
        name, msg_missing, msg_superfluous)


def has_unexpected_keys(expected_keys, actual_keys, name):
  """Return an error if unexpected keys are present or expected keys are
  missing.
  """
  return has_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, name)


def log_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, request, source, name):
  """Logs an error if unexpected keys are present or expected keys are missing.

  Accepts optional keys.

  This is important to catch typos.
  """
  message = has_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, name)
  if message:
    ereporter2.log_request(request, source=source, message=message)
  return message


def log_unexpected_keys(expected_keys, actual_keys, request, source, name):
  """Logs an error if unexpected keys are present or expected keys are missing.
  """
  return log_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, request, source, name)


def has_missing_keys(minimum_keys, actual_keys, name):
  """Returns an error if expected keys are not present.

  Do not warn about unexpected keys.
  """
  actual_keys = frozenset(actual_keys)
  missing = minimum_keys - actual_keys
  if missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)


class BootstrapHandler(auth.AuthenticatingHandler):
  """Returns python code to run to bootstrap a swarming bot."""

  @auth.require(acl.is_bot)
  def get(self):
    self.response.headers['Content-Type'] = 'text/x-python'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename="swarming_bot_bootstrap.py"')
    self.response.out.write(
        bot_code.get_bootstrap(self.request.host_url).content)


class BotCodeHandler(auth.AuthenticatingHandler):
  """Returns a zip file with all the files required by a bot.

  Optionally specify the hash version to download. If so, the returned data is
  cacheable.
  """

  @auth.require(acl.is_bot)
  def get(self, version=None):
    if version:
      expected = bot_code.get_bot_version(self.request.host_url)
      if version != expected:
        # This can happen when the server is rapidly updated.
        logging.error('Requested Swarming bot %s, have %s', version, expected)
        self.abort(404)
      self.response.headers['Cache-Control'] = 'public, max-age=3600'
    else:
      self.response.headers['Cache-Control'] = 'no-cache, no-store'
    self.response.headers['Content-Type'] = 'application/octet-stream'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename="swarming_bot.zip"')
    self.response.out.write(
        bot_code.get_swarming_bot_zip(self.request.host_url))


class _BotBaseHandler(auth.ApiHandler):
  """
  Request body is a JSON dict:
    {
      "dimensions": <dict of properties>,
      "state": <dict of properties>,
      "version": <sha-1 of swarming_bot.zip uncompressed content>,
    }
  """

  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}
  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  def _process(self):
    """Returns True if the bot has invalid parameter and should be automatically
    quarantined.

    Does one DB synchronous GET.

    Returns:
      tuple(request, bot_id, version, state, dimensions, quarantined_msg)
    """
    request = self.parse_body()
    version = request.get('version', None)

    dimensions = request.get('dimensions', {})
    state = request.get('state', {})
    bot_id = None
    if dimensions.get('id'):
      dimension_id = dimensions['id']
      if (isinstance(dimension_id, list) and len(dimension_id) == 1
          and isinstance(dimension_id[0], unicode)):
        bot_id = dimensions['id'][0]

    # The bot may decide to "self-quarantine" itself. Accept both via
    # dimensions or via state. See bot_management._BotCommon.quarantined for
    # more details.
    if (bool(dimensions.get('quarantined')) or
        bool(state.get('quarantined'))):
      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'

    quarantined_msg = None
    # Use a dummy 'for' to be able to break early from the block.
    for _ in [0]:

      quarantined_msg = has_unexpected_keys(
          self.EXPECTED_KEYS, request, 'keys')
      if quarantined_msg:
        break

      quarantined_msg = has_missing_keys(
          self.REQUIRED_STATE_KEYS, state, 'state')
      if quarantined_msg:
        break

      if not bot_id:
        quarantined_msg = 'Missing bot id'
        break

      if not all(
          isinstance(key, unicode) and
          isinstance(values, list) and
          all(isinstance(value, unicode) for value in values)
          for key, values in dimensions.iteritems()):
        quarantined_msg = (
            'Invalid dimensions type:\n%s' % json.dumps(dimensions,
              sort_keys=True, indent=2, separators=(',', ': ')))
        break

      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)
      if dimensions_count > task_to_run.MAX_DIMENSIONS:
        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count
        break

      if not isinstance(
          state.get('lease_expiration_ts'), (None.__class__, int)):
        quarantined_msg = (
            'lease_expiration_ts (%r) must be int or None' % (
                state['lease_expiration_ts']))
        break

    if quarantined_msg:
      line = 'Quarantined Bot\nhttps://%s/restricted/bot/%s\n%s' % (
          app_identity.get_default_version_hostname(), bot_id,
          quarantined_msg)
      ereporter2.log_request(self.request, source='bot', message=line)
      return request, bot_id, version, state, dimensions, quarantined_msg

    # Look for admin enforced quarantine.
    bot_settings = bot_management.get_settings_key(bot_id).get()
    if bool(bot_settings and bot_settings.quarantined):
      return request, bot_id, version, state, dimensions, 'Quarantined by admin'

    return request, bot_id, version, state, dimensions, None


class BotHandshakeHandler(_BotBaseHandler):
  """First request to be called to get initial data like XSRF token.

  The bot is server-controled so the server doesn't have to support multiple API
  version. When running a task, the bot sync the the version specific URL. Once
  abot finished its currently running task, it'll be immediately be upgraded
  after on its next poll.

  This endpoint does not return commands to the bot, for example to upgrade
  itself. It'll be told so when it does its first poll.

  Response body is a JSON dict:
    {
      "bot_version": <sha-1 of swarming_bot.zip uncompressed content>,
      "server_version": "138-193f1f3",
      "xsrf_token": "......",                    
    }
  """

  # This handler is called to get XSRF token, there's nothing to enforce yet.
  xsrf_token_enforce_on = ()                    

  @auth.require_xsrf_token_request                    
  @auth.require(acl.is_bot)
  def post(self):
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    bot_management.bot_event(
        event_type='bot_connected', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=dimensions,
        state=state, version=version, quarantined=bool(quarantined_msg),
        task_id='', task_name=None, message=quarantined_msg)

    data = {
      # This access token will be used to validate each subsequent request.
      'bot_version': bot_code.get_bot_version(self.request.host_url),
      'expiration_sec': auth.handler.XSRFToken.expiration_sec,
      'server_version': utils.get_app_version(),
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.send_response(data)


class BotPollHandler(_BotBaseHandler):
  """The bot polls for a task; returns either a task, update command or sleep.

  In case of exception on the bot, this is enough to get it just far enough to
  eventually self-update to a working version. This is to ensure that coding
  errors in bot code doesn't kill all the fleet at once, they should still be up
  just enough to be able to self-update again even if they don't get task
  assigned anymore.
  """

  @auth.require(acl.is_bot)
  def post(self):
    """Handles a polling request.

    Be very permissive on missing values. This can happen because of errors
    on the bot, *we don't want to deny them the capacity to update*, so that the
    bot code is eventually fixed and the bot self-update to this working code.

    It makes recovery of the fleet in case of catastrophic failure much easier.
    """
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    sleep_streak = state.get('sleep_streak', 0)
    quarantined = bool(quarantined_msg)

    # Note bot existence at two places, one for stats at 1 minute resolution,
    # the other for the list of known bots.
    action = 'bot_inactive' if quarantined else 'bot_active'
    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)

    def bot_event(event_type, task_id=None, task_name=None):
      bot_management.bot_event(
          event_type=event_type, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=dimensions,
          state=state, version=version, quarantined=quarantined,
          task_id=task_id, task_name=task_name, message=quarantined_msg)

    # Bot version is host-specific because the host URL is embedded in
    # swarming_bot.zip
    expected_version = bot_code.get_bot_version(self.request.host_url)
    if version != expected_version:
      bot_event('request_update')
      self._cmd_update(expected_version)
      return
    if quarantined:
      bot_event('request_sleep')
      self._cmd_sleep(sleep_streak, quarantined)
      return

    #
    # At that point, the bot should be in relatively good shape since it's
    # running the right version. It is still possible that invalid code was
    # pushed to the server, so be diligent about it.
    #

    # Bot may need a reboot if it is running for too long. We do not reboot
    # quarantined bots.
    needs_restart, restart_message = bot_management.should_restart_bot(
        bot_id, state)
    if needs_restart:
      bot_event('request_restart')
      self._cmd_restart(restart_message)
      return

    # The bot is in good shape. Try to grab a task.
    try:
      # This is a fairly complex function call, exceptions are expected.
      request, run_result = task_scheduler.bot_reap_task(
          dimensions, bot_id, version, state.get('lease_expiration_ts'))
      if not request:
        # No task found, tell it to sleep a bit.
        bot_event('request_sleep')
        self._cmd_sleep(sleep_streak, quarantined)
        return

      try:
        # This part is tricky since it intentionally runs a transaction after
        # another one.
        if request.properties.is_terminate:
          bot_event('bot_terminate', task_id=run_result.task_id)
          self._cmd_terminate(run_result.task_id)
        else:
          bot_event(
              'request_task', task_id=run_result.task_id,
              task_name=request.name)
          self._cmd_run(request, run_result.key, bot_id)
      except:
        logging.exception('Dang, exception after reaping')
        raise
    except runtime.DeadlineExceededError:
      # If the timeout happened before a task was assigned there is no problems.
      # If the timeout occurred after a task was assigned, that task will
      # timeout (BOT_DIED) since the bot didn't get the details required to
      # run it) and it will automatically get retried (TODO) when the task times
      # out.
      # TODO(maruel): Note the task if possible and hand it out on next poll.
      # https://code.google.com/p/swarming/issues/detail?id=130
      self.abort(500, 'Deadline')

  def _cmd_run(self, request, run_result_key, bot_id):
    cmd = None
    if request.properties.commands:
      cmd = request.properties.commands[0]
    elif request.properties.command:
      cmd = request.properties.command
    out = {
      'cmd': 'run',
      'manifest': {
        'bot_id': bot_id,
        'command': cmd,
        'dimensions': request.properties.dimensions,
        'env': request.properties.env,
        'extra_args': request.properties.extra_args,
        'grace_period': request.properties.grace_period_secs,
        'hard_timeout': request.properties.execution_timeout_secs,
        'host': utils.get_versioned_hosturl(),
        'io_timeout': request.properties.io_timeout_secs,
        'inputs_ref': request.properties.inputs_ref,
        'task_id': task_pack.pack_run_result_key(run_result_key),
      },
    }
    self.send_response(utils.to_json_encodable(out))

  def _cmd_sleep(self, sleep_streak, quarantined):
    out = {
      'cmd': 'sleep',
      'duration': task_scheduler.exponential_backoff(sleep_streak),
      'quarantined': quarantined,
    }
    self.send_response(out)

  def _cmd_terminate(self, task_id):
    out = {
      'cmd': 'terminate',
      'task_id': task_id,
    }
    self.send_response(out)

  def _cmd_update(self, expected_version):
    out = {
      'cmd': 'update',
      'version': expected_version,
    }
    self.send_response(out)

  def _cmd_restart(self, message):
    logging.info('Rebooting bot: %s', message)
    out = {
      'cmd': 'restart',
      'message': message,
    }
    self.send_response(out)


class BotEventHandler(_BotBaseHandler):
  """On signal that a bot had an event worth logging."""

  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}

  @auth.require(acl.is_bot)
  def post(self):
    (request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    event = request.get('event')
    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):
      self.abort_with_error(400, error='Unsupported event type')
    message = request.get('message')
    bot_management.bot_event(
        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,
        dimensions=dimensions, state=state, version=version,
        quarantined=bool(quarantined_msg), task_id=None, task_name=None,
        message=message)

    if event == 'bot_error':
      line = (
          'Bot: https://%s/restricted/bot/%s\n'
          'Bot error:\n'
          '%s') % (
          app_identity.get_default_version_hostname(), bot_id, message)
      ereporter2.log_request(self.request, source='bot', message=line)
    self.send_response({})


class BotTaskUpdateHandler(auth.ApiHandler):
  """Receives updates from a Bot for a task.

  The handler verifies packets are processed in order and will refuse
  out-of-order packets.
  """
  ACCEPTED_KEYS = {
    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',
    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',
    u'output_chunk_start', u'outputs_ref', u'task_id',
  }
  REQUIRED_KEYS = {u'id', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    # Unlike handshake and poll, we do not accept invalid keys here. This code
    # path is much more strict.
    request = self.parse_body()
    msg = log_unexpected_subset_keys(
        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',
        'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    bot_id = request['id']
    cost_usd = request['cost_usd']
    task_id = request['task_id']

    bot_overhead = request.get('bot_overhead')
    duration = request.get('duration')
    exit_code = request.get('exit_code')
    hard_timeout = request.get('hard_timeout')
    io_timeout = request.get('io_timeout')
    isolated_stats = request.get('isolated_stats')
    output = request.get('output')
    output_chunk_start = request.get('output_chunk_start')
    outputs_ref = request.get('outputs_ref')

    if bool(isolated_stats) != (bot_overhead is not None):
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % task_id)
      self.abort_with_error(
          400,
          error='Both bot_overhead and isolated_stats must be set '
                'simultaneously\nbot_overhead: %s\nisolated_stats: %s' %
                (bot_overhead, isolated_stats))

    run_result_key = task_pack.unpack_run_result_key(task_id)
    performance_stats = None
    if isolated_stats:
      download = isolated_stats['download']
      upload = isolated_stats['upload']
      performance_stats = task_result.PerformanceStats(
          bot_overhead=bot_overhead,
          isolated_download=task_result.IsolatedOperation(
              duration=download['duration'],
              initial_number_items=download['initial_number_items'],
              initial_size=download['initial_size'],
              items_cold=base64.b64decode(download['items_cold']),
              items_hot=base64.b64decode(download['items_hot'])),
          isolated_upload=task_result.IsolatedOperation(
              duration=upload['duration'],
              items_cold=base64.b64decode(upload['items_cold']),
              items_hot=base64.b64decode(upload['items_hot'])))

    if output is not None:
      try:
        output = base64.b64decode(output)
      except UnicodeEncodeError as e:
        logging.error('Failed to decode output\n%s\n%r', e, output)
        output = output.encode('ascii', 'replace')
      except TypeError as e:
        # Save the output as-is instead. The error will be logged in ereporter2
        # and returning a HTTP 500 would only force the bot to stay in a retry
        # loop.
        logging.error('Failed to decode output\n%s\n%r', e, output)
    if outputs_ref:
      outputs_ref = task_request.FilesRef(**outputs_ref)

    try:
      state = task_scheduler.bot_update_task(
          run_result_key=run_result_key,
          bot_id=bot_id,
          output=output,
          output_chunk_start=output_chunk_start,
          exit_code=exit_code,
          duration=duration,
          hard_timeout=hard_timeout,
          io_timeout=io_timeout,
          cost_usd=cost_usd,
          outputs_ref=outputs_ref,
          performance_stats=performance_stats)
      if not state:
        logging.info('Failed to update, please retry')
        self.abort_with_error(500, error='Failed to update, please retry')

      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):
        action = 'task_completed'
      else:
        assert state == task_result.State.RUNNING, state
        action = 'task_update'
      bot_management.bot_event(
          event_type=action, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=None, state=None,
          version=None, quarantined=None, task_id=task_id, task_name=None)
    except ValueError as e:
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % e)
      self.abort_with_error(400, error=str(e))
    except webob.exc.HTTPException:
      raise
    except Exception as e:
      logging.exception('Internal error: %s', e)
      self.abort_with_error(500, error=str(e))

    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot
    # reboots itself to abort the task abruptly. It is useful when a task hangs
    # and the timeout was set too long or the task was superseded by a newer
    # task with more recent executable (e.g. a new Try Server job on a newer
    # patchset on Rietveld).
    self.send_response({'ok': True})


class BotTaskErrorHandler(auth.ApiHandler):
  """It is a specialized version of ereporter2's /ereporter2/api/v1/on_error
  that also attaches a task id to it.

  This formally kills the task, marking it as an internal failure. This can be
  used by bot_main.py to kill the task when task_runner misbehaved.
  """

  EXPECTED_KEYS = {u'id', u'message', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()                    

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    request = self.parse_body()
    bot_id = request.get('id')
    task_id = request.get('task_id', '')
    message = request.get('message', 'unknown')

    bot_management.bot_event(
        event_type='task_error', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=None, state=None,
        version=None, quarantined=None, task_id=task_id, task_name=None,
        message=message)
    line = (
        'Bot: https://%s/restricted/bot/%s\n'
        'Task failed: https://%s/user/task/%s\n'
        '%s') % (
        app_identity.get_default_version_hostname(), bot_id,
        app_identity.get_default_version_hostname(), task_id,
        message)
    ereporter2.log_request(self.request, source='bot', message=line)

    msg = log_unexpected_keys(
        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    msg = task_scheduler.bot_kill_task(
        task_pack.unpack_run_result_key(task_id), bot_id)
    if msg:
      logging.error(msg)
      self.abort_with_error(400, error=msg)
    self.send_response({})


class ServerPingHandler(webapp2.RequestHandler):
  """Handler to ping when checking if the server is up.

  This handler should be extremely lightweight. It shouldn't do any
  computations, it should just state that the server is up. It's open to
  everyone for simplicity and performance.
  """

  def get(self):
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.out.write('Server up')


def get_routes():
  routes = [
      ('/bootstrap', BootstrapHandler),
      ('/bot_code', BotCodeHandler),
      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),
      ('/swarming/api/v1/bot/event', BotEventHandler),
      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),
      ('/swarming/api/v1/bot/poll', BotPollHandler),
      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),
      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',
          BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),
      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',
          BotTaskErrorHandler),
  ]
  return [webapp2.Route(*i) for i in routes]

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Generates the swarming_bot.zip archive for the bot.

Unlike the other source files, this file can be run from ../tools/bot_archive.py
stand-alone to generate a swarming_bot.zip for local testing so it doesn't
import anything from the AppEngine SDK.

The hash of the content of the files in the archive is used to define the
current version of the swarming bot code.
"""

import hashlib
import json
import logging
import os
import StringIO
import zipfile


# List of files needed by the swarming bot.
# TODO(maruel): Make the list automatically generated?
FILES = (
    '__main__.py',
    'api/__init__.py',
    'api/bot.py',
    'api/parallel.py',
    'api/os_utilities.py',
    'api/platforms/__init__.py',
    'api/platforms/android.py',
    'api/platforms/common.py',
    'api/platforms/gce.py',
    'api/platforms/linux.py',
    'api/platforms/osx.py',
    'api/platforms/posix.py',
    'api/platforms/win.py',
    'bot_code/__init__.py',
    'bot_code/bot_main.py',
    'bot_code/common.py',
    'bot_code/singleton.py',
    'bot_code/task_runner.py',
    'bot_code/xsrf_client.py',                    
    'client/auth.py',
    'client/isolated_format.py',
    'client/isolateserver.py',
    'client/run_isolated.py',
    'config/__init__.py',
    'third_party/__init__.py',
    'third_party/colorama/__init__.py',
    'third_party/colorama/ansi.py',
    'third_party/colorama/ansitowin32.py',
    'third_party/colorama/initialise.py',
    'third_party/colorama/win32.py',
    'third_party/colorama/winterm.py',
    'third_party/depot_tools/__init__.py',
    'third_party/depot_tools/fix_encoding.py',
    'third_party/depot_tools/subcommand.py',
    'third_party/httplib2/__init__.py',
    'third_party/httplib2/cacerts.txt',
    'third_party/httplib2/iri2uri.py',
    'third_party/httplib2/socks.py',
    'third_party/oauth2client/__init__.py',
    'third_party/oauth2client/_helpers.py',
    'third_party/oauth2client/_openssl_crypt.py',
    'third_party/oauth2client/_pycrypto_crypt.py',
    'third_party/oauth2client/client.py',
    'third_party/oauth2client/clientsecrets.py',
    'third_party/oauth2client/crypt.py',
    'third_party/oauth2client/file.py',
    'third_party/oauth2client/gce.py',
    'third_party/oauth2client/keyring_storage.py',
    'third_party/oauth2client/locked_file.py',
    'third_party/oauth2client/multistore_file.py',
    'third_party/oauth2client/service_account.py',
    'third_party/oauth2client/tools.py',
    'third_party/oauth2client/util.py',
    'third_party/oauth2client/xsrfutil.py',
    'third_party/pyasn1/pyasn1/__init__.py',
    'third_party/pyasn1/pyasn1/codec/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',
    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',
    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',
    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',
    'third_party/pyasn1/pyasn1/codec/der/__init__.py',
    'third_party/pyasn1/pyasn1/codec/der/decoder.py',
    'third_party/pyasn1/pyasn1/codec/der/encoder.py',
    'third_party/pyasn1/pyasn1/compat/__init__.py',
    'third_party/pyasn1/pyasn1/compat/binary.py',
    'third_party/pyasn1/pyasn1/compat/octets.py',
    'third_party/pyasn1/pyasn1/debug.py',
    'third_party/pyasn1/pyasn1/error.py',
    'third_party/pyasn1/pyasn1/type/__init__.py',
    'third_party/pyasn1/pyasn1/type/base.py',
    'third_party/pyasn1/pyasn1/type/char.py',
    'third_party/pyasn1/pyasn1/type/constraint.py',
    'third_party/pyasn1/pyasn1/type/error.py',
    'third_party/pyasn1/pyasn1/type/namedtype.py',
    'third_party/pyasn1/pyasn1/type/namedval.py',
    'third_party/pyasn1/pyasn1/type/tag.py',
    'third_party/pyasn1/pyasn1/type/tagmap.py',
    'third_party/pyasn1/pyasn1/type/univ.py',
    'third_party/pyasn1/pyasn1/type/useful.py',
    'third_party/requests/__init__.py',
    'third_party/requests/adapters.py',
    'third_party/requests/api.py',
    'third_party/requests/auth.py',
    'third_party/requests/certs.py',
    'third_party/requests/compat.py',
    'third_party/requests/cookies.py',
    'third_party/requests/exceptions.py',
    'third_party/requests/hooks.py',
    'third_party/requests/models.py',
    'third_party/requests/packages/__init__.py',
    'third_party/requests/packages/urllib3/__init__.py',
    'third_party/requests/packages/urllib3/_collections.py',
    'third_party/requests/packages/urllib3/connection.py',
    'third_party/requests/packages/urllib3/connectionpool.py',
    'third_party/requests/packages/urllib3/contrib/__init__.py',
    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',
    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',
    'third_party/requests/packages/urllib3/exceptions.py',
    'third_party/requests/packages/urllib3/fields.py',
    'third_party/requests/packages/urllib3/filepost.py',
    'third_party/requests/packages/urllib3/packages/__init__.py',
    'third_party/requests/packages/urllib3/packages/ordered_dict.py',
    'third_party/requests/packages/urllib3/packages/six.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '__init__.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '_implementation.py',
    'third_party/requests/packages/urllib3/poolmanager.py',
    'third_party/requests/packages/urllib3/request.py',
    'third_party/requests/packages/urllib3/response.py',
    'third_party/requests/packages/urllib3/util/__init__.py',
    'third_party/requests/packages/urllib3/util/connection.py',
    'third_party/requests/packages/urllib3/util/request.py',
    'third_party/requests/packages/urllib3/util/response.py',
    'third_party/requests/packages/urllib3/util/retry.py',
    'third_party/requests/packages/urllib3/util/ssl_.py',
    'third_party/requests/packages/urllib3/util/timeout.py',
    'third_party/requests/packages/urllib3/util/url.py',
    'third_party/requests/sessions.py',
    'third_party/requests/status_codes.py',
    'third_party/requests/structures.py',
    'third_party/requests/utils.py',
    'third_party/rsa/rsa/__init__.py',
    'third_party/rsa/rsa/_compat.py',
    'third_party/rsa/rsa/_version133.py',
    'third_party/rsa/rsa/_version200.py',
    'third_party/rsa/rsa/asn1.py',
    'third_party/rsa/rsa/bigfile.py',
    'third_party/rsa/rsa/cli.py',
    'third_party/rsa/rsa/common.py',
    'third_party/rsa/rsa/core.py',
    'third_party/rsa/rsa/key.py',
    'third_party/rsa/rsa/parallel.py',
    'third_party/rsa/rsa/pem.py',
    'third_party/rsa/rsa/pkcs1.py',
    'third_party/rsa/rsa/prime.py',
    'third_party/rsa/rsa/randnum.py',
    'third_party/rsa/rsa/transform.py',
    'third_party/rsa/rsa/util.py',
    'third_party/rsa/rsa/varblock.py',
    'third_party/six/__init__.py',
    'utils/__init__.py',
    'utils/cacert.pem',
    'utils/file_path.py',
    'utils/fs.py',
    'utils/large.py',
    'utils/logging_utils.py',
    'utils/lru.py',
    'utils/net.py',
    'utils/oauth.py',
    'utils/on_error.py',
    'utils/subprocess42.py',
    'utils/threading_utils.py',
    'utils/tools.py',
    'utils/zip_package.py',
    'adb/__init__.py',
    'adb/adb_commands.py',
    'adb/adb_protocol.py',
    'adb/common.py',
    'adb/contrib/__init__.py',
    'adb/contrib/adb_commands_safe.py',
    'adb/contrib/high.py',
    'adb/contrib/parallel.py',
    'adb/fastboot.py',
    'adb/filesync_protocol.py',
    'adb/sign_pythonrsa.py',
    'adb/usb_exceptions.py',
    'python_libusb1/__init__.py',
    'python_libusb1/libusb1.py',
    'python_libusb1/usb1.py',
)


def is_windows():
  """Returns True if this code is running under Windows."""
  return os.__file__[0] != '/'


def resolve_symlink(path):
  """Processes path containing symlink on Windows.

  This is needed to make ../swarming_bot/main_test.py pass on Windows because
  git on Windows renders symlinks as normal files.
  """
  if not is_windows():
    # Only does this dance on Windows.
    return path
  parts = os.path.normpath(path).split(os.path.sep)
  for i in xrange(2, len(parts)):
    partial = os.path.sep.join(parts[:i])
    if os.path.isfile(partial):
      with open(partial) as f:
        link = f.read()
      assert '\n' not in link and link, link
      parts[i-1] = link
  return os.path.normpath(os.path.sep.join(parts))


def yield_swarming_bot_files(root_dir, host, host_version, additionals):
  """Yields all the files to map as tuple(filename, content).

  config.json is injected with json data about the server.

  This function guarantees that the output is sorted by filename.
  """
  items = {i: None for i in FILES}
  items.update(additionals)
  config = {
    'server': host.rstrip('/'),
    'server_version': host_version,
  }
  items['config/config.json'] = json.dumps(config)
  for item, content in sorted(items.iteritems()):
    if content is not None:
      yield item, content
    else:
      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:
        yield item, f.read()


def get_swarming_bot_zip(root_dir, host, host_version, additionals):
  """Returns a zipped file of all the files a bot needs to run.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: dict(filepath: content) of additional items to put into the zip
        file, in addition to FILES and MAPPED. In practice, it's going to be a
        custom bot_config.py.
  Returns:
    Tuple(str being the zipped file's content, bot version (SHA-1) it
    represents).
  """
  zip_memory_file = StringIO.StringIO()
  h = hashlib.sha1()
  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      zip_file.writestr(name, content)
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)

  data = zip_memory_file.getvalue()
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_zip(%s) is %d bytes; %s',
      additionals.keys(), len(data), bot_version)
  return data, bot_version


def get_swarming_bot_version(root_dir, host, host_version, additionals):
  """Returns the SHA1 hash of the bot code, representing the version.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: See get_swarming_bot_zip's doc.

  Returns:
    The SHA1 hash of the bot code.
  """
  h = hashlib.sha1()
  try:
    # TODO(maruel): Deduplicate from zip_package.genereate_version().
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)
  except IOError:
    logging.warning('Missing expected file. Hash will be invalid.')
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)
  return bot_version

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Runs either task_runner.py, bot_main.py or bot_config.py.

The imports are done late so if an ImportError occurs, it is localized to this
command only.
"""

import code
import json
import logging
import os
import optparse
import shutil
import sys
import zipfile

from bot_code import common                    

# That's from ../../../client/
from third_party.depot_tools import fix_encoding
from utils import logging_utils
from utils import zip_package

# This file can only be run as a zip.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# libusb1 expects to be directly in sys.path.
sys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))


# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the
# sub commands packed into the single .zip file as a swiss army knife (think
# busybox but worse).


def CMDattributes(_args):
  """Prints out the bot's attributes."""
  from bot_code import bot_main
  json.dump(
      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,
      sort_keys=True, separators=(',', ': '))
  print('')
  return 0


def CMDconfig(_args):
  """Prints the config.json embedded in this zip."""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)
  print('')
  return 0


def CMDis_fine(_args):
  """Just reports that the code doesn't throw.

  That ensures that the bot has minimal viability before transfering control to
  it. For now, it just imports bot_main but later it'll check the config, etc.
  """
  # pylint: disable=unused-variable
  from bot_code import bot_main
  from config import bot_config
  # We're #goodenough.
  return 0


def CMDrestart(_args):
  """Utility subcommand that hides the difference between each OS to reboot
  the host."""
  logging_utils.prepare_logging(None)
  import os_utilities
  # This function doesn't return.
  os_utilities.restart()
  # Should never reach here.
  return 1


def CMDrun_isolated(args):
  """Internal command to run an isolated command."""
  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))
  # run_isolated setups logging by itself.
  import run_isolated
  return run_isolated.main(args)


def CMDsetup(_args):
  """Setup the bot to auto-start but doesn't start the bot."""
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))
  from bot_code import bot_main
  bot_main.setup_bot(True)
  return 0


def CMDserver(_args):
  """Prints the server url. It's like 'config' but easier to parse."""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  print bot_main.get_config()['server']
  return 0


def CMDshell(args):
  """Starts a shell with api.* in.."""
  logging_utils.prepare_logging(None)
  logging_utils.set_console_level(logging.DEBUG)

  from bot_code import bot_main
  from api import os_utilities
  from api import platforms
  local_vars = {
    'bot_main': bot_main,
    'json': json,
    'os_utilities': os_utilities,
    'platforms': platforms,
  }
  # Can't use: from api.platforms import *
  local_vars.update(
      (k, v) for k, v in platforms.__dict__.iteritems()
      if not k.startswith('_'))

  if args:
    for arg in args:
      exec code.compile_command(arg) in local_vars
  else:
    code.interact(
        'Locals:\n  ' + '\n  '.join( sorted(local_vars)), None, local_vars)
  return 0


def CMDstart_bot(args):
  """Starts the swarming bot."""
  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))
  logging.info(
      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())
  from bot_code import bot_main
  result = bot_main.main(args)
  logging.info('bot_main exit code: %d', result)
  return result


def CMDstart_slave(args):
  """Ill named command that actually sets up the bot then start it."""
  # TODO(maruel): Rename function.
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))

  parser = optparse.OptionParser()
  parser.add_option(
      '--survive', action='store_true',
      help='Do not reboot the host even if bot_config.setup_bot() asked to')
  options, args = parser.parse_args(args)

  try:
    from bot_code import bot_main
    bot_main.setup_bot(options.survive)
  except Exception:
    logging.exception('bot_main.py failed.')

  logging.info('Starting the bot: %s', THIS_FILE)
  return common.exec_python([THIS_FILE, 'start_bot'])


def CMDtask_runner(args):
  """Internal command to run a swarming task."""
  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))
  from bot_code import task_runner
  return task_runner.main(args)


def CMDversion(_args):
  """Prints the version of this file and the hash of the code."""
  logging_utils.prepare_logging(None)
  print zip_package.generate_version()
  return 0


def main():
  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':
    # Disable itself when run under Google Chrome Remote Desktop, as it's
    # normally started at the console and starting up via Remote Desktop would
    # cause multiple bots to run concurrently on the host.
    print >> sys.stderr, (
        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')
    return 0

  # Always make the current working directory the directory containing this
  # file. It simplifies assumptions.
  os.chdir(os.path.dirname(THIS_FILE))
  # Always create the logs dir first thing, before printing anything out.
  if not os.path.isdir('logs'):
    os.mkdir('logs')

  # This is necessary so os.path.join() works with unicode path. No kidding.
  # This must be done here as each of the command take wildly different code
  # path and this must be run in every case, as it causes really unexpected
  # issues otherwise, especially in module os.path.
  fix_encoding.fix_encoding()

  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':
    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.
    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()
    if os.path.isfile('swarming_bot.1.zip'):
      os.remove('swarming_bot.1.zip')
    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')
    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]
    print >> sys.stderr, 'cmd: %s' % cmd
    return common.exec_python(cmd)

  # sys.argv[0] is the zip file itself.
  cmd = 'start_slave'
  args = []
  if len(sys.argv) > 1:
    cmd = sys.argv[1]
    args = sys.argv[2:]

  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)
  if fn:
    try:
      return fn(args)
    except ImportError:
      logging.exception('Failed to run %s', cmd)
      with zipfile.ZipFile(THIS_FILE, 'r') as f:
        logging.error('Files in %s:\n%s', THIS_FILE, f.namelist())
      return 1

  print >> sys.stderr, 'Unknown command %s' % cmd
  return 1


if __name__ == '__main__':
  sys.exit(main())

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Bot interface used in bot_config.py."""

import logging
import os
import threading
import time

import os_utilities
from utils import zip_package

THIS_FILE = os.path.abspath(zip_package.get_main_script_path())

# Method could be a function - pylint: disable=R0201


class Bot(object):
  def __init__(
      self, remote, attributes, server, server_version, base_dir,                    
      shutdown_hook):                    
    # Do not expose attributes nor remote for now, as attributes will be
    # refactored soon and remote would have a lot of side effects if used by
    # bot_config.
    self._attributes = attributes
    self._base_dir = base_dir
    self._remote = remote                    
    self._server = server
    self._server_version = server_version
    self._shutdown_hook = shutdown_hook
    self._timers = []
    self._timers_dying = False
    self._timers_lock = threading.Lock()

  @property                    
  def base_dir(self):
    """Returns the working directory.

    It is normally the current workind directory, e.g. os.getcwd() but it is
    preferable to not assume that.
    """
    return self._base_dir

  @property                    
  def dimensions(self):
    """The bot's current dimensions.

    Dimensions are relatively static and not expected to change much. They
    should change only when it effectively affects the bot's capacity to execute
    tasks.
    """
    return self._attributes.get('dimensions', {}).copy()

  @property                    
  def id(self):
    """Returns the bot's ID."""
    return self.dimensions.get('id', ['unknown'])[0]

  @property                    
  def remote(self):                    
    """XsrfClient instance to talk to the server.                    

    Should not be normally used by bot_config.py for now.                    
    """
    return self._remote                    

  @property                    
  def server(self):
    """URL of the swarming server this bot is connected to.

    It includes the https:// prefix but without trailing /, so it looks like
    "https://foo-bar.appspot.com".
    """
    return self._server

  @property                    
  def server_version(self):
    """Version of the server's implementation.

    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu
    for non-upstreamed code base:
      nnn: revision pseudo number
      hhhhhhh: git commit hash
      uuuu: username
    """
    return self._server_version

  @property                    
  def state(self):
    return self._attributes['state']

  @property                    
  def swarming_bot_zip(self):
    """Absolute path to the swarming_bot.zip file.

    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always
    return swarming_bot.zip since this is the script that must be used when
    starting up.
    """
    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')

  def post_event(self, event_type, message):
    """Posts an event to the server."""
    data = self._attributes.copy()
    data['event'] = event_type
    data['message'] = message
    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)                    

  def post_error(self, message):
    """Posts given string as a failure.

    This is used in case of internal code error. It traps exception.
    """
    logging.error('Error: %s\n%s', self._attributes, message)
    try:
      self.post_event('bot_error', message)
    except Exception:
      logging.exception('post_error(%s) failed.', message)

  def restart(self, message):
    """Reboots the machine.

    If the reboot is successful, never returns: the process should just be
    killed by OS.

    If reboot fails, logs the error to the server and moves the bot to
    quarantined mode.
    """
    self.post_event('bot_rebooting', message)
    self.cancel_all_timers()
    if self._shutdown_hook:
      try:
        self._shutdown_hook(self)
      except Exception as e:
        logging.exception('shutdown hook failed: %s', e)
    # os_utilities.restart should never return, unless restart is not happening.
    # If restart is taking longer than N minutes, it probably not going to
    # finish at all. Report this to the server.
    try:
      os_utilities.restart(message, timeout=15*60)
    except LookupError:
      # This is a special case where OSX is deeply hosed. In that case the disk
      # is likely in read-only mode and there isn't much that can be done. This
      # exception is deep inside pickle.py. So notify the server then hang in
      # there.
      self.post_error('This host partition is bad; please fix the host')
      while True:
        time.sleep(1)
    self.post_error('Bot is stuck restarting for: %s' % message)

  def call_later(self, delay_sec, callback):
    """Schedules a function to be called later (if bot is still running).

    All calls are executed in a separate internal thread, be careful with what
    you call from there (Bot object is generally not thread safe).

    Multiple callbacks can be executed concurrently. It is safe to call
    'call_later' from the callback.
    """
    timer = None

    def call_wrapper():
      with self._timers_lock:
        # Canceled already?
        if timer not in self._timers:
          return
        self._timers.remove(timer)
      try:
        callback()
      except Exception:
        logging.exception('Timer callback failed')

    with self._timers_lock:
      if not self._timers_dying:
        timer = threading.Timer(delay_sec, call_wrapper)
        self._timers.append(timer)
        timer.daemon = True
        timer.start()

  def cancel_all_timers(self):
    """Cancels all pending 'call_later' calls and forbids adding new ones."""
    timers = None
    with self._timers_lock:
      self._timers_dying = True
      for t in self._timers:
        t.cancel()
      timers, self._timers = self._timers, []
    for t in timers:
      t.join(timeout=5)
      if t.isAlive():
        logging.error('Timer thread did not terminate fast enough: %s', t)

  def update_dimensions(self, new_dimensions):
    """Called internally to update Bot.dimensions."""
    self._attributes['dimensions'] = new_dimensions

  def update_state(self, new_state):
    """Called internally to update Bot.state."""
    self._attributes['state'] = new_state



# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

"""Runs a Swarming task.

Downloads all the necessary files to run the task, executes the command and
streams results back to the Swarming server.

The process exit code is 0 when the task was executed, even if the task itself
failed. If there's any failure in the setup or teardown, like invalid packet
response, failure to contact the server, etc, a non zero exit code is used. It's
up to the calling process (bot_main.py) to signal that there was an internal
failure and to cancel this task run and ask the server to retry it.
"""

import base64
import json
import logging
import optparse
import os
import signal
import sys
import time

import xsrf_client                    
from utils import net
from utils import on_error
from utils import subprocess42
from utils import zip_package


# Path to this file or the zip containing this file.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# Sends a maximum of 100kb of stdout per task_update packet.
MAX_CHUNK_SIZE = 102400


# Maximum wait between task_update packet when there's no output.
MAX_PACKET_INTERVAL = 30


# Minimum wait between task_update packet when there's output.
MIN_PACKET_INTERNAL = 10


# Current task_runner_out version.
OUT_VERSION = 3


# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real
# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.
SIG_BREAK_OR_TERM = (
    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)


# Used to implement monotonic_time for a clock that never goes backward.
_last_now = 0


def monotonic_time():
  """Returns monotonically increasing time."""
  global _last_now
  now = time.time()
  if now > _last_now:
    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.
    _last_now = now
  return _last_now


def get_run_isolated():
  """Returns the path to itself to run run_isolated.

  Mocked in test to point to the real run_isolated.py script.
  """
  return [sys.executable, THIS_FILE, 'run_isolated']


def get_isolated_cmd(
    work_dir, task_details, isolated_result, min_free_space):
  """Returns the command to call run_isolated. Mocked in tests."""
  bot_dir = os.path.dirname(work_dir)
  if os.path.isfile(isolated_result):
    os.remove(isolated_result)
  cmd = get_run_isolated()
  cmd.extend(
      [
        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),
        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),
        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),
        '--json', isolated_result,
        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),
        '--cache', os.path.join(bot_dir, 'cache'),
        '--root-dir', os.path.join(work_dir, 'isolated'),
      ])
  if min_free_space:
    cmd.extend(('--min-free-space', str(min_free_space)))

  if task_details.hard_timeout:
    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))
  if task_details.grace_period:
    cmd.extend(('--grace-period', str(task_details.grace_period)))
  if task_details.extra_args:
    cmd.append('--')
    cmd.extend(task_details.extra_args)
  return cmd


class TaskDetails(object):
  def __init__(self, data):
    """Loads the raw data.

    It is expected to have at least:
     - bot_id
     - command as a list of str
     - data as a list of urls
     - env as a dict
     - hard_timeout
     - io_timeout
     - task_id
    """
    logging.info('TaskDetails(%s)', data)
    if not isinstance(data, dict):
      raise ValueError('Expected dict, got %r' % data)

    # Get all the data first so it fails early if the task details is invalid.
    self.bot_id = data['bot_id']

    # Raw command. Only self.command or self.inputs_ref can be set.
    self.command = data['command'] or []

    # Isolated command. Is a serialized version of task_request.FilesRef.
    self.inputs_ref = data['inputs_ref']
    self.extra_args = data['extra_args']

    self.env = {
      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()
    }
    self.grace_period = data['grace_period']
    self.hard_timeout = data['hard_timeout']
    self.io_timeout = data['io_timeout']
    self.task_id = data['task_id']


class MustExit(Exception):
  """Raised on signal that the process must exit immediately."""
  def __init__(self, sig):
    super(MustExit, self).__init__()
    self.signal = sig


def load_and_run(
    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):
  """Loads the task's metadata and execute it.

  This may throw all sorts of exceptions in case of failure. It's up to the
  caller to trap them. These shall be considered 'internal_failure' instead of
  'failure' from a TaskRunResult standpoint.
  """
  # The work directory is guaranteed to exist since it was created by
  # bot_main.py and contains the manifest. Temporary files will be downloaded
  # there. It's bot_main.py that will delete the directory afterward. Tests are
  # not run from there.
  task_result = None
  def handler(sig, _):
    logging.info('Got signal %s', sig)
    raise MustExit(sig)
  work_dir = os.path.dirname(out_file)
  try:
    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):
      if not os.path.isdir(work_dir):
        raise ValueError('%s expected to exist' % work_dir)

      with open(in_file, 'rb') as f:
        task_details = TaskDetails(json.load(f))

      task_result = run_command(
          swarming_server, task_details, work_dir, cost_usd_hour, start,
          min_free_space)
  except MustExit as e:
    # This normally means run_command() didn't get the chance to run, as it
    # itself trap MustExit and will report accordingly. In this case, we want
    # the parent process to send the message instead.
    if not task_result:
      task_result = {
        u'exit_code': None,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure':
            u'task_runner received signal %s' % e.signal,
        u'version': OUT_VERSION,
      }
  finally:
    # We've found tests to delete 'work' when quitting, causing an exception
    # here. Try to recreate the directory if necessary.
    if not os.path.isdir(work_dir):
      os.mkdir(work_dir)
    with open(out_file, 'wb') as f:
      json.dump(task_result, f)


def post_update(swarming_server, params, exit_code, stdout, output_chunk_start):
  """Posts task update to task_update.

  Arguments:
    swarming_server: XsrfRemote instance.                    
    params: Default JSON parameters for the POST.
    exit_code: Process exit code, only when a command completed.
    stdout: Incremental output since last call, if any.
    output_chunk_start: Total number of stdout previously sent, for coherency
        with the server.
  """
  params = params.copy()
  if exit_code is not None:
    params['exit_code'] = exit_code
  if stdout:
    # The output_chunk_start is used by the server to make sure that the stdout
    # chunks are processed and saved in the DB in order.
    params['output'] = base64.b64encode(stdout)
    params['output_chunk_start'] = output_chunk_start
  # TODO(maruel): Support early cancellation.
  # https://code.google.com/p/swarming/issues/detail?id=62
  resp = swarming_server.url_read_json(                    
      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)                    
  logging.debug('post_update() = %s', resp)
  if resp.get('error'):
    # Abandon it. This will force a process exit.
    raise ValueError(resp.get('error'))


def should_post_update(stdout, now, last_packet):
  """Returns True if it's time to send a task_update packet via post_update().

  Sends a packet when one of this condition is met:
  - more than MAX_CHUNK_SIZE of stdout is buffered.
  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was
    stdout.
  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.
  """
  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval


def calc_yield_wait(task_details, start, last_io, timed_out, stdout):
  """Calculates the maximum number of seconds to wait in yield_any()."""
  now = monotonic_time()
  if timed_out:
    # Give a |grace_period| seconds delay.
    if task_details.grace_period:
      return max(now - timed_out - task_details.grace_period, 0.)
    return 0.

  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  if task_details.hard_timeout:
    out = min(out, start + task_details.hard_timeout - now)
  if task_details.io_timeout:
    out = min(out, last_io + task_details.io_timeout - now)
  out = max(out, 0)
  logging.debug('calc_yield_wait() = %d', out)
  return out


def kill_and_wait(proc, grace_period, reason):
  logging.warning('SIGTERM finally due to %s', reason)
  proc.terminate()
  try:
    proc.wait(grace_period)
  except subprocess42.TimeoutError:
    logging.warning('SIGKILL finally due to %s', reason)
    proc.kill()
  exit_code = proc.wait()
  logging.info('Waiting for proces exit in finally - done')
  return exit_code


def run_command(
    swarming_server, task_details, work_dir, cost_usd_hour, task_start,
    min_free_space):
  """Runs a command and sends packets to the server to stream results back.

  Implements both I/O and hard timeouts. Sends the packets numbered, so the
  server can ensure they are processed in order.

  Returns:
    Metadata about the command.
  """
  # TODO(maruel): This function is incomprehensible, split and refactor.
  # Signal the command is about to be started.
  last_packet = start = now = monotonic_time()
  params = {
    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,
    'id': task_details.bot_id,
    'task_id': task_details.task_id,
  }
  post_update(swarming_server, params, None, '', 0)

  if task_details.command:
    # Raw command.
    cmd = task_details.command
    isolated_result = None
  else:
    # Isolated task.
    isolated_result = os.path.join(work_dir, 'isolated_result.json')
    cmd = get_isolated_cmd(
        work_dir, task_details, isolated_result, min_free_space)
    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to
    # give one 'grace_period' slot to the child process and one slot to upload
    # the results back.
    task_details.hard_timeout = 0
    if task_details.grace_period:
      task_details.grace_period *= 2

  try:
    # TODO(maruel): Support both channels independently and display stderr in
    # red.
    env = None
    if task_details.env:
      env = os.environ.copy()
      for key, value in task_details.env.iteritems():
        if not value:
          env.pop(key, None)
        else:
          env[key] = value
    logging.info('cmd=%s', cmd)
    logging.info('env=%s', env)
    try:
      proc = subprocess42.Popen(
          cmd,
          env=env,
          cwd=work_dir,
          detached=True,
          stdout=subprocess42.PIPE,
          stderr=subprocess42.STDOUT,
          stdin=subprocess42.PIPE)
    except OSError as e:
      stdout = 'Command "%s" failed to start.\nError: %s' % (' '.join(cmd), e)
      now = monotonic_time()
      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
      params['duration'] = now - start
      params['io_timeout'] = False
      params['hard_timeout'] = False
      post_update(swarming_server, params, 1, stdout, 0)
      return {
        u'exit_code': -1,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': OUT_VERSION,
      }

    output_chunk_start = 0
    stdout = ''
    exit_code = None
    had_hard_timeout = False
    had_io_timeout = False
    must_signal_internal_failure = None
    kill_sent = False
    timed_out = None
    try:
      calc = lambda: calc_yield_wait(
          task_details, start, last_io, timed_out, stdout)
      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)
      last_io = monotonic_time()
      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):
        now = monotonic_time()
        if new_data:
          stdout += new_data
          last_io = now

        # Post update if necessary.
        if should_post_update(stdout, now, last_packet):
          last_packet = monotonic_time()
          params['cost_usd'] = (
              cost_usd_hour * (last_packet - task_start) / 60. / 60.)
          post_update(swarming_server, params, None, stdout, output_chunk_start)
          output_chunk_start += len(stdout)
          stdout = ''

        # Send signal on timeout if necessary. Both are failures, not
        # internal_failures.
        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.
        if not timed_out:
          if (task_details.io_timeout and
              now - last_io > task_details.io_timeout):
            had_io_timeout = True
            logging.warning('I/O timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
          elif (task_details.hard_timeout and
              now - start > task_details.hard_timeout):
            had_hard_timeout = True
            logging.warning('Hard timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
        else:
          # During grace period.
          if not kill_sent and now >= timed_out + task_details.grace_period:
            # Now kill for real. The user can distinguish between the following
            # states:
            # - signal but process exited within grace period,
            #   (hard_|io_)_timed_out will be set but the process exit code will
            #   be script provided.
            # - processed exited late, exit code will be -9 on posix.
            logging.warning('Grace exhausted; sending SIGKILL')
            proc.kill()
            kill_sent = True
      logging.info('Waiting for proces exit')
      exit_code = proc.wait()
    except MustExit as e:
      # TODO(maruel): Do the send SIGTERM to child process and give it
      # task_details.grace_period to terminate.
      must_signal_internal_failure = (
          u'task_runner received signal %s' % e.signal)
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'signal %d' % e.signal)
    except (IOError, OSError):
      # Something wrong happened, try to kill the child process.
      had_hard_timeout = True
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'exception %s' % e)

    # This is the very last packet for this command. It if was an isolated task,
    # include the output reference to the archived .isolated file.
    now = monotonic_time()
    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
    params['duration'] = now - start
    params['io_timeout'] = had_io_timeout
    params['hard_timeout'] = had_hard_timeout
    if isolated_result:
      try:
        if ((had_io_timeout or had_hard_timeout) and
            not os.path.isfile(isolated_result)):
          # It's possible that run_isolated failed to quit quickly enough; it
          # could be because there was too much data to upload back or something
          # else. Do not create an internal error, just send back the (partial)
          # view as task_runner saw it, for example the real exit_code is
          # unknown.
          logging.warning('TIMED_OUT and there\'s no result file')
          exit_code = -1
        else:
          # See run_isolated.py for the format.
          with open(isolated_result, 'rb') as f:
            run_isolated_result = json.load(f)
          logging.debug('run_isolated:\n%s', run_isolated_result)
          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,
          # mapping time, etc) from run_isolated and push them to the server.
          if run_isolated_result['outputs_ref']:
            params['outputs_ref'] = run_isolated_result['outputs_ref']
          had_hard_timeout = (
              had_hard_timeout or run_isolated_result['had_hard_timeout'])
          params['hard_timeout'] = had_hard_timeout
          if not had_io_timeout and not had_hard_timeout:
            if run_isolated_result['internal_failure']:
              must_signal_internal_failure = (
                  run_isolated_result['internal_failure'])
              logging.error('%s', must_signal_internal_failure)
            elif exit_code:
              # TODO(maruel): Grab stdout from run_isolated.
              must_signal_internal_failure = (
                  'run_isolated internal failure %d' % exit_code)
              logging.error('%s', must_signal_internal_failure)
          exit_code = run_isolated_result['exit_code']
          if run_isolated_result.get('duration') is not None:
            # Calculate the real task duration as measured by run_isolated and
            # calculate the remaining overhead.
            params['bot_overhead'] = params['duration']
            params['duration'] = run_isolated_result['duration']
            params['bot_overhead'] -= params['duration']
            params['bot_overhead'] -= run_isolated_result.get(
                'download', {}).get('duration', 0)
            params['bot_overhead'] -= run_isolated_result.get(
                'upload', {}).get('duration', 0)
            if params['bot_overhead'] < 0:
              params['bot_overhead'] = 0
          stats = run_isolated_result.get('stats')
          if stats:
            params['isolated_stats'] = stats
      except (IOError, OSError, ValueError) as e:
        logging.error('Swallowing error: %s', e)
        if not must_signal_internal_failure:
          must_signal_internal_failure = str(e)
    # TODO(maruel): Send the internal failure here instead of sending it through
    # bot_main, this causes a race condition.
    if exit_code is None:
      exit_code = -1
    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)
    return {
      u'exit_code': exit_code,
      u'hard_timeout': had_hard_timeout,
      u'io_timeout': had_io_timeout,
      u'must_signal_internal_failure': must_signal_internal_failure,
      u'version': OUT_VERSION,
    }
  finally:
    if isolated_result:
      try:
        os.remove(isolated_result)
      except OSError:
        pass


def main(args):
  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
  parser.add_option('--in-file', help='Name of the request file')
  parser.add_option(
      '--out-file', help='Name of the JSON file to write a task summary to')
  parser.add_option(
      '--swarming-server', help='Swarming server to send data back')
  parser.add_option(
      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')
  parser.add_option('--start', type='float', help='Time this task was started')
  parser.add_option(
      '--min-free-space', type='int',
      help='Value to send down to run_isolated')

  options, args = parser.parse_args(args)
  if not options.in_file or not options.out_file or args:
    parser.error('task_runner is meant to be used by swarming_bot.')

  on_error.report_on_exception_exit(options.swarming_server)

  logging.info('starting')
  remote = xsrf_client.XsrfRemote(options.swarming_server)                    

  now = monotonic_time()
  if options.start > now:
    options.start = now

  try:
    load_and_run(
        options.in_file, remote, options.cost_usd_hour, options.start,                    
        options.out_file, options.min_free_space)                    
    return 0
  finally:
    logging.info('quitting')



# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS-schoolcms-init."""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

# version is a human-readable version number.

# version_info is a four-tuple for programmatic comparison. The first
# three numbers are the components of the version number.  The fourth
# is zero for an official release, positive for a development branch,
# or negative for a release candidate or beta (after the base version
# number has been incremented)
version = "0.0.3dev2"                    
version_info = (0, 0, 3, 12)                    

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS-handler-init.

route.
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

from ..import version as system_version
from ..db import SQL_Session, User, GroupList, Login_Session
from ..util  import webassets_react

import functools
import os
from webassets import Environment, Bundle

import tornado.web
from tornado.escape import json_encode
from tornado.options import options


class BaseHandler(tornado.web.RequestHandler):
    def initialize(self, is_api=True):
        self.is_api = is_api

        self.assets = Environment(                    
                os.path.join(os.path.dirname(__file__), '../static'),'/static')                    
        css_all = Bundle(                    
                'css/bootstrap.min.css',                    
                'css/material.min.css',                    
                Bundle('css/schoolcms.css','css/dropdown.css', filters='cssmin'),                    
                'outdatedbrowser/outdatedbrowser.min.css',                    
                output='dict/plugin.min.css')                    
        js_all = Bundle(                    
                Bundle(
                    'outdatedbrowser/outdatedbrowser.min.js',                    
                    'react-0.13.2/react-with-addons.min.js',                    
                    'js/jquery-2.1.3.min.js',                    
                    'js/bootstrap.min.js',                    
                    'js/react-bootstrap.min.js',                    
                    'js/react-mini-router.min.js',                    
                    'js/marked.min.js',                    
                    'js/material.min.js',                    
                    'js/isMobile.min.js',                    
                    'js/moment-with-locales.min.js',                    
                    'js/dropdown.js',filters='jsmin'),                    
                Bundle(
                    'schoolcms/init.jsx',                    
                    'schoolcms/mixin/*.jsx',                    
                    'schoolcms/component/*.jsx',                    
                    'schoolcms/page/*.jsx', filters=('react','jsmin')),                    
                output='dict/plugin.min.js')                    
        self.assets.register('css_all', css_all)                    
        self.assets.register('js_all', js_all)                    

    def prepare(self):
        """This method is executed at the beginning of each request.

        """
        self.sql_session = SQL_Session()

    def on_finish(self):
        """Finish this response, ending the HTTP request 
        and properly close the database.
        """
        try:
            self.sql_session.close()
        except AttributeError:
            pass

    def get_current_user(self):
        """Gets the current user logged in from the cookies
        If a valid cookie is retrieved, return a User object.
        Otherwise, return None.
        """
        session_key = self.get_secure_cookie('session_key')
        if not session_key:
            return None
        login_session = Login_Session.get_by_key(session_key, self.sql_session)
        if not login_session:
            return None
        return User.by_key(login_session.userkey, self.sql_session).scalar()

    def get_template_namespace(self):
        _ = super(BaseHandler, self).get_template_namespace()
        _['css_urls'] = self.assets['css_all'].urls()
        _['js_urls'] = self.assets['js_all'].urls()
        _['system_name'] = options.system_name
        _['SERVER_DEBUG'] = options.server_debug
        _['ip'] = self.request.remote_ip
        _['system_version'] = system_version
        _['_host'] = self.request.host
        _['_protocol'] = self.request.protocol
        
        if self.current_user:
            groups = GroupList.get_user_groups(self.current_user.key, self.sql_session)
        else:
            groups = []
        _['current_user'] = self.current_user.to_dict() if self.current_user else None
        _['current_groups'] = groups
        return _

    def page_render(self, page_json, template='app.html', **kw):
        if self.is_api:
            self.write(page_json)
        else:
            self.render(template, page_json=page_json, **kw)

    @property
    def HTTPError(self):
        return tornado.web.HTTPError
    
    def write_error(self, error, **kargs):
        self.render('app.html', page_json={})

    @staticmethod
    def authenticated(method):
        return tornado.web.authenticated(method)

    @staticmethod
    def check_is_admin_user(method):
        def wrapper(self, *args, **kwargs):
            if not self.current_user or not self.current_user.admin:
                raise self.HTTPError(403)
            return method(self, *args, **kwargs)
        return wrapper

    @staticmethod
    def check_is_group_user(group):
        def decorator(method):
            def wrapper(self, *args, **kwargs):
                if not self.is_group_user(group):
                    raise self.HTTPError(403)
                return method(self, *args, **kwargs)
            return wrapper
        return decorator

    def is_group_user(self, group):
        if not self.current_user:
            return False
        if self.current_user.admin:
            return True
        group = GroupList.check(self.current_user.key,
                                group, self.sql_session)
        return bool(group)


class AppHandler(BaseHandler):
    def get(self,  *a, **kwargs):
        self.render('app.html', page_json={})


from .indexhandler import IndexHandler
from .announcehandler import AnnounceHandler, EditAnnHandler
from .signhandler import LoginHandler, LogoutHandler
from .userhandler import GroupHandler, UserHandler
from .filehandler import FileHandler, TempUploadHandler
from .recordhandler import RecordHandler

print(os.path.join(os.path.dirname(__file__), '../../file'))

route = [
    # (r'/', AppHandler),
    # (r'/login/?', AppHandler),
    # (r'/logout/?', AppHandler),
    (r'/announce(?:/([0-9]+))?/?', AnnounceHandler, {'is_api': False}),
    (r'/announce/edit(?:/([0-9]+))?/?', EditAnnHandler, {'is_api': False}),

    # Admin
    (r'/admin/user/?', UserHandler, {'is_api': False}),

    # API
    (r'/api/?', IndexHandler),
    (r'/api/login/?', LoginHandler),
    (r'/api/logout/?', LogoutHandler),
    (r'/api/announce(?:/([0-9]+))?/?', AnnounceHandler),
    (r'/api/announce/edit(?:/([0-9]+))?/?', EditAnnHandler),
    (r'/api/announce/record/?', RecordHandler),

    # Admin API
    (r'/api/admin/group/?', GroupHandler),
    (r'/api/admin/user/?', UserHandler),

    # Att and File
    (r'/file/(.*)', FileHandler, {"path": os.path.join(os.path.dirname(__file__), '../../file')}),
    (r'/fileupload(?:/([a-zA-Z0-9]+))?/?', TempUploadHandler),
]

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""SchoolCMS announce handlers.

handlers.
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

from . import BaseHandler
from ..db import Announce, AnnTag, TempFileList, AttachmentList, Record, GroupList

import os
import shutil
import re
from markdown import markdown
from bs4 import BeautifulSoup
from datetime import datetime, timedelta

from sqlalchemy import desc

try:
    xrange
except NameError:
    xrange = range


def _to_int(s, default, mi=None, mx=None):
    if not s.isdigit():
        return default
    _n = int(s)
    if mi != None and _n < mi:
        return default
    if mx != None and _n > mx:
        return default
    return _n


class AnnounceHandler(BaseHandler):
    def get(self, ann_id):
        # Ann Page
        if ann_id:
            ann = Announce.by_id(ann_id, self.sql_session).scalar()
            if not ann:
                raise self.HTTPError(404)
            if ann.is_private and not self.is_group_user('Announcement Manager'):
                raise self.HTTPError(404)

            atts = AttachmentList.by_ann_id(ann_id, self.sql_session).all()

            self.ann_d = ann.to_dict()
            self.ann_d['tags'] = AnnTag.get_ann_tags(ann_id, self.sql_session)
            self.ann_d['atts'] = [att.to_dict() for att in atts]
            
            meta = {
                'title': self.ann_d['title'],
                'uri': '/announce/%s' % self.ann_d['id'],
                'content': BeautifulSoup(markdown(self.ann_d['content']), 'html.parser').text,
            }
            self.set_header('Cache-Control', 'max-age=300')
            self.page_render(self.ann_d, 'announce.html', meta=meta)

        # AnnIndex Page
        else:
            start = _to_int(self.get_argument('start', '0'), -1, 0, 10000000000000000000)
            step = _to_int(self.get_argument('step', '12'), 0, 1, 20)
            search = self.get_argument('search', '')
            group = self.get_argument('group', '')
            author = self.get_argument('author', '')
            hours = _to_int(self.get_argument('hours', ''), 0, 1, 23999999976)

            if start == -1 or step == 0:
                raise self.HTTPError(400)

            q = self.sql_session.query(Announce)
            if search:
                q = q.filter(Announce.full_text_search(search))
            else:
                q = q.order_by(Announce.created.desc())                    

            if author:
                q = q.filter(Announce.author_name == author)
            if group:
                q = q.filter(Announce.author_group_name == group)

            if hours:
                start_time = datetime.utcnow() - timedelta(hours=hours)
                q = q.filter(Announce.created >= start_time)                    

            if not self.is_group_user('Announcement Manager'):
                q = q.filter(Announce.is_private == False)

            total = q.count()
            q = q.offset(start).limit(step)
            anns = q.all()

            groups = self.sql_session.query(Announce.author_group_name).group_by(Announce.author_group_name).all()
            authors = self.sql_session.query(Announce.author_name).group_by(Announce.author_name).all()

            def _make_ann(ann):
                _d = ann.to_dict()
                del _d['content']
                _d['tags'] = AnnTag.get_ann_tags(ann.id, self.sql_session)
                return _d
            self.set_header('Cache-Control', 'max-age=300')
            self.page_render({
                    'anns' : [_make_ann(ann) for ann in anns],
                    'search' : search,
                    'start' : start,
                    'groups' : groups,
                    'authors' : authors,
                    'total' : total,
                })

    @BaseHandler.check_is_group_user('Announcement Manager')
    def delete(self, ann_id):
        if not ann_id:
            raise self.HTTPError(404)
        if not Announce.by_id(ann_id, self.sql_session).scalar():
            raise self.HTTPError(404)

        q = AttachmentList.by_ann_id(ann_id, self.sql_session)
        old_atts = q.all()
        for old_att in old_atts:
            shutil.rmtree('file/%s' % old_att.key)
        q.delete()
        Announce.by_id(ann_id, self.sql_session).delete()

        self.write({'success':True})


tag_re = re.compile(r'^[^\s,][^,]*[^\s,]$')

class EditAnnHandler(BaseHandler):
    def prepare(self):
        super(EditAnnHandler, self).prepare()
        self._ = {
            'id': '',
            'title': '',
            'content': '',
            'is_private': False,
            'group': '',
            'tmpatts': [],
            'atts': [],
            'tags': [],
            'alert': '',
        }

    @BaseHandler.check_is_group_user('Announcement Manager')
    def get(self, ann_id):
        if ann_id:
            ann = Announce.by_id(ann_id, self.sql_session).scalar()
            if not ann:
                raise self.HTTPError(404)
            self._['ann_id'] = ann_id
            self._['title'] = ann.title
            self._['content'] = ann.content
            self._['is_private'] = ann.is_private
            atts = AttachmentList.by_ann_id(ann_id, self.sql_session).all()
            self._['tags'] = AnnTag.get_ann_tags(ann_id, self.sql_session)
            self._['atts'] = [att.to_dict() for att in atts]
            if self.is_group_user(ann.author_group_name):
                self._['group'] = ann.author_group_name

        self._['user_groups'] = GroupList.get_user_groups(self.current_user.key, self.sql_session)

        self.page_render(self._)

    @BaseHandler.check_is_group_user('Announcement Manager')
    def post(self, ann_id):
        self.ann_id = ann_id if ann_id else ''
        del ann_id
        del self._['atts']
        self._['id'] = self.ann_id
        self._['title'] = self.get_argument('title', '')
        self._['content'] = self.get_argument('content', '')
        self.group = self.get_argument('group', '')
        self._['is_private'] = bool(self.get_argument('is_private', ''))
        self._['tags'] = self.get_arguments('tag')
        self.attkeys = self.get_arguments('attachment')

        # check ann and att
        if not self.check_ann():
            self._['tmpatts'] = [att.to_dict() for att in self._['tmpatts']]
            return self.write(self._)

        self._['author_name'] = self.current_user.name

        if self.ann_id:
            Announce.by_id(self.ann_id, self.sql_session).update({
                    'title' : self._['title'],
                    'content' : self._['content'],
                    'author_group_name' : self._['author_group_name'],
                    'author_name' : self._['author_name'],
                    'is_private' : self._['is_private'],
                })
            Record.add('update', self.ann_id, self.sql_session)
        else:
            new_ann = Announce(**self._)
            self.sql_session.add(new_ann)
            self.sql_session.flush()
            self.sql_session.refresh(new_ann)
            self.ann_id = new_ann.id
            Record.add('new', self.ann_id, self.sql_session)

        self.parse_att()
        self.parse_tag()

        self.sql_session.commit()
        self.write({'success': True,'id': self.ann_id})

    def check_ann(self):
        for i in xrange(len(self.attkeys)):
            if self.attkeys[i]:
                q = self.sql_session.query(TempFileList)
                q = q.filter(TempFileList.key == self.attkeys[i])
                try:
                    new_tmpatt = q.one()
                    if new_tmpatt.author_key != self.current_user.key:
                        raise ValueError('user key error!')
                    if not os.path.exists('file/tmp/%s' % new_tmpatt.key):
                        raise ValueError('att lost!')
                    self._['tmpatts'].append(new_tmpatt)
                except ValueError:
                    self._['alert'] = '!'
        if self._['alert']:
            return False

        if not self._['title']:
            self._['alert'] = ''
            return False
        elif not self._['content']:
            self._['alert'] = ''
            return False
        elif not self.group or not GroupList.check(self.current_user.key, self.group, self.sql_session):
            self._['alert'] = ''
            return False

        self._['author_group_name'] = self.group

        return True

    def parse_att(self):
        for att in self._['tmpatts']:
            os.makedirs('file/%s' % att.key)
            os.rename('file/tmp/%s' % att.key, 'file/%s/%s' % (att.key, att.filename))
            new_att = AttachmentList(key=att.key, ann_id=self.ann_id, 
                                    content_type=att.content_type, filename=att.filename)
            self.sql_session.add(new_att)
            TempFileList.by_key(att.key, self.sql_session).delete()

    def parse_tag(self):
        for i in xrange(len(self._['tags'])):
            self._['tags'][i] = self._['tags'][i][:40:]
            if not tag_re.match(self._['tags'][i]):
                del self._['tags'][i]

        old_tags = AnnTag.get_ann_tags(self.ann_id, self.sql_session)
        new_tag_set = set(self._['tags'])
        old_tag_set = set(old_tags)

        add_set = new_tag_set - old_tag_set
        delete_set = old_tag_set - new_tag_set

        for tag in add_set:
            self.sql_session.add(AnnTag(self.ann_id, tag))
        for tag in delete_set:
            AnnTag.by_tag(self.ann_id, tag, self.sql_session).delete()

import os.path

import tornado.web
import tornado.httpserver
import tornado.options
import tornado.ioloop

from config.MockConfigDAO import MockConfigDAO
cfgDAO = MockConfigDAO()

from tornado.options import define, options
define("port", default=8080, help="Server port", type=int)

class TVServer(tornado.web.Application):
    ''' Configure server '''
    def __init__(self):
        handlers = [
            (r"/", ReqHandler),
            (r"/login", LoginHandler),
            (r"/logout", LogoutHandler),
            (r"/config", ConfigHandler),
            (r"/(\w+)", ReqHandler),
        ]
        mainDir = os.path.dirname(__file__)
        settings = dict(
            xsrf_cookie = True,                    
            cookie_secret = "bls9+x7PT5GIbaBuKzsGOecL9SG7KUmEh6rNbMYTpfk=",
            login_url = "/login",
            template_path = os.path.join(mainDir, "templates/myStyle"),
            static_path = os.path.join(mainDir, "templates/myStyle/static"),
        )
        tornado.web.Application.__init__(self, handlers, **settings)

class PersonalisedRequestHandler(tornado.web.RequestHandler):
    ''' This class specifies how we store the user identity '''

    def get_current_user(self):
        return self.get_secure_cookie("user")

    def delete_session_cookie(self):
        self.clear_cookie("user");

class LoginHandler(PersonalisedRequestHandler):
    ''' Show the login page and handle authentication process '''

    def get(self):
        if not self.current_user:
            self.render("../login.html")
            return
        self.redirect("/")

    def post(self):
        self.set_secure_cookie("user", self.get_argument("username"))
        self.redirect("/")

class LogoutHandler(PersonalisedRequestHandler):
    ''' End the user's current session '''

    def get(self):
        self.delete_session_cookie()
        self.redirect("/")

class ConfigHandler(PersonalisedRequestHandler):
    ''' Handle the configuration page for the streaming '''

    @tornado.web.authenticated
    def get(self):
        self.render("../config.html", cfg = cfgDAO.loadConfig())

    def post(self):
        cfgDAO.persistConfig(self.get_argument("AudioCodec"),
                          self.get_argument("AudioRate"),
                          self.get_argument("VideoCodec"),
                          self.get_argument("VideoRate"),
                          self.get_argument("VideoSize"),
                          self.get_argument("StreamEncryption"),
                          self.get_argument("GenEncryptionKey"))
        self.render("../config.html", cfg = cfgDAO.loadConfig())

class ReqHandler(PersonalisedRequestHandler):
    ''' Handle get/post requests for the TVOnline website '''

    @tornado.web.authenticated
    def get(self, page="home"):
        self.render("../" + page + ".html")

    def get_error_html (self, status_code, **kwargs):
        self.render("../error.html")

# Launch server
if __name__ == "__main__":
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(TVServer())
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

#!/usr/bin/env python
#
# Copyright 2010 Brett Slatkin, Nathan Naze
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Base class and functionality for request handlers, common utilities."""

import cgi
import json
import logging
import os
import traceback

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template

# Local libs
import config
import models


class Error(Exception):
    """Base class for exceptions."""

class MissingParameterError(Error):
    """A required parameter was missing."""

class BadParameterValueError(Error):
    """A parameter has a bad type."""

class NotAuthorizedError(Error):
    """The user is not authorized to do this action."""

class TopicShardError(Error):
    """Topic shards cannot be used in this way."""

class PostError(Error):
    """A posting could not be made."""


class BaseHandler(webapp.RequestHandler):
    """Base handler for handling web requests."""

    # Allow requests with the GET verb.
    get_enabled = True

    # Allow requests with the POST verb.
    post_enabled = True

    def _require_xsrf_token(self):
        # TODO(bslatkin): Rotate the token periodically.
        if 'xsrf_token' not in self.session:
            self.session['xsrf_token'] = models.human_uuid()
            self.session.save()

    def get(self, *args):
        if not self.get_enabled:
            self.response.set_status(405)
            return
        self.session = self.request.environ['beaker.session']
        self._require_xsrf_token()
        self.handle_request(*args)

    def post(self, *args):
        if not self.post_enabled:
            self.response.set_status(405)
            return

        self.session = self.request.environ['beaker.session']
        self._require_xsrf_token()

        found_token = self.request.get('xsrf_token')
        if found_token != self.session['xsrf_token']:
            logging.warning('XSRF token invalid! session=%r', self.session)
            self.response.headers['X-Why'] = 'Bad XSRF token'
            self.response.set_status(403)
            return

        self.handle_request(*args)

    def handle_request(self, *args):
        raise NotImplementedError()

    def get_required(self,
                     name,
                     type_constructor,
                     default=None,
                     repeated=False,
                     html_escape=False):
        """Retrieves a required parameter with the given name and default."""
        value_list = self.request.get_all(name)

        if default is None:
            if not value_list:
                raise MissingParameterError(
                    'Parameter "%s" is required' % name)
        else:
            value_list.append(default)

        out_list = []
        for value in value_list:
            try:
                value = type_constructor(value)
            except ValueError:
                raise BadParameterValueError(
                    'Parameter "%s" has an invalid value: %r' % (name, value))

            if html_escape:
                value = cgi.escape(value)

            out_list.append(value)

        if repeated:
            return out_list
        return out_list[0]

    def require_active_login(self):
        """Raises an error if the user does not have an active connection."""
        import presence     # Break circular import
        login_record = models.LoginRecord.get_by_id(self.user_id)
        if not presence.only_active_users(login_record):
                raise NotAuthorizedError(
                    'Connection no longer valid, must relogin')
        return login_record

    def render(self, template_name, context=None):
        """Renders the given template and context."""
        js_mode = 'compiled'                    
        if config.debug and config.is_dev_appserver:                    
            js_mode = self.request.get('js_mode', 'raw')                    

        my_context = {
            'cache_buster': config.version_id,
            'host_url': self.request.host_url,
            'js_mode': js_mode,                    
            'page_name': 'base',
            'site_name': config.site_name,
            'xsrf_token': self.session['xsrf_token'],                    
        }
        if context:
            my_context.update(context)

        self.response.out.write(
            template.render('templates/' + template_name, my_context))


class BaseRpcHandler(BaseHandler):
    """Base handler for turning responses into JSON.

    Sub-classes should override the handle() method and stuff their response
    parameters into self.json_response. In the event an exception is raised
    it will be returned to the caller as 'error_class' and 'error_detail'
    parameters in the JSON response with a 500 response. In the successful case
    the response will be JSON with a 200 response.

    Properties:
        all_shards: List of all shards this user is logged into.
        shard: The current logged in shard, set when 'require_shard' is True.
    """

    # By default RPCs are post only.
    get_enabled = False

    # Whether or not to require user log-in to the shard they assert.
    require_shard = False

    # Do not write the output JSON or content-type to the response.
    raw_response = False    # TODO(bslatkin): Refactor this to use BaseHandler

    def handle_request(self, *args):
        self.session = self.request.environ['beaker.session']
        if 'shards' in self.session:
            self.all_shards = self.session['shards']
        else:
            self.all_shards = []
        if self.require_shard:
            self.shard = self._verify_shard_login()
            self.user_id = self.all_shards[self.shard]
        else:
            self.shard = None
            self.user_id = None

        self.json_response = {}
        try:
            self.handle(*args)
        except Exception, e:
            logging.exception('Error encountered during RPC')
            self.json_response['errorClass'] = e.__class__.__name__
            self.json_response['errorDetail'] = str(e)
            self.json_response['errorTraceback'] = traceback.format_exc()
            self.response.set_status(500)
        finally:
            if not self.raw_response:
                self.response.headers['Content-Type'] = 'text/javascript'
                self.response.out.write(json.dumps(self.json_response))

    def handle(self):
        raise NotImplementedError('Override in sub-class')

    def _verify_shard_login(self):
        """Verifies the user is logged into the shard they assert, returns it.
        """
        shard = self.get_required('shard', str)
        if 'shards' not in self.session:
            raise NotAuthorizedError('Your cookie has no valid shards')
        if shard not in self.session['shards']:
            raise NotAuthorizedError('You may not access shard %s' % shard)
        return shard

# -*- coding: utf-8 -*-

'''Make Pyramid play ball with AngularJS to achieve CSRF protection.

    To start using this module, include it in your application configuration::

        # Integrate with Angular for CSRF protection:
        config.include('bag.web.pyramid.angular_csrf')

    For any GET requests, this causes the response to have a
    cookie containing the CSRF token, just as Angular 1.3.x wants it.

    In subsequent AJAX requests (with verbs different than GET),
    Angular will send the token back in a header 'X-XSRF-Token'.
    Now you have 2 choices for view configuration.

    First choice: the view_config argument
    ======================================

    **WARNING: The 1st choice isn't working. If you find out why, a pull
    request would be extremely welcome.**

    The first choice is easiest:
    You can protect the corresponding Pyramid views simply by
    adding the ``check_csrf=True`` parameter to view_config().

    But to achieve this, we have to monkeypatch Pyramid.
    By default Pyramid uses a header named 'X-CSRF-Token'.
    We change it to 'X-XSRF-Token', which is preferred by Angular.
    Just so you know, the monkeypatch works well against Pyramid 1.5.1.
    To do this, run::

        from bag.web.pyramid.angular_csrf import monkeypatch_pyramid_csrf_check
        monkeypatch_pyramid_csrf_check()

    ...and now you can use the ``check_csrf=True`` argument.

    The disadvantages of this approach are, of course, monkeypatching,
    and the fact that when the CSRF token is missing, Pyramid returns 404,
    which in my opinion isn't accurate  404 tells me the URL is incorrect,
    when in fact there's only a missing header. Enters the second choice:

    Second choice: the csrf() decorator
    ===================================

    Decorate your view with @csrf and it will raise HTTPForbidden when
    the token is missing, which seems better. Usage::

        from bag.web.pyramid.angular_csrf import csrf

        @view_config(context=User, permission='edit_user',
                     accept='application/json', request_method='PUT',
                     renderer='json')
        @csrf
        def view_that_changes_a_user(context, request):
            ...

    Although I haven't tested this, I hear one can also decorate a class:

        @view_defaults(decorator=csrf)
        class SomeView(object):
            ...

    https://docs.angularjs.org/api/ng/service/$http
'''

from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
from functools import wraps
from pyramid.events import NewResponse
from pyramid.httpexceptions import HTTPForbidden
from . import _

COOKIE_NAME = 'XSRF-TOKEN'
HEADER_NAME = 'X-XSRF-Token'  # different from Pyramid's default 'X-CSRF-Token'


def on_GET_request_setup_csrf_cookie(ev):
    '''If this is the first GET request, we set the CSRF token in a
        JavaScript readable session cookie called XSRF-TOKEN.
        Angular will pick it up for subsequent AJAX requests.
        '''
    if ev.request.method == 'GET':  # and not 'static' in ev.request.path:
        token = ev.request.session.get_csrf_token()
        if ev.request.cookies.get('XSRF-TOKEN') != token:
            ev.response.set_cookie(COOKIE_NAME, token)                    


# Option 1 is not working  :(
def monkeypatch_pyramid_csrf_check():
    from pyramid import session

    def check_csrf_token(request, token='csrf_token', header=HEADER_NAME,
                         raises=True):
        supplied_token = request.params.get(token, request.headers.get(header))
        if supplied_token != request.session.get_csrf_token():
            if raises:
                raise session.BadCSRFToken('check_csrf_token(): Invalid token')
            return False
        return True

    session.check_csrf_token = check_csrf_token


# Option 2: decorator
def csrf(fn):
    @wraps(fn)
    def wrapper(context, request):
        token = request.headers.get(HEADER_NAME)
        session_token = request.session.get_csrf_token()
        # print(token, session_token)
        if token == session_token:
            return fn(context, request)
        else:
            raise HTTPForbidden(_(
                'Invalid CSRF token. Please try reloading the page.'))
    return wrapper


def includeme(config):
    config.add_subscriber(on_GET_request_setup_csrf_cookie, NewResponse)

#!/usr/bin/env python
# coding=utf-8

from webapp.web import BaseHandler
from model import dbapi


class PasswordHandler(BaseHandler):

    def check_xsrf(self):
        if self.check_xsrf_cookie() == False:
            self.clear_cookies()
            return self.redirect("/")                    

    def check(self):
        #email = self.get_secure_cookie("email")
        sid = self.get_secure_cookie('sid')
        if not sid:
            return False
        email = self.session.get('email')
        
        user = dbapi.User()
        if email and user.get_user(email) == 0:
            profile = user.get_user_all(email)
            if profile:
                self.time = profile[4]
                self.email = email
                return True
        else:
            self.clear_cookies()
            return False

    def get(self, error=""):
        self.check()
        params = {
            'error_info': error,
            "name": self.email,
            "xsrf_token": self.xsrf_from_html()}
        body = self.wrap_html('templates/pwdchange.html', params)
        return self.write(body)

    def post(self):
        #self.check()
        if self.check() == False:
            return self.redirect("/")                    
        self.check_xsrf()                    

        oldpassword = self.get_arg('oldpassword')
        password = self.get_arg('password')
        password2 = self.get_arg('password2')
        
        user = dbapi.User()
        error = ""

        if password == password2 and user.check_user(self.email, oldpassword) != -1:
            result = user.update_password(self.email, password)
            if result != -1:
                error = "Update Password Successfully"
            else:
                error = "Update failure, try again later"
        else:
            if password != password2:
                error = "new password inconsistent"
            else:
                error = "old password incorrect"

        return self.get(error)

#!/usr/bin/env python
# coding=utf-8

import hashlib

from webapp.web import BaseHandler
from model import dbapi


class RegisterHandler(BaseHandler):

    def check_xsrf(self):
        if self.check_xsrf_cookie() == False:
            error = "xsrf invalid"                    
            self.get(error)                    

    def get(self, error=""):
        xsrf_token = self.xsrf_from_html()
        params = {'error_info': error, 'xsrf_token': xsrf_token}
        body = self.wrap_html('templates/register.html', params)
        return self.write(body)

    def post(self):
        self.check_xsrf()                    
        email = self.get_arg('email')
        email = email.strip()
        password = self.get_arg('password')
        password2 = self.get_arg('password2')

        user = dbapi.User()
        error = ""
        if email and password == password2:
            if user.get_user(email) == 0:
                error = "user already exist"
            else:
                result = user.insert_user(email, password)
                if result != -1:
                    #self.set_secure_cookie('email', str(email))
                    # change to sssion
                    m = hashlib.md5()
                    m.update(email)
                    email_md5 = m.hexdigest()
                    self.session["email"] = email
                    self.session["email_md5"] = email_md5
                    self.set_secure_cookie('sid', self.session.session_id)

                    return self.redirect("/user")
                else:
                    error = "insert falure, try again later"
        else:
            if password != password2:
                error = "password inconsistent"
            else:
                error = "missing argument"

        return self.get(error)                    

#!/usr/bin/env python
# coding=utf-8

import os
import hashlib
import imghdr

from webapp.web import BaseHandler
from model import dbapi

MAX_FILE_SIZE = 5000000  # upload file size setting < 5MB


class UploadHandler(BaseHandler):

    def check_xsrf(self):
        if self.check_xsrf_cookie() == False:
            return self.redirect("ftypeerror")                    

    def check(self):
        #email = self.get_secure_cookie("email")
        sid = self.get_secure_cookie('sid')
        if not sid:
            return False
        email = self.session.get('email')
        
        user = dbapi.User()
        if email and user.get_user(email) == 0:
            profile = user.get_user_all(email)
            if profile:
                self.id = profile[0]
                self.time = profile[4]
                self.email = email
                return True
        else:
            self.clear_cookies()
            return False

    def get_filesize(self, file):
        file.seek(0, 2)
        size = file.tell()
        file.seek(0)
        return size

    def post(self):
        self.check_xsrf()                     
        if self.check() == False:
            return self.redirect("/")
        fileitem = self.request.files["filename"]
        if fileitem.filename:
            #fn = os.path.basename(fileitem.filename)
            filetype = imghdr.what(fileitem.file)
            filesize = self.get_filesize(fileitem.file)
            if filesize > MAX_FILE_SIZE:
                return self.redirect("/ftypeerror")
            if filetype is "jpeg" or filetype is "png" or filetype is "gif":
                m = hashlib.md5()
                m.update(self.email)
                email_md5 = m.hexdigest()
                path = "images/" + email_md5
                path = os.path.join(os.path.dirname(__file__), "..", path)
                open(path, "wb").write(fileitem.file.read())
                return self.redirect("/user")
            else:
                return self.redirect("/ftypeerror")
        else:
            return self.redirect("/user")

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

import logging
from datetime import datetime

from pylons.i18n import _
import formencode

from openid.consumer.consumer import Consumer, SUCCESS, DiscoveryFailure
from openid.extensions import sreg, ax

from adhocracy.lib.base import *
from adhocracy.lib.openidstore import create_consumer
import adhocracy.lib.util as util
import adhocracy.model.forms as forms

log = logging.getLogger(__name__)


AX_MAIL_SCHEMA = u'http://schema.openid.net/contact/email'
AX_MEMBERSHIP_SCHEMA = u'http://schema.liqd.de/membership/signed/'

class OpenIDInitForm(formencode.Schema):
    openid = validators.OpenId(not_empty=False, if_empty=None)
    
class OpenIDUsernameForm(formencode.Schema):
    login = formencode.All(validators.PlainText(),
                           forms.UniqueUsername())

class OpenidauthController(BaseController):
    
                
    def _create(self, user_name, email, identity):
        """
        Create a user based on data gathered from OpenID
        """
        user = model.User.create(user_name, email, locale=c.locale, 
                                 openid_identity=identity)
        # trust provided email:
        user.activation_code = None
        model.meta.Session.commit()
        event.emit(event.T_USER_CREATE, user)
        return user

    def _login(self, user):
        """
        Raw login giving severe headaches to repoze.who, repoze.what and any
        bystanding squirrels. 
        """
        identity = {
            'userdata': '',
            'repoze.who.userid': str(user.user_name),
            'timestamp': int(datetime.utcnow().strftime("%s")),
            'user': user,
                    }
        
        # set up repoze.what
        authorization_md = request.environ['repoze.who.plugins']['authorization_md']
        authorization_md.add_metadata(request.environ, identity)
                  
        auth_tkt = request.environ['repoze.who.plugins']['auth_tkt']
        header = auth_tkt.remember(request.environ, identity)
        response.headerlist.extend(header)
                
        if c.instance and not user.is_member(c.instance):
            redirect_to(h.instance_url(c.instance, 
                        path="/instance/join/%s?%s" % (c.instance.key, 
                                                       h.url_token())))
        redirect_to("/")        
            
    def _failure(self, openid, message):
        """
        Abort an OpenID authenication attempt and return to login page, 
        giving an error message at the openid field.
        """
        log.info("OpenID: %s - Error: %s" % (openid, message))
        if c.user:
            h.flash(message)
            return redirect_to("/user/%s/edit" % str(c.user.user_name))
        else:
            loginhtml = render("/user/login.html")
            return formencode.htmlfill.render(loginhtml, 
                defaults = {'openid': openid}, 
                errors = {'openid': message})
    

    def __before__(self):
        self.openid_session = session.get("openid_session", {})
    
    @validate(schema=OpenIDInitForm(), form="foo", post_only=False, on_get=True)
    def init(self):
        self.consumer = create_consumer(self.openid_session)
        openid = self.form_result.get("openid")
        try:
            if not openid: raise ValueError(_("No OpenID given!"))
            authrequest = self.consumer.begin(openid)
        except Exception, e:
            return self._failure(openid, str(e))
        
        if not c.user and not model.OpenID.by_id(openid):                    
            axreq = ax.FetchRequest(h.instance_url(c.instance, path='/openid/update'))
            axreq.add(ax.AttrInfo(AX_MAIL_SCHEMA, alias="email", required=True))
            authrequest.addExtension(axreq)

            sreq = sreg.SRegRequest(required=['nickname'], optional=['email'])
            authrequest.addExtension(sreq)    
        
        redirecturl = authrequest.redirectURL(h.instance_url(c.instance, path='/'), 
                                    return_to=h.instance_url(c.instance, path='/openid/verify'), 
                                    immediate=False)
        session['openid_session'] = self.openid_session
        session.save()
        return redirect_to(redirecturl)
    
    @ActionProtector(has_permission("user.edit"))
    def connect(self):
        if not c.user:
            h.flash(_("No OpenID was entered."))
            redirect_to("/login")
        return render("/openid/connect.html")   
    
    @RequireInternalRequest()
    @ActionProtector(has_permission("user.edit"))
    def revoke(self, id):
        openid = model.OpenID.by_id(id)
        if not openid:
            abort(404, _("No OpenID with ID '%s' exists.") % id)
        page_user = openid.user
        if not (page_user == c.user or h.has_permission("user.manage")): 
            abort(403, _("You're not authorized to change %s's settings.") % id)
        openid.delete()
        model.meta.Session.commit()
        return redirect_to("/user/%s/edit" % str(page_user.user_name))

    def verify(self):
        self.consumer = create_consumer(self.openid_session)
        info = self.consumer.complete(request.params, h.instance_url(c.instance, path='/openid/verify'))
        if not info.status == SUCCESS:
            return self._failure(info.identity_url, _("OpenID login failed."))
        
        email = None
        user_name = None
            
        # evaluate Simple Registration Extension data
        srep = sreg.SRegResponse.fromSuccessResponse(info)
        if srep:
            user_name = srep.get('nickname').strip()
            if srep.get('email'):
                email = srep.get('email')
                    
        # evaluate Attribute Exchange data        
        # TBD: AXSCHEMA friendlyName 
        # TBD: SignedMembership
        axrep = ax.FetchResponse.fromSuccessResponse(info)
        if axrep:
            args = axrep.getExtensionArgs()
            if args.get('type.ext0') == AX_MAIL_SCHEMA:
                email = args.get('value.ext0.1')
            
        if 'openid_session' in session:
            del session['openid_session']
                
        oid = model.OpenID.find(info.identity_url)
        if oid:
            if c.user:
                if oid.user == c.user:
                    return self._failure(info.identity_url, 
                        _("You have already claimed this OpenID."))
                else:
                    return self._failure(info.identity_url,
                        _("OpenID %s already belongs to %s.") 
                        % (info.identity_url, oid.user.name))
            else: 
                self._login(oid.user)
                # returns
        else:
            if c.user:
                oid = model.OpenID(unicode(info.identity_url), c.user)
                model.meta.Session.add(oid)
                model.meta.Session.commit()
                redirect_to("/user/%s/edit" % str(c.user.user_name))
            else:
                try:
                    forms.UniqueUsername(not_empty=True).to_python(user_name)
                except:
                    session['openid_req'] = (info.identity_url, user_name, email)
                    session.save()
                    redirect_to('/openid/username')
                user = self._create(user_name, email, info.identity_url)
                self._login(user)
                    
        return self._failure(info.identity_url, _("Justin Case has entered the room."))

    @validate(schema=OpenIDUsernameForm(), form="username", post_only=True)
    def username(self):
        """
        Called when the nickname proposed by the OpenID identity provider is 
        unavailable locally. 
        """
        if 'openid_req' in session:
            (openid, c.user_name, email) = session['openid_req']
            if request.method == "POST":
                c.user_name = self.form_result.get('login')
                c.user_name = forms.UniqueUsername(not_empty=True).to_python(c.user_name)
                if c.user_name:
                    user = self._create(c.user_name, email, openid)
                    del session['openid_req']
                    self._login(user)
            return render('/openid/username.html')
        else:
            redirect_to('/register')

"""
XSRF is Cross-Site Request Forgery, where an attacker has a user follow a link that triggers an 
action on a site which the user did not intentionally want to perform (i.e. vote in 
a certain way). To prevent this, some actions are only possible if authorized via HTTP or if a
modtoken - a shared SHA1 hash - is included.  
"""

import random
import hashlib
from urlparse import urlparse
from decorator import decorator

from pylons import session, request, config
from pylons.controllers.util import abort
from pylons.i18n import _

def RequireInternalRequest(methods=['POST', 'GET', 'PUT', 'DELETE']):
    """
    XSRF Spoof Filter
    
    TODO: There is still a scenario in which an attacker opens an adhocracy 
    page in an iframe, extracts a valid modtoken via javascript and uses this
    token to execute the request. 
    """
    def _decorate(f, *a, **kw):
        def check():
            if not request.method in methods:
                return True
            if not request.environ.get("AUTH_TYPE") == "cookie":
                return True
            if config.get('skip_authentication'):
                return True
            
            if request.environ.get('HTTP_REFERER'):           
                ref_url = urlparse(request.environ.get('HTTP_REFERER'))
                ref_host = ref_url.hostname
                if ref_url.port:
                    ref_host += ":" + str(ref_url.port)
            
                if ref_host.endswith(request.environ['adhocracy.domain']):
                    if request.method != 'GET':                    
                        return True
            
            if request.method == 'GET' and has_token():                    
                return True
                       
            return False
        if check():
            return f(*a, **kw)
        else:
            abort(403, _("Action failed. You were probably trying to re-perform " +
                         "an action after using your browser's 'Back' button. This " +
                         "is prohibited for security reasons.")) 
    return decorator(_decorate)

def make_token():
    tokens = session.get('modtokens', [])
    
    token = None
    if len(tokens) < 100:
        token = hashlib.sha1(str(random.random())).hexdigest()
    else:
        token = tokens[-1]
        
    tokens.append(token)
    session['modtokens'] = tokens
    session.save()
    return token

def url_token():
    return "_csrftoken=%s" % make_token()

def field_token():
    return '<input name="_csrftoken" type="hidden" value="%s" />' % make_token() 

def has_token():
    if request.params.get('_csrftoken', None) in session['modtokens']:
        tokens = session['modtokens']
        tokens.remove(request.params.get('_csrftoken'))
        session['modtokens'] = tokens
        session.save()
        return True
    return False

from datetime import datetime

import logging

from sqlalchemy import Table, Column, Integer, Unicode, ForeignKey, DateTime, Binary, func, or_ 
 
import meta 

log = logging.getLogger(__name__)

openid_table = Table('openid', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('identifier', Unicode(255), nullable=False, index=True) 
    )


oid_nonces = Table('oid_nonces', meta.data,
    Column('server_url', Binary, nullable=False),
    Column('timestamp', Integer, primary_key=True),
    Column('salt', Unicode(40), nullable=False, index=True)
    )

    
oid_associations = Table('oid_associations', meta.data,
    Column('server_url', Binary, nullable=False),
    Column('handle', Unicode(255), nullable=False, index=True),
    Column('secret', Binary, nullable=False),
    Column('issued', Integer, primary_key=True),
    Column('lifetime', Integer, primary_key=True),
    Column('assoc_type', Unicode(64), nullable=False)
    )
    

class OpenID(object):
    
    def __init__(self, identifier, user):
        self.identifier = identifier
        self.user = user
    
    
    @classmethod
    def find(cls, identifier, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.identifier==identifier)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time==None,
                                 OpenID.delete_time>datetime.utcnow()))
            return q.one()                    
        except Exception, e:
            log.warn("find(%s): %s" % (identifier, e))
            return None
        
    
    @classmethod
    def by_id(cls, id, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.id==id)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time==None,
                                 OpenID.delete_time>datetime.utcnow()))
            return q.one()                    
        except Exception:
            log.exception("by_id(%s)" % id)
            return None
            
    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time  
    
    
    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time
            
            
    def __repr__(self):
        return u"<OpenID(%d,%s,%s)>" % (self.id, 
                                        self.identifier,
                                        self.user.user_name)  

import logging
from datetime import datetime

from pylons.i18n import _
import formencode

from openid.consumer.consumer import Consumer, SUCCESS, DiscoveryFailure
from openid.extensions import sreg, ax

from adhocracy.lib.base import *
from adhocracy.lib.openidstore import create_consumer
import adhocracy.lib.util as util
import adhocracy.model.forms as forms

log = logging.getLogger(__name__)


AX_MAIL_SCHEMA = u'http://schema.openid.net/contact/email'
AX_MEMBERSHIP_SCHEMA = u'http://schema.liqd.de/membership/signed/'

class OpenIDInitForm(formencode.Schema):
    openid = validators.OpenId(not_empty=False, if_empty=None)
    
class OpenIDUsernameForm(formencode.Schema):
    login = formencode.All(validators.PlainText(),
                           forms.UniqueUsername())

class OpenidauthController(BaseController):
    
                
    def _create(self, user_name, email, identity):
        """
        Create a user based on data gathered from OpenID
        """
        user = model.User.create(user_name, email, locale=c.locale, 
                                 openid_identity=identity)
        # trust provided email:
        user.activation_code = None
        model.meta.Session.commit()
        event.emit(event.T_USER_CREATE, user)
        return user

    def _login(self, user):
        """
        Raw login giving severe headaches to repoze.who, repoze.what and any
        bystanding squirrels. 
        """
        identity = {
            'userdata': '',
            'repoze.who.userid': str(user.user_name),
            'timestamp': int(datetime.utcnow().strftime("%s")),
            'user': user,
                    }
        
        # set up repoze.what
        authorization_md = request.environ['repoze.who.plugins']['authorization_md']
        authorization_md.add_metadata(request.environ, identity)
                  
        auth_tkt = request.environ['repoze.who.plugins']['auth_tkt']
        header = auth_tkt.remember(request.environ, identity)
        response.headerlist.extend(header)
                
        if c.instance and not user.is_member(c.instance):
            redirect_to(h.instance_url(c.instance, 
                        path="/instance/join/%s?%s" % (c.instance.key, 
                                                       h.url_token())))
        redirect_to("/")        
            
    def _failure(self, openid, message):
        """
        Abort an OpenID authenication attempt and return to login page, 
        giving an error message at the openid field.
        """
        log.info("OpenID: %s - Error: %s" % (openid, message))
        if c.user:
            h.flash(message)
            return redirect_to("/user/%s/edit" % str(c.user.user_name))
        else:
            loginhtml = render("/user/login.html")
            return formencode.htmlfill.render(loginhtml, 
                defaults = {'openid': openid}, 
                errors = {'openid': message})
    

    def __before__(self):
        self.openid_session = session.get("openid_session", {})
    
    @validate(schema=OpenIDInitForm(), form="foo", post_only=False, on_get=True)
    def init(self):
        self.consumer = create_consumer(self.openid_session)
        openid = self.form_result.get("openid")
        try:
            if not openid: raise ValueError(_("No OpenID given!"))
            authrequest = self.consumer.begin(openid)
        except Exception, e:
            return self._failure(openid, str(e))
        
        if not c.user and not model.OpenID.by_id(openid):                    
            axreq = ax.FetchRequest(h.instance_url(c.instance, path='/openid/update'))
            axreq.add(ax.AttrInfo(AX_MAIL_SCHEMA, alias="email", required=True))
            authrequest.addExtension(axreq)

            sreq = sreg.SRegRequest(required=['nickname'], optional=['email'])
            authrequest.addExtension(sreq)    
        
        redirecturl = authrequest.redirectURL(h.instance_url(c.instance, path='/'), 
                                    return_to=h.instance_url(c.instance, path='/openid/verify'), 
                                    immediate=False)
        session['openid_session'] = self.openid_session
        session.save()
        return redirect_to(redirecturl)
    
    @ActionProtector(has_permission("user.edit"))
    def connect(self):
        if not c.user:
            h.flash(_("No OpenID was entered."))
            redirect_to("/login")
        return render("/openid/connect.html")   
    
    @RequireInternalRequest()
    @ActionProtector(has_permission("user.edit"))
    def revoke(self, id):
        openid = model.OpenID.by_id(id)
        if not openid:
            abort(404, _("No OpenID with ID '%s' exists.") % id)
        page_user = openid.user
        if not (page_user == c.user or h.has_permission("user.manage")): 
            abort(403, _("You're not authorized to change %s's settings.") % id)
        openid.delete()
        model.meta.Session.commit()
        return redirect_to("/user/%s/edit" % str(page_user.user_name))

    def verify(self):
        self.consumer = create_consumer(self.openid_session)
        info = self.consumer.complete(request.params, h.instance_url(c.instance, path='/openid/verify'))
        if not info.status == SUCCESS:
            return self._failure(info.identity_url, _("OpenID login failed."))
        
        email = None
        user_name = None
            
        # evaluate Simple Registration Extension data
        srep = sreg.SRegResponse.fromSuccessResponse(info)
        if srep:
            user_name = srep.get('nickname').strip()
            if srep.get('email'):
                email = srep.get('email')
                    
        # evaluate Attribute Exchange data        
        # TBD: AXSCHEMA friendlyName 
        # TBD: SignedMembership
        axrep = ax.FetchResponse.fromSuccessResponse(info)
        if axrep:
            args = axrep.getExtensionArgs()
            if args.get('type.ext0') == AX_MAIL_SCHEMA:
                email = args.get('value.ext0.1')
            
        if 'openid_session' in session:
            del session['openid_session']
                
        oid = model.OpenID.find(info.identity_url)
        if oid:
            if c.user:
                if oid.user == c.user:
                    return self._failure(info.identity_url, 
                        _("You have already claimed this OpenID."))
                else:
                    return self._failure(info.identity_url,
                        _("OpenID %s already belongs to %s.") 
                        % (info.identity_url, oid.user.name))
            else: 
                self._login(oid.user)
                # returns
        else:
            if c.user:
                oid = model.OpenID(unicode(info.identity_url), c.user)
                model.meta.Session.add(oid)
                model.meta.Session.commit()
                redirect_to("/user/%s/edit" % str(c.user.user_name))
            else:
                try:
                    forms.UniqueUsername(not_empty=True).to_python(user_name)
                except:
                    session['openid_req'] = (info.identity_url, user_name, email)
                    session.save()
                    redirect_to('/openid/username')
                user = self._create(user_name, email, info.identity_url)
                self._login(user)
                    
        return self._failure(info.identity_url, _("Justin Case has entered the room."))

    @validate(schema=OpenIDUsernameForm(), form="username", post_only=True)
    def username(self):
        """
        Called when the nickname proposed by the OpenID identity provider is 
        unavailable locally. 
        """
        if 'openid_req' in session:
            (openid, c.user_name, email) = session['openid_req']
            if request.method == "POST":
                c.user_name = self.form_result.get('login')
                c.user_name = forms.UniqueUsername(not_empty=True).to_python(c.user_name)
                if c.user_name:
                    user = self._create(c.user_name, email, openid)
                    del session['openid_req']
                    self._login(user)
            return render('/openid/username.html')
        else:
            redirect_to('/register')

"""
XSRF is Cross-Site Request Forgery, where an attacker has a user follow a link that triggers an 
action on a site which the user did not intentionally want to perform (i.e. vote in 
a certain way). To prevent this, some actions are only possible if authorized via HTTP or if a
modtoken - a shared SHA1 hash - is included.  
"""

import random
import hashlib
from urlparse import urlparse
from decorator import decorator

from pylons import session, request, config
from pylons.controllers.util import abort
from pylons.i18n import _

def RequireInternalRequest(methods=['POST', 'GET', 'PUT', 'DELETE']):
    """
    XSRF Spoof Filter
    
    TODO: There is still a scenario in which an attacker opens an adhocracy 
    page in an iframe, extracts a valid modtoken via javascript and uses this
    token to execute the request. 
    """
    def _decorate(f, *a, **kw):
        def check():
            if not request.method in methods:
                return True
            if not request.environ.get("AUTH_TYPE") == "cookie":
                return True
            if config.get('skip_authentication'):
                return True
            
            if request.environ.get('HTTP_REFERER'):           
                ref_url = urlparse(request.environ.get('HTTP_REFERER'))
                ref_host = ref_url.hostname
                if ref_url.port:
                    ref_host += ":" + str(ref_url.port)
            
                if ref_host.endswith(request.environ['adhocracy.domain']):
                    if request.method != 'GET':                    
                        return True
            
            if request.method == 'GET' and has_token():                    
                return True
                       
            return False
        if check():
            return f(*a, **kw)
        else:
            abort(403, _("Action failed. You were probably trying to re-perform " +
                         "an action after using your browser's 'Back' button. This " +
                         "is prohibited for security reasons.")) 
    return decorator(_decorate)

def make_token():
    tokens = session.get('modtokens', [])
    
    token = None
    if len(tokens) < 100:
        token = hashlib.sha1(str(random.random())).hexdigest()
    else:
        token = tokens[-1]
        
    tokens.append(token)
    session['modtokens'] = tokens
    session.save()
    return token

def url_token():
    return "_csrftoken=%s" % make_token()

def field_token():
    return '<input name="_csrftoken" type="hidden" value="%s" />' % make_token() 

def has_token():
    if request.params.get('_csrftoken', None) in session['modtokens']:
        tokens = session['modtokens']
        tokens.remove(request.params.get('_csrftoken'))
        session['modtokens'] = tokens
        session.save()
        return True
    return False

from datetime import datetime

import logging

from sqlalchemy import Table, Column, Integer, Unicode, ForeignKey, DateTime, Binary, func, or_ 
 
import meta 

log = logging.getLogger(__name__)

openid_table = Table('openid', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('identifier', Unicode(255), nullable=False, index=True) 
    )


oid_nonces = Table('oid_nonces', meta.data,
    Column('server_url', Binary, nullable=False),
    Column('timestamp', Integer, primary_key=True),
    Column('salt', Unicode(40), nullable=False, index=True)
    )

    
oid_associations = Table('oid_associations', meta.data,
    Column('server_url', Binary, nullable=False),
    Column('handle', Unicode(255), nullable=False, index=True),
    Column('secret', Binary, nullable=False),
    Column('issued', Integer, primary_key=True),
    Column('lifetime', Integer, primary_key=True),
    Column('assoc_type', Unicode(64), nullable=False)
    )
    

class OpenID(object):
    
    def __init__(self, identifier, user):
        self.identifier = identifier
        self.user = user
    
    
    @classmethod
    def find(cls, identifier, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.identifier==identifier)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time==None,
                                 OpenID.delete_time>datetime.utcnow()))
            return q.one()                    
        except Exception, e:
            log.warn("find(%s): %s" % (identifier, e))
            return None
        
    
    @classmethod
    def by_id(cls, id, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.id==id)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time==None,
                                 OpenID.delete_time>datetime.utcnow()))
            return q.one()                    
        except Exception:
            log.exception("by_id(%s)" % id)
            return None
            
    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time  
    
    
    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time
            
            
    def __repr__(self):
        return u"<OpenID(%d,%s,%s)>" % (self.id, 
                                        self.identifier,
                                        self.user.user_name)  

"""API endpoints dealing with submissions."""
from tornado.escape import json_encode, to_unicode                    
import tornado.web

import api.submission
from db.survey import IncorrectQuestionIdError
from pages.util.base import APIHandler, get_email, get_json_request_body, \
    catch_bare_integrity_error, validation_message, BaseHandler                    


class SubmissionsAPIHandler(APIHandler):
    """The endpoint for getting all submissions to a survey."""

    def _get_subs(self):
        if 'submitter' in self.request.arguments:
            return list(map(to_unicode, self.request.arguments['submitter']))

    def get(self, survey_id: str):
        subs = self._get_subs()
        response = api.submission.get_all(survey_id,
                                          email=get_email(self),
                                          submitters=subs)
        self.write(response)

    def post(self, survey_id: str):
        body = get_json_request_body(self)
        subs = body.get('submitters', None)
        filters = body.get('filters', None)
        response = api.submission.get_all(survey_id,
                                          email=get_email(self),
                                          submitters=subs,
                                          filters=filters)
        self.write(response)


class SingleSubmissionAPIHandler(APIHandler):
    """The endpoint for getting a single submission."""

    def get(self, submission_id: str):
        response = api.submission.get_one(submission_id, email=get_email(self))
        self.write(response)


class SubmitAPIHandler(BaseHandler):                    
    """The endpoint for submitting to a survey. You don't need to log in."""

    @catch_bare_integrity_error
    def post(self, survey_id: str):
        data = get_json_request_body(self)

        if data.get('survey_id', None) != survey_id:
            reason = validation_message('submission', 'survey_id', 'invalid')
            raise tornado.web.HTTPError(422, reason=reason)
        try:
            self.write(api.submission.submit(data))
            self.set_status(201)
        except KeyError as e:
            reason = validation_message('submission', str(e), 'missing_field')
            raise tornado.web.HTTPError(422, reason=reason)
        except IncorrectQuestionIdError:
            reason = validation_message('submission', 'question_id', 'invalid')
            raise tornado.web.HTTPError(422, reason=reason)

"""API endpoints dealing with surveys."""

from tornado.escape import json_encode                    

import api.survey
from pages.util.base import APIHandler, get_email                    


class SurveysAPIHandler(APIHandler):
    """The endpoint for getting all of a user's surveys."""

    def get(self):
        """
        I hope you like parentheses.

        """
        self.write(api.survey.get_all(get_email(self)))


class SingleSurveyAPIHandler(APIHandler):
    """The endpoint for getting a single survey."""

    def get(self, survey_id: str):
        email = get_email(self)
        self.write(api.survey.get_one(survey_id, email=email))

#!/usr/bin/env python3

"""
This tornado server creates the client app by serving html/css/js and
it also functions as the wsgi container for accepting survey form post
requests back from the client app.
"""

from tornado.escape import json_encode
import tornado.web
import tornado.ioloop

import api.aggregation
import api.survey
import api.submission
import api.user
from pages.api.aggregations import AggregationHandler
from pages.auth import LogoutHandler, LoginHandler
from pages.api.submissions import SubmissionsAPIHandler, \
    SingleSubmissionAPIHandler, SubmitAPIHandler
from pages.api.surveys import SurveysAPIHandler, SingleSurveyAPIHandler                    
from pages.util.base import BaseHandler, get_json_request_body, \
    validation_message, catch_bare_integrity_error
import pages.util.ui
from pages.debug import DebugLoginHandler, DebugLogoutHandler                    
from pages.view.surveys import ViewHandler
from pages.view.submissions import ViewSubmissionsHandler, \
    ViewSubmissionHandler
import settings
from utils.logger import setup_custom_logger
from db.survey import SurveyPrefixDoesNotIdentifyASurveyError, \
    SurveyPrefixTooShortError, \
    get_survey_id_from_prefix, get_surveys_by_email, IncorrectQuestionIdError


logger = setup_custom_logger('dokomo')


class Index(BaseHandler):
    def get(self, msg=""):
        surveys = get_surveys_by_email(self.current_user, 10)
        self.render('index.html', message=msg, surveys=surveys)

    def post(self):
        LogoutHandler.post(self)  # TODO move to js
        self.get("You logged out")


class Survey(BaseHandler):
    def get(self, survey_prefix: str):
        try:
            survey_id = get_survey_id_from_prefix(survey_prefix)
            if len(survey_prefix) < 36:
                self.redirect('/survey/{}'.format(survey_id), permanent=False)
            else:
                survey = api.survey.display_survey(survey_id)['result']
                self.render('survey.html',
                            survey=json_encode(survey),
                            survey_title=survey['survey_title'])
        except (SurveyPrefixDoesNotIdentifyASurveyError,
                SurveyPrefixTooShortError):
            raise tornado.web.HTTPError(404)


    def post(self, uuid):
        SubmitAPIHandler.post(self, uuid) # TODO: Hey Abdi kill this


class APITokenGenerator(BaseHandler):
    @tornado.web.authenticated
    def get(self):
        # self.render('api-token.html')
        self.write(
            api.user.generate_token(
                {'email': self.current_user}))


    @tornado.web.authenticated
    def post(self):
        data = get_json_request_body(self)
        self.write(api.user.generate_token(data))


config = {
    'template_path': 'templates',
    'static_path': 'static',
    'xsrf_cookies': True,
    'login_url': '/',
    'cookie_secret': settings.COOKIE_SECRET,
    'ui_methods': pages.util.ui,
    'debug': True  # Remove this
}

UUID_REGEX = '[a-f0-9]{8}-?[a-f0-9]{4}-?4[a-f0-9]{3}-?[89ab][a-f0-9]{3}-?[' \
             'a-f0-9]{12}'

pages = [
    # Dokomo Forms
    (r'/', Index),

    # View surveys and submissions
    (r'/view/?', ViewHandler),
    (r'/view/({})/?'.format(UUID_REGEX), ViewSubmissionsHandler),
    (r'/view/submission/({})/?'.format(UUID_REGEX), ViewSubmissionHandler),

    # Survey Submissions
    (r'/survey/(.+)/?', Survey),

    # Auth
    (r'/user/login/persona/?', LoginHandler),  # Post to Persona here

    # API tokens
    (r'/user/generate-api-token/?', APITokenGenerator),

    # Testing
    (r'/api/aggregate/({})/?'.format(UUID_REGEX), AggregationHandler),

    (r'/api/surveys/?', SurveysAPIHandler),
    (r'/api/surveys/({})/?'.format(UUID_REGEX), SingleSurveyAPIHandler),
    (r'/api/surveys/({})/submit/?'.format(UUID_REGEX), SubmitAPIHandler),
    (r'/api/surveys/({})/submissions/?'.format(UUID_REGEX),
     SubmissionsAPIHandler),
    (r'/api/submissions/({})/?'.format(UUID_REGEX),
     SingleSubmissionAPIHandler),
]

if config.get('debug', False):
    pages += [(r'/debug/login/(.+)/?', DebugLoginHandler),                    
              (r'/debug/logout/?', DebugLogoutHandler),
    ]

app = tornado.web.Application(pages, **config)

if __name__ == '__main__':
    app.listen(settings.WEBAPP_PORT, '0.0.0.0')

    logger.info('starting server on port ' + str(settings.WEBAPP_PORT))

    tornado.ioloop.IOLoop.current().start()

"""The base class of the TornadoResource classes in the api module."""
from abc import ABCMeta, abstractmethod
from collections import OrderedDict
from time import localtime

from passlib.hash import bcrypt_sha256

from restless.tnd import TornadoResource
import restless.exceptions as exc

from sqlalchemy import text, func
from sqlalchemy.sql.expression import false
from sqlalchemy.sql.functions import count
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm.exc import NoResultFound

import tornado.web

from dokomoforms.api.serializer import ModelJSONSerializer
from dokomoforms.handlers.util import BaseHandler, BaseAPIHandler
from dokomoforms.models import SurveyCreator, Email
from dokomoforms.models.util import column_search, get_fields_subset
from dokomoforms.exc import DokomoError

# TODO: Find out if it is OK to remove these. @jmwohl
# """
# A list of the expected query arguments
# """
# QUERY_ARGS = [
#     'limit',
#     'offset',
#     'type',
#     'draw',
#     'fields',
# ]


class BaseResource(TornadoResource, metaclass=ABCMeta):

    """Set up the basics for the model resource.

    BaseResource does some basic configuration for the restless resources.
    - sets the base request handler class which is used by the resources
    - providing reference to the ORM session via request handler
    - inserting a serializer for dokomo Models
    - setting up authentication
    """

    _request_handler_base_ = BaseAPIHandler

    # The serializer is used to serialize / deserialize models to json
    serializer = ModelJSONSerializer()

    @property  # pragma: no cover
    @abstractmethod
    def resource_type(self):
        """The model class for the resource."""

    @property  # pragma: no cover
    @abstractmethod
    def default_sort_column_name(self):
        """The default ORDER BY column name for list responses."""

    @property  # pragma: no cover
    @abstractmethod
    def objects_key(self):
        """The key for list responses."""

    @property
    def session(self):
        """The handler's session."""
        return self.r_handler.session

    @property
    def current_user_model(self):
        """The handler's current_user_model."""
        return self.r_handler.current_user_model

    @property
    def current_user(self):
        """The handler's current_user."""
        return self.r_handler.current_user

    def _query_arg(self, argument_name, output=None, default=None):
        """Get a useful query parameter argument."""
        arg = self.r_handler.get_query_argument(argument_name, None)

        # Return default if the argument was not given.
        if not arg:
            return default

        # Convert 'true'/'false' argument into True or False
        if output is bool:
            return arg.lower() == 'true'

        # Convert a comma-separated list to a list of strings
        if output is list:
            return arg.split(',')

        # Apply the parsing function if supplied.
        if output is not None:
            return output(arg)

        return arg

    def handle_error(self, err):
        """Generate a serialized error message.

        If the error came from Tornado, pass it along as such.
        Otherwise, turn certain expected errors into 400 BAD REQUEST instead
        of 500 INTERNAL SERVER ERROR.
        """
        understood = (
            KeyError, ValueError, TypeError, AttributeError,
            SQLAlchemyError, DokomoError
        )

        if isinstance(err, tornado.web.HTTPError):
            restless_error = exc.HttpError(err.log_message)
            restless_error.status = err.status_code
            err = restless_error
        elif isinstance(err, understood):
            err = exc.BadRequest(err)
        return super().handle_error(err)

    def wrap_list_response(self, data):
        """Wrap a list response in a dict.

        Takes a list of data & wraps it in a dictionary (within the ``objects``
        key).
        For security in JSON responses, it's better to wrap the list results in
        an ``object`` (due to the way the ``Array`` constructor can be attacked
        in Javascript).
        See http://haacked.com/archive/2009/06/25/json-hijacking.aspx/
        & similar for details.
        Overridable to allow for modifying the key names, adding data (or just
        insecurely return a plain old list if that's your thing).
        :param data: A list of data about to be serialized
        :type data: list
        :returns: A wrapping dict
        :rtype: dict
        """
        response = OrderedDict((
            (self.objects_key, data[1]),
            (
                'total_entries',
                self.session.query(func.count(self.resource_type.id)).scalar()
            ),
            ('filtered_entries', data[0]),
        ))
        # add additional properties to the response object
        full_response = self._add_meta_props(response)

        return full_response

    def _check_xsrf_cookie(self):
        return BaseHandler.check_xsrf_cookie(self.r_handler)

    def is_authenticated(self):
        """Return whether the request has been authenticated."""
        # A logged-in user has already authenticated.
        if self.r_handler.current_user is not None:
            self._check_xsrf_cookie()                    
            return True

        # A SurveyCreator can log in with a token.
        token = self.r_handler.request.headers.get('Token', None)
        email = self.r_handler.request.headers.get('Email', None)
        if (token is not None) and (email is not None):
            # Get the user's token hash and expiration time.
            try:
                user = (
                    self.session
                    .query(SurveyCreator.token, SurveyCreator.token_expiration)
                    .join(Email)
                    .filter(Email.address == email)
                    .one()
                )
            except NoResultFound:
                return False
            # Check that the token has not expired
            if user.token_expiration.timetuple() < localtime():
                return False
            # Check the token
            token_exists = user.token is not None
            return token_exists and bcrypt_sha256.verify(token, user.token)

        return False

    def _specific_fields(self, model_or_models, is_detail=True):
        """Pick out the specified fields on the given models.

        TODO: Confirm that this is not a performance bottleneck.
        """
        fields = self._query_arg('fields', list)

        # No fields specified -> return them all.
        if fields is None:
            return model_or_models

        if is_detail:
            the_model = model_or_models
            return get_fields_subset(the_model, fields)
        models = model_or_models
        return [get_fields_subset(model, fields) for model in models]

    def detail(self, model_id):
        """Return a single instance of a model."""
        model = self.session.query(self.resource_type).get(model_id)
        if model is None:
            raise exc.NotFound()
        return self._specific_fields(model)

    def list(self, where=None):
        """Return a list of instances of this model.

        Given a model class, build up the ORM query based on query params
        and return the query result.
        """
        model_cls = self.resource_type
        query = self.session.query(model_cls, count().over())

        limit = self._query_arg('limit', int)
        offset = self._query_arg('offset', int)
        deleted = self._query_arg('show_deleted', bool, False)
        search_term = self._query_arg('search')
        regex = self._query_arg('regex', bool, False)
        search_fields = self._query_arg(
            'search_fields', list, default=['title']
        )
        search_lang = self._query_arg('lang')

        default_sort = ['{}:DESC'.format(self.default_sort_column_name)]
        order_by_text = (
            element.split(':') for element in self._query_arg(
                'order_by', list, default=default_sort
            )
        )

        type_constraint = self._query_arg('type')

        if search_term is not None:
            for search_field in search_fields:
                query = column_search(
                    query,
                    model_cls=model_cls,
                    column_name=search_field,
                    search_term=search_term,
                    language=search_lang,
                    regex=regex,
                )

        if not deleted:
            query = query.filter(model_cls.deleted == false())

        if type_constraint is not None:
            query = query.filter(model_cls.type_constraint == type_constraint)

        if where is not None:
            query = query.filter(where)

        for attribute_name, direction in order_by_text:
            try:
                order = getattr(model_cls, attribute_name)
                direction = direction.lower()
                if direction == 'asc':
                    order = order.asc()
                elif direction == 'desc':
                    order = order.desc()
                order = order.nullslast()
            except AttributeError:
                order = text(
                    '{} {} NULLS LAST'.format(attribute_name, direction)
                )
            query = query.order_by(order)

        if limit is not None:
            query = query.limit(limit)

        if offset is not None:
            query = query.offset(offset)

        result = query.all()
        if result:
            num_filtered = result[0][1]
            models = [res[0] for res in result]
            return num_filtered, self._specific_fields(models, is_detail=False)
        return 0, []

    def update(self, model_id):
        """Update a model."""
        model = self.session.query(self.resource_type).get(model_id)

        if model is None:
            raise exc.NotFound()

        with self.session.begin():
            for attribute, value in self.data.items():
                setattr(model, attribute, value)
            self.session.add(model)
        return model

    def delete(self, model_id):
        """Set the deleted attribute to True. Does not destroy the instance."""
        with self.session.begin():
            model = self.session.query(self.resource_type).get(model_id)
            if model is None:
                raise exc.NotFound()
            model.deleted = True

    def _add_meta_props(self, response):
        """Add metadata to the response.

        Add the appropriate metadata fields to the response body object. Any
        properties that should sit alongside the list of objects being
        returned should be added here.

        e.g. if the request contained a limit, include the limit value in
        the response:

        {
            "objects": [{
                "title": "Testing"
            },
            {
                "title": "Check One"
            }],
            "limit": 5
        }

        TODO: this will require a bit more sophistication, since we probably
        don't want to just reflect query params willy nilly.
        """
        for prop in sorted(self.r_handler.request.arguments):
            prop_value = self.r_handler.get_query_argument(prop)
            if prop_value.isdigit():
                prop_value = int(prop_value)
            response[prop] = prop_value

        return response



from flask import Flask
from flask import redirect
from flask import url_for
from routes.topic_routes import topic_routes
from routes.auth_routes import auth_routes
from routes.reply_routes import reply_routes


app = Flask(__name__)
app.secret_key = "for test"

@app.route("/", methods=["GET"])
def index():
	return redirect(url_for("auth.login"))

app.register_blueprint(topic_routes, url_prefix="/topic")                    
app.register_blueprint(auth_routes, url_prefix="/auth")                    
app.register_blueprint(reply_routes, url_prefix="/reply")                    

if __name__ == "__main__":
	app.run(debug=True)                    

import logging
import tornado.httpserver
import tornado.ioloop
import tornado.web
from tornado.options import define, options

import application
import handlers
import settings
import beacon

define("port", default=4000, help="run on the given port", type=int)
define("develop", default=False, help="Run in develop environment", type=bool)

redirect_uri = settings.redirect_uri

# Setup the Tornado Application
settings = {"debug": False,
            "cookie_secret": settings.cookie_secret,
            "login_url": "/login",
            "google_oauth": {
                "key": settings.google_key,
                "secret": settings.google_secret
            },
            "contact_person": 'mats.dahlberg@scilifelab.se',
            "redirect_uri": redirect_uri,
            "template_path": "templates/"                    
        }

class Application(tornado.web.Application):
    def __init__(self, settings):
        self.declared_handlers = [
            ## Static handlers
            (r"/static/(.*)",                             tornado.web.StaticFileHandler,              {"path": "static/"}),
            (r'/(favicon.ico)',                           tornado.web.StaticFileHandler,              {"path": "static/img/"}),
            (r"/release/(?P<dataset>[^\/]+)/(?P<file>.*)",        handlers.AuthorizedStaticNginxFileHanlder,  {"path": "/release-files/"}),
            ## Authentication
            ("/login",                                    handlers.LoginHandler),
            ("/logout",                                   handlers.LogoutHandler),
            ## API Methods
            ("/api/countries",                                  application.CountryList),
            ("/api/users/me",                                   application.GetUser),
            ### Dataset Api
            ("/api/datasets",                                                     application.ListDatasets),
            ("/api/datasets/(?P<dataset>[^\/]+)",                                 application.GetDataset),
            ("/api/datasets/(?P<dataset>[^\/]+)/log/(?P<event>[^\/]+)",           application.LogEvent),
            ("/api/datasets/(?P<dataset>[^\/]+)/logo",                            application.ServeLogo),
            ("/api/datasets/(?P<dataset>[^\/]+)/files",                           application.DatasetFiles),
            ("/api/datasets/(?P<dataset>[^\/]+)/sample_set",                      application.SampleSet),
            ("/api/datasets/(?P<dataset>[^\/]+)/users",                           application.DatasetUsers),
            ("/api/datasets/(?P<dataset>[^\/]+)/users/(?P<email>[^\/]+)/request", application.RequestAccess),
            ("/api/datasets/(?P<dataset>[^\/]+)/users/(?P<email>[^\/]+)/approve", application.ApproveUser),
            ("/api/datasets/(?P<dataset>[^\/]+)/users/(?P<email>[^\/]+)/revoke",  application.RevokeUser),
            ### Beacon API
            ("/api/query",                                beacon.Query),
            ("/api/info",                                 beacon.Info),
            # # # # # Legacy beacon URIs # # # # #
            ("/query",                                    beacon.Query),
            ("/info",                                     tornado.web.RedirectHandler, {"url": "/api/info"}),
            ## Catch all
            (r'.*',                                       application.Home),
        ]

        # google oauth key
        self.oauth_key = settings["google_oauth"]["key"]

        # Setup the Tornado Application
        tornado.web.Application.__init__(self, self.declared_handlers, **settings)

if __name__ == '__main__':
    tornado.log.enable_pretty_logging()
    tornado.options.parse_command_line()

    if options.develop:
        settings['debug'] = True
        settings['develop'] = True
        logging.getLogger().setLevel(logging.DEBUG)

    # Instantiate Application
    application = Application(settings)
    application.listen(options.port)

    # Start HTTP Server
    http_server = tornado.httpserver.HTTPServer(application)

    # Get a handle to the instance of IOLoop
    ioloop = tornado.ioloop.IOLoop.instance()

    # Start the IOLoop
    ioloop.start()

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import json
import logging
from datetime import datetime
import peewee
import smtplib
import tornado.web

import db
import handlers
import settings


def build_dataset_structure(dataset_version, user=None, dataset=None):
    if dataset is None:
        dataset = dataset_version.dataset
    r = db.build_dict_from_row(dataset)

    r['version'] = db.build_dict_from_row(dataset_version)
    r['version']['available_from'] = r['version']['available_from'].strftime('%Y-%m-%d')

    r['has_image']  = dataset.has_image()

    if user:
        r['is_admin'] = user.is_admin(dataset)
        if user.has_access(dataset):
            r['authorization_level'] = 'has_access'
        elif user.has_requested_access(dataset):
            r['authorization_level'] = 'has_requested_access'
        else:
            r['authorization_level'] = 'no_access'

    return r                    


class ListDatasets(handlers.UnsafeHandler):
    def get(self):
        # List all datasets available to the current user, earliear than now OR
        # versions that are available in the future that the user is admin of.
        user = self.current_user                    

        ret = []
        if user:
            futures = db.DatasetVersion.select(
                    ).join(
                        db.Dataset
                    ).join(
                        db.DatasetAccess
                    ).where(
                        db.DatasetVersion.available_from > datetime.now(),
                        db.DatasetAccess.user == user,
                        db.DatasetAccess.is_admin
                    )
            for f in futures:
                dataset = build_dataset_structure(f, user)
                dataset['future'] = True
                ret.append( dataset )

        for version in db.DatasetVersionCurrent.select():
            dataset = build_dataset_structure(version, user)
            dataset['current'] = True
            ret.append( dataset )

        self.finish({'data':ret})


class GetDataset(handlers.UnsafeHandler):
    def get(self, dataset, version=None):
        user = self.current_user                    

        current_version = False
        future_version  = False
        dataset = db.get_dataset(dataset)
        if version:
            version = db.DatasetVersion.select().where(
                    db.DatasetVersion.version == version,
                    db.DatasetVersion.dataset == dataset
                ).get()
        else:
            version = dataset.current_version.get()
            current_version = True

        if version.available_from > datetime.now():
            # If it's not available yet, only return if user is admin.                    
            if not (user and user.is_admin(dataset)):
                self.send_error(status_code=403)
                return                    
            future_version = True
        elif not current_version:
            # Make another check on whether this is the current version
            cv = dataset.current_version.get()
            current_version = cv.version == version.version

        ret = build_dataset_structure(version, user, dataset)
        ret['current'] = current_version
        ret['future']  = future_version

        self.finish(ret)


class ListDatasetVersions(handlers.UnsafeHandler):
    def get(self, dataset):
        user = self.current_user                    
        dataset = db.get_dataset(dataset)

        versions = db.DatasetVersion.select(
                db.DatasetVersion.version, db.DatasetVersion.available_from
            ).where(
                db.DatasetVersion.dataset == dataset
            )
        logging.info("ListDatasetVersions")

        data = []
        found_current = False
        for v in reversed(versions):
            current = False
            future  = False

            # Skip future versions unless admin
            if v.available_from > datetime.now():
                if not (user and user.is_admin(dataset)):
                    continue
                future = True

            # Figure out if this is the current version
            if not found_current and v.available_from < datetime.now():
                found_current = True
                current       = True

            data.insert(0, {
                'name':           v.version,
                'available_from': v.available_from.strftime('%Y-%m-%d'),
                'current':        current,
                'future':         future,
            })

        self.finish({'data': data})


class DatasetFiles(handlers.AuthorizedHandler):
    def get(self, dataset, version=None, *args, **kwargs):
        dataset = db.get_dataset(dataset)
        if version:
            dataset_version = dataset.versions.where(db.DatasetVersion.version==version).get()
        else:
            dataset_version = dataset.current_version.get()
        ret = []
        for f in dataset_version.files:
            ret.append(db.build_dict_from_row(f))
        self.finish({'files': ret})


class Collection(handlers.UnsafeHandler):
    def get(self, dataset, *args, **kwargs):
        user = self.current_user                    
        dataset = db.get_dataset(dataset)

        collections = {}

        for sample_set in dataset.sample_sets:
            collection = sample_set.collection
            if not collection.name in collections:
                collections[collection.name] = {
                        'sample_sets': [],
                        'ethnicity': collection.ethnicity,
                    }
            collections[collection.name]['sample_sets'].append( db.build_dict_from_row(sample_set) )


        ret = {
            'collections': collections,
            'study':       db.build_dict_from_row(dataset.study)
        }
        ret['study']['publication_date'] = ret['study']['publication_date'].strftime('%Y-%m-%d')

        self.finish(ret)


class GetUser(handlers.UnsafeHandler):
    def get(self):
        user = self.current_user                    

        ret = { 'user': None, 'email': None }
        if user:
            ret = { 'user': user.name, 'email': user.email }

        self.finish(ret)


class CountryList(handlers.UnsafeHandler):
    def get(self, *args, **kwargs):
        self.write({'countries': [{'name': c} for c in self.country_list()]})

    def country_list(self):
        return ["Afghanistan", "Albania", "Algeria", "American Samoa", "Andorra",                    
                "Angola", "Anguilla", "Antarctica", "Antigua and Barbuda",
                "Argentina", "Armenia", "Aruba", "Australia", "Austria",
                "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados",
                "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan",
                "Bolivia", "Bosnia and Herzegovina", "Botswana", "Brazil",
                "British Indian Ocean Territory", "British Virgin Islands",
                "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia",
                "Cameroon", "Canada", "Cape Verde", "Cayman Islands",
                "Central African Republic", "Chad", "Chile", "China",
                "Christmas Island", "Cocos Islands", "Colombia", "Comoros",
                "Cook Islands", "Costa Rica", "Croatia", "Cuba", "Curacao",
                "Cyprus", "Czech Republic", "Democratic Republic of the Congo",
                "Denmark", "Djibouti", "Dominica", "Dominican Republic",
                "East Timor", "Ecuador", "Egypt", "El Salvador",
                "Equatorial Guinea", "Eritrea", "Estonia", "Ethiopia",
                "Falkland Islands", "Faroe Islands", "Fiji", "Finland", "France",
                "French Polynesia", "Gabon", "Gambia", "Georgia", "Germany",
                "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guam",
                "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana",
                "Haiti", "Honduras", "Hong Kong", "Hungary", "Iceland", "India",
                "Indonesia", "Iran", "Iraq", "Ireland", "Isle of Man", "Israel",
                "Italy", "Ivory Coast", "Jamaica", "Japan", "Jersey", "Jordan",
                "Kazakhstan", "Kenya", "Kiribati", "Kosovo", "Kuwait",
                "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia",
                "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Macau",
                "Macedonia", "Madagascar", "Malawi", "Malaysia", "Maldives",
                "Mali", "Malta", "Marshall Islands", "Mauritania", "Mauritius",
                "Mayotte", "Mexico", "Micronesia", "Moldova", "Monaco",
                "Mongolia", "Montenegro", "Montserrat", "Morocco", "Mozambique",
                "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands",
                "Netherlands Antilles", "New Caledonia", "New Zealand",
                "Nicaragua", "Niger", "Nigeria", "Niue", "North Korea",
                "Northern Mariana Islands", "Norway", "Oman", "Pakistan", "Palau",
                "Palestine", "Panama", "Papua New Guinea", "Paraguay", "Peru",
                "Philippines", "Pitcairn", "Poland", "Portugal", "Puerto Rico",
                "Qatar", "Republic of the Congo", "Reunion", "Romania", "Russia",
                "Rwanda", "Saint Barthelemy", "Saint Helena",
                "Saint Kitts and Nevis", "Saint Lucia", "Saint Martin",
                "Saint Pierre and Miquelon",
                "Saint Vincent and the Grenadines", "Samoa", "San Marino",
                "Sao Tome and Principe", "Saudi Arabia", "Senegal", "Serbia",
                "Seychelles", "Sierra Leone", "Singapore", "Sint Maarten",
                "Slovakia", "Slovenia", "Solomon Islands", "Somalia",
                "South Africa", "South Korea", "South Sudan", "Spain",
                "Sri Lanka", "Sudan", "Suriname", "Svalbard and Jan Mayen",
                "Swaziland", "Sweden", "Switzerland", "Syria", "Taiwan",
                "Tajikistan", "Tanzania", "Thailand", "Togo", "Tokelau", "Tonga",
                "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan",
                "Turks and Caicos Islands", "Tuvalu", "U.S. Virgin Islands",
                "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom",
                "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican",
                "Venezuela", "Vietnam", "Wallis and Futuna", "Western Sahara",
                "Yemen", "Zambia", "Zimbabwe" ];


class RequestAccess(handlers.SafeHandler):
    def get(self, dataset, *args, **kwargs):
        user = self.current_user                    
        name = user.name
        email = user.email

        logging.info("Request: " + name + ' ' + email)
        self.finish(json.dumps({'user':name, 'email':email}))

    def post(self, dataset, *args, **kwargs):
        dataset = db.get_dataset(dataset)

        email       = self.get_argument("email", default='', strip=False)                    
        affiliation = self.get_argument("affiliation", strip=False)
        country     = self.get_argument("country", strip=False)
        newsletter  = self.get_argument("newsletter", strip=False)

        # This is the only chance for XSRF in the application
        # avoid it by checking that the email sent by google is the same as
        # supplied by the form post
        user = self.current_user                    
        if user.email != email:                    
            return                    

        user.affiliation = affiliation
        user.country = country
        logging.info("Inserting into database: {}, {}".format(user.name, user.email))

        try:
            with db.database.atomic():
                user.save() # Save to database
                (da,_) = db.DatasetAccess.get_or_create(
                        user    = user,
                        dataset = dataset
                    )
                da.wants_newsletter = newsletter
                da.save()
                db.UserAccessLog.create(
                        user = user,
                        dataset = dataset,
                        action = 'access_requested'
                    )
        except Exception as e:
            logging.error(e)


class LogEvent(handlers.SafeHandler):
    def post(self, dataset, event, target):
        user = self.current_user                    

        if event == 'consent':
            dv = (db.DatasetVersion
                    .select()
                    .where(db.DatasetVersion.version==target)
                    .get())
            db.UserConsentLog.create(
                    user = user,
                    dataset_version = dv,
                )
        else:
            raise tornado.web.HTTPError(400, reason="Can't log that")


class ApproveUser(handlers.AdminHandler):
    def post(self, dataset, email):
        with db.database.atomic():
            dataset = db.get_dataset(dataset)

            user = db.User.select().where(db.User.email == email).get()

            da = db.DatasetAccess.select().where(
                        db.DatasetAccess.user == user,
                        db.DatasetAccess.dataset == dataset
                ).get()
            da.has_access = True
            da.save()

            db.UserAccessLog.create(
                    user = user,
                    dataset = dataset,
                    action = 'access_granted'
                )

        msg = MIMEMultipart()
        msg['to'] = email
        msg['from'] = settings.from_address
        msg['subject'] = 'Swefreq access granted to {}'.format(dataset.short_name)
        msg.add_header('reply-to', settings.reply_to_address)
        body = """You now have access to the {} dataset

Please visit https://swefreq.nbis.se/dataset/{}/download to download files.
        """.format(dataset.full_name, dataset.short_name,
                dataset.study.contact_name)
        msg.attach(MIMEText(body, 'plain'))

        server = smtplib.SMTP(settings.mail_server)
        server.sendmail(msg['from'], [msg['to']], msg.as_string())


class RevokeUser(handlers.AdminHandler):
    def post(self, dataset, email):
        with db.database.atomic():
            dataset = db.get_dataset(dataset)
            user = db.User.select().where(db.User.email == email).get()

            db.UserAccessLog.create(
                    user = user,
                    dataset = dataset,
                    action = 'access_revoked'
                )

class DatasetUsers():
    def _build_json_response(self, query, access_for):
        json_response = []
        for user in query:
            applyDate = '-'
            access = access_for(user)
            if not access:
                continue
            access = access[0]
            if access.access_requested:
                applyDate = access.access_requested.strftime('%Y-%m-%d')

            data = {
                    'user':        user.name,
                    'email':       user.email,
                    'affiliation': user.affiliation,
                    'country':     user.country,
                    'newsletter':  access.wants_newsletter,
                    'has_access':  access.has_access,
                    'applyDate':   applyDate
                }
            json_response.append(data)
        return json_response                    


class DatasetUsersPending(handlers.AdminHandler, DatasetUsers):
    def get(self, dataset, *args, **kwargs):
        dataset = db.get_dataset(dataset)
        users = db.User.select()
        access = (db.DatasetAccessPending
                   .select()
                   .where(
                       db.DatasetAccessPending.dataset == dataset,
                   ))
        query = peewee.prefetch(users, access)

        self.finish({'data': self._build_json_response(
            query, lambda u: u.access_pending_prefetch)})


class DatasetUsersCurrent(handlers.AdminHandler, DatasetUsers):
    def get(self, dataset, *args, **kwargs):
        dataset = db.get_dataset(dataset)
        users = db.User.select()
        access = (db.DatasetAccessCurrent
                   .select()
                   .where(
                       db.DatasetAccessCurrent.dataset == dataset,
                   ))
        query = peewee.prefetch(users, access)
        self.finish({'data': self._build_json_response(
            query, lambda u: u.access_current_prefetch)})


class ServeLogo(handlers.UnsafeHandler):
    def get(self, dataset, *args, **kwargs):
        try:
            logo_entry = db.DatasetLogo.select(
                    db.DatasetLogo
                ).join(
                    db.Dataset
                ).where(
                    db.Dataset.short_name == dataset
                ).get()
        except:
            self.send_error(status_code=404)
            return                    

        self.set_header("Content-Type", logo_entry.mimetype)
        self.write(logo_entry.data)
        self.finish()

#
# Copyright (C) 2010-2011  Ralf Nyren <ralf@nyren.net>
#
# This file is part of the occi-py library.
#
# The occi-py library is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# The occi-py library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with the occi-py library.  If not, see <http://www.gnu.org/licenses/>.
#

try:
    from ordereddict import OrderedDict
except ImportError:
    OrderedDict = dict
import json

from occi.http.parser import Parser, register_parser
from occi.http.renderer import Renderer, register_renderer, HeaderRenderer
from occi.http.dataobject import DataObject, LinkRepr

CONTENT_TYPE = 'application/json'

class JSONParser(Parser):
    """Parser for the application/json content type."""
    def parse(self, headers=None, body=None):
        raise NotImplemented('yet')

class JSONRenderer(Renderer):
    """Renderer for the application/json content type.

    >>> from occi.ext.infrastructure import ComputeKind, StorageKind
    >>> cats = [ComputeKind]
    >>> links = [LinkRepr(target_location='http://example.com/storage/345', target_categories=[StorageKind])]
    >>> attrs = [('occi.compute.cores', 3), ('occi.compute.speed', 2.667)]
    >>> obj = DataObject(location='http://example.com/compute/123', categories=cats, links=links, attributes=attrs)
    >>> JSONRenderer.INDENT = None
    >>> r = JSONRenderer()
    >>> r.render(obj)
    >>> r.headers
    [('Content-Type', 'application/json; charset=utf-8'), ('Category', 'compute; scheme="http://schemas.ogf.org/occi/infrastructure#"; class="kind"; title="Compute Resource"')]
    >>> response = json.loads(r.body)
    >>> response['categories'][0]['term']
    u'compute'
    >>> response['links'][0]['target_uri']
    u'http://example.com/storage/345'
    >>> response['links'][0]['target_type'][0] == str(StorageKind)
    True
    >>> response['attributes']['occi.compute.cores']
    3
    >>> response['attributes']['occi.compute.speed'] == 2.667
    True
    """

    INDENT = 4

    def render(self, objects):
        self.headers.append(('Content-Type', '%s; charset=utf-8' % CONTENT_TYPE))
        if isinstance(objects, list) or isinstance(objects, tuple):
            json_data = self._render_obj_list(objects)
        else:
            json_data = self._render_single_obj(objects)
        self.body = json.dumps(json_data, indent=self.INDENT)

    def _render_single_obj(self, obj):
        """Render a single `DataObject`.
        """
        if 'category_discovery' not in obj.render_flags:
            category_headers = HeaderRenderer.category_headers(obj)
            [self.headers.append(('Category', h)) for h in category_headers.headers()]
        return self._json_obj(obj)

    def _render_obj_list(self, objects):
        """Render a list of `DataObject` instances.
        """
        json_data = []
        for obj in objects:
            json_data.append(self._json_obj(obj))
        return json_data                    

    def _json_obj(self, obj):
        """Render `DataObject` into a JSON-friendly dictionary structure.
        """
        json_obj = OrderedDict()
        if obj.categories:
            json_obj['categories'] = []
        if obj.actions:
            json_obj['actions'] = []
        if obj.links:
            json_obj['links'] = []
        if obj.attributes:
            json_obj['attributes'] = OrderedDict()
        if obj.location:
            json_obj['location'] = obj.location

        # Categories
        for category in obj.categories:
            d = OrderedDict()
            d['term'] = category.term
            d['scheme'] = category.scheme

            cat_class = category.__class__.__name__.lower()
            #if cat_class == 'category': cat_class = 'action'
            d['class'] = cat_class

            d['title'] = category.title
            if category.related:
                d['related'] = str(category.related)
            if category.attributes:
                attr_defs = OrderedDict()
                for attr in category.unique_attributes:
                    attr_props = OrderedDict()
                    attr_props['mutable'] = attr.mutable
                    attr_props['required'] = attr.required
                    attr_props['type'] = attr.type_name
                    attr_defs[attr.name] = attr_props
                d['attributes'] = attr_defs
            if hasattr(category, 'actions') and category.actions:
                d['actions'] = [str(cat) for cat in category.actions]
            if hasattr(category, 'location') and category.location:
                d['location'] = obj.translator.url_build(category.location, path_only=True)

            json_obj['categories'].append(d)

        # Links
        for link in obj.links:
            d = OrderedDict()
            if link.target_title:
                d['title'] = link.target_title
            d['target_uri'] = link.target_location
            d['target_type'] = [str(cat) for cat in link.target_categories]
            if link.link_location:
                d['link_uri'] = link.link_location
            if link.link_categories:
                d['link_type'] = [str(cat) for cat in link.link_categories]
            if link.link_attributes:
                attrs = OrderedDict()
                for name, value in link.link_attributes:
                    attrs[name] = value
                d['attributes'] = attrs
            json_obj['links'].append(d)

        # Actions
        for action in obj.actions:
            d = OrderedDict()
            if action.target_title:
                d['title'] = action.target_title
            d['uri'] = action.target_location
            assert(len(action.target_categories) == 1)
            d['type'] = str(action.target_categories[0])
            json_obj['actions'].append(d)

        # Attributes
        for name, value in obj.attributes:
            json_obj['attributes'][name] = value

        return json_obj


def register():
    register_parser(CONTENT_TYPE, JSONParser)
    register_renderer(CONTENT_TYPE, JSONRenderer)

if __name__ == "__main__":
    import doctest
    doctest.testmod()


# Copyright (c) 2015 VMware, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import copy
import unittest

import mock
from oslo_serialization import jsonutils
from oslo_utils import uuidutils
from requests import exceptions as requests_exceptions

from vmware_nsxlib import v3
from vmware_nsxlib.v3 import client as nsx_client
from vmware_nsxlib.v3 import client_cert
from vmware_nsxlib.v3 import cluster as nsx_cluster
from vmware_nsxlib.v3 import config

NSX_USER = 'admin'
NSX_PASSWORD = 'default'
NSX_MANAGER = '1.2.3.4'
NSX_INSECURE = False
NSX_CERT = '/opt/stack/certs/nsx.pem'
CLIENT_CERT = '/opt/stack/certs/client.pem'
NSX_HTTP_RETRIES = 10
NSX_HTTP_TIMEOUT = 10
NSX_HTTP_READ_TIMEOUT = 180
NSX_CONCURENT_CONN = 10
NSX_CONN_IDLE_TIME = 10
NSX_MAX_ATTEMPTS = 10

PLUGIN_SCOPE = "plugin scope"
PLUGIN_TAG = "plugin tag"
PLUGIN_VER = "plugin ver"

DNS_NAMESERVERS = ['1.1.1.1']
DNS_DOMAIN = 'openstacklocal'


def _mock_nsxlib():
    def _return_id_key(*args, **kwargs):
        return {'id': uuidutils.generate_uuid()}

    def _mock_add_rules_in_section(*args):
        # NOTE(arosen): the code in the neutron plugin expects the
        # neutron rule id as the display_name.
        rules = args[0]
        return {
            'rules': [
                {'display_name': rule['display_name'],
                 'id': uuidutils.generate_uuid()}
                for rule in rules
            ]}

    mock.patch(
        "vmware_nsxlib.v3.cluster.NSXRequestsHTTPProvider"
        ".validate_connection").start()

    mock.patch(
        "vmware_nsxlib.v3.security.NsxLibNsGroup.create",
        side_effect=_return_id_key
    ).start()

    mock.patch(
        "vmware_nsxlib.v3.security.NsxLibFirewallSection.create_empty",
        side_effect=_return_id_key).start()

    mock.patch(
        "vmware_nsxlib.v3.security.NsxLibFirewallSection.init_default",
        side_effect=_return_id_key).start()

    mock.patch(
        "vmware_nsxlib.v3.security.NsxLibNsGroup.list").start()

    mock.patch(
        "vmware_nsxlib.v3.security.NsxLibFirewallSection.add_rules",
        side_effect=_mock_add_rules_in_section).start()

    mock.patch(
        ("vmware_nsxlib.v3.core_resources."
         "NsxLibTransportZone.get_id_by_name_or_id"),
        side_effect=_return_id_key).start()


def get_default_nsxlib_config():
    return config.NsxLibConfig(
        username=NSX_USER,
        password=NSX_PASSWORD,
        retries=NSX_HTTP_RETRIES,
        insecure=NSX_INSECURE,
        ca_file=NSX_CERT,
        concurrent_connections=NSX_CONCURENT_CONN,
        http_timeout=NSX_HTTP_TIMEOUT,
        http_read_timeout=NSX_HTTP_READ_TIMEOUT,
        conn_idle_timeout=NSX_CONN_IDLE_TIME,
        http_provider=None,
        nsx_api_managers=[],
        plugin_scope=PLUGIN_SCOPE,
        plugin_tag=PLUGIN_TAG,
        plugin_ver=PLUGIN_VER,
        dns_nameservers=DNS_NAMESERVERS,
        dns_domain=DNS_DOMAIN
    )


def get_nsxlib_config_with_client_cert():
    return config.NsxLibConfig(
        client_cert_provider=client_cert.ClientCertProvider(CLIENT_CERT),
        retries=NSX_HTTP_RETRIES,
        insecure=NSX_INSECURE,
        ca_file=NSX_CERT,
        concurrent_connections=NSX_CONCURENT_CONN,
        http_timeout=NSX_HTTP_TIMEOUT,
        http_read_timeout=NSX_HTTP_READ_TIMEOUT,
        conn_idle_timeout=NSX_CONN_IDLE_TIME,
        http_provider=None,
        nsx_api_managers=[],
        plugin_scope=PLUGIN_SCOPE,
        plugin_tag=PLUGIN_TAG,
        plugin_ver=PLUGIN_VER)


class NsxLibTestCase(unittest.TestCase):

    def use_client_cert_auth(self):
        return False

    def setUp(self, *args, **kwargs):
        super(NsxLibTestCase, self).setUp()
        _mock_nsxlib()

        if self.use_client_cert_auth():
            nsxlib_config = get_nsxlib_config_with_client_cert()
        else:
            nsxlib_config = get_default_nsxlib_config()

        self.nsxlib = v3.NsxLib(nsxlib_config)

        # print diffs when assert comparisons fail
        self.maxDiff = None


class MemoryMockAPIProvider(nsx_cluster.AbstractHTTPProvider):
    """Acts as a HTTP provider for mocking which is backed

    by a MockRequestSessionApi.
    """

    def __init__(self, mock_session_api):
        self._store = mock_session_api

    @property
    def provider_id(self):
        return "Memory mock API"

    def validate_connection(self, cluster_api, endpoint, conn):
        return

    def new_connection(self, cluster_api, provider):
        # all callers use the same backing
        return self._store

    def is_connection_exception(self, exception):
        return isinstance(exception, requests_exceptions.ConnectionError)


class NsxClientTestCase(NsxLibTestCase):

    class MockNSXClusteredAPI(nsx_cluster.NSXClusteredAPI):

        def __init__(
            self, session_response=None,
            username=None,
            password=None,
            retries=None,
            insecure=None,
            ca_file=None,
            concurrent_connections=None,
            http_timeout=None,
            http_read_timeout=None,
            conn_idle_timeout=None,
            nsx_api_managers=None):

            nsxlib_config = config.NsxLibConfig(
                username=username or NSX_USER,
                password=password or NSX_PASSWORD,
                retries=retries or NSX_HTTP_RETRIES,
                insecure=insecure if insecure is not None else NSX_INSECURE,
                ca_file=ca_file or NSX_CERT,
                concurrent_connections=(concurrent_connections or
                                        NSX_CONCURENT_CONN),
                http_timeout=http_timeout or NSX_HTTP_TIMEOUT,
                http_read_timeout=http_read_timeout or NSX_HTTP_READ_TIMEOUT,
                conn_idle_timeout=conn_idle_timeout or NSX_CONN_IDLE_TIME,
                http_provider=NsxClientTestCase.MockHTTPProvider(
                    session_response=session_response),
                nsx_api_managers=nsx_api_managers or [NSX_MANAGER],
                plugin_scope=PLUGIN_SCOPE,
                plugin_tag=PLUGIN_TAG,
                plugin_ver=PLUGIN_VER)

            super(NsxClientTestCase.MockNSXClusteredAPI, self).__init__(
                nsxlib_config)
            self._record = mock.Mock()

        def record_call(self, request, **kwargs):
            verb = request.method.lower()

            # filter out requests specific attributes
            checked_kwargs = copy.copy(kwargs)
            del checked_kwargs['proxies']
            del checked_kwargs['stream']
            if 'allow_redirects' in checked_kwargs:
                del checked_kwargs['allow_redirects']

            for attr in ['url', 'body']:
                checked_kwargs[attr] = getattr(request, attr, None)

            # remove headers we don't need to verify
            checked_kwargs['headers'] = copy.copy(request.headers)
            for header in ['Accept-Encoding', 'User-Agent',
                           'Connection', 'Authorization',
                           'Content-Length']:
                if header in checked_kwargs['headers']:
                    del checked_kwargs['headers'][header]

            checked_kwargs['headers'] = request.headers

            # record the call in the mock object
            method = getattr(self._record, verb)
            method(**checked_kwargs)

        def assert_called_once(self, verb, **kwargs):
            mock_call = getattr(self._record, verb.lower())
            mock_call.assert_called_once_with(**kwargs)

        def assert_any_call(self, verb, **kwargs):
            mock_call = getattr(self._record, verb.lower())
            mock_call.assert_any_call(**kwargs)

        @property
        def recorded_calls(self):
            return self._record

    class MockHTTPProvider(nsx_cluster.NSXRequestsHTTPProvider):

        def __init__(self, session_response=None):
            super(NsxClientTestCase.MockHTTPProvider, self).__init__()
            if isinstance(session_response, list):
                self._session_responses = session_response
            elif session_response:
                self._session_responses = [session_response]
            else:
                self._session_responses = None

        def new_connection(self, cluster_api, provider):
            # wrapper the session so we can intercept and record calls
            session = super(NsxClientTestCase.MockHTTPProvider,
                            self).new_connection(cluster_api, provider)

            mock_adapter = mock.Mock()
            session_send = session.send

            def _adapter_send(request, **kwargs):
                # record calls at the requests HTTP adapter level
                mock_response = mock.Mock()
                mock_response.history = None
                mock_response.headers = {'location': ''}
                # needed to bypass requests internal checks for mock
                mock_response.raw._original_response = {}

                # record the request for later verification
                cluster_api.record_call(request, **kwargs)
                return mock_response

            def _session_send(request, **kwargs):
                # calls at the Session level
                if self._session_responses:
                    # pop first response
                    current_response = self._session_responses[0]
                    del self._session_responses[0]
                    # consumer has setup a response for the session
                    cluster_api.record_call(request, **kwargs)
                    return (current_response()
                            if hasattr(current_response, '__call__')
                            else current_response)

                # bypass requests redirect handling for mock
                kwargs['allow_redirects'] = False

                # session send will end up calling adapter send
                return session_send(request, **kwargs)

            mock_adapter.send = _adapter_send
            session.send = _session_send

            def _mock_adapter(*args, **kwargs):
                # use our mock adapter rather than requests adapter
                return mock_adapter

            session.get_adapter = _mock_adapter
            return session

        def validate_connection(self, cluster_api, endpoint, conn):
            assert conn is not None

    def mock_nsx_clustered_api(self, session_response=None, **kwargs):
        return NsxClientTestCase.MockNSXClusteredAPI(                    
            session_response=session_response, **kwargs)                    

    def mocked_resource(self, resource_class, mock_validate=True,
                        session_response=None):
        mocked = resource_class(nsx_client.NSX3Client(
            self.mock_nsx_clustered_api(session_response=session_response),
            nsx_api_managers=[NSX_MANAGER],
            max_attempts=NSX_MAX_ATTEMPTS),
            nsxlib_config=get_default_nsxlib_config(),
            nsxlib=self.nsxlib)
        if mock_validate:
            mock.patch.object(mocked.client, '_validate_result').start()

        return mocked

    def new_mocked_client(self, client_class, mock_validate=True,
                          session_response=None, mock_cluster=None,
                          **kwargs):
        client = client_class(mock_cluster or self.mock_nsx_clustered_api(
            session_response=session_response), **kwargs)

        if mock_validate:
            mock.patch.object(client, '_validate_result').start()

        new_client_for = client.new_client_for

        def _new_client_for(*args, **kwargs):
            sub_client = new_client_for(*args, **kwargs)
            if mock_validate:
                mock.patch.object(sub_client, '_validate_result').start()
            return sub_client

        client.new_client_for = _new_client_for

        return client

    def new_mocked_cluster(self, conf_managers, validate_conn_func,
                           concurrent_connections=None):
        mock_provider = mock.Mock()
        mock_provider.default_scheme = 'https'
        mock_provider.validate_connection = validate_conn_func

        nsxlib_config = get_default_nsxlib_config()
        if concurrent_connections:
            nsxlib_config.concurrent_connections = concurrent_connections
        nsxlib_config.http_provider = mock_provider
        nsxlib_config.nsx_api_managers = conf_managers

        return nsx_cluster.NSXClusteredAPI(nsxlib_config)

    def assert_json_call(self, method, client, url,
                         headers=nsx_client.JSONRESTClient._DEFAULT_HEADERS,                    
                         timeout=(NSX_HTTP_TIMEOUT, NSX_HTTP_READ_TIMEOUT),
                         data=None):
        cluster = client._conn
        if data:
            data = jsonutils.dumps(data, sort_keys=True)
        cluster.assert_called_once(
            method,
            **{'url': url, 'verify': NSX_CERT, 'body': data,
               'headers': headers, 'cert': None, 'timeout': timeout})

# Copyright 2015 VMware, Inc.
# All Rights Reserved
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
import copy

from oslo_log import log
from oslo_serialization import jsonutils
import requests

from vmware_nsxlib.tests.unit.v3 import mocks
from vmware_nsxlib.tests.unit.v3 import nsxlib_testcase
from vmware_nsxlib.v3 import client
from vmware_nsxlib.v3 import exceptions as nsxlib_exc


LOG = log.getLogger(__name__)

CLIENT_PKG = 'vmware_nsxlib.v3.client'

DFT_ACCEPT_HEADERS = {
    'Accept': '*/*'                    
}


def _headers(**kwargs):
    headers = copy.copy(DFT_ACCEPT_HEADERS)
    headers.update(kwargs)
    return headers


def assert_call(verb, client_or_resource,
                url, verify=nsxlib_testcase.NSX_CERT,
                data=None, headers=DFT_ACCEPT_HEADERS,
                timeout=(nsxlib_testcase.NSX_HTTP_TIMEOUT,
                         nsxlib_testcase.NSX_HTTP_READ_TIMEOUT),
                single_call=True):
    nsx_client = client_or_resource
    if getattr(nsx_client, 'client', None) is not None:
        nsx_client = nsx_client.client
    cluster = nsx_client._conn
    if single_call:
        cluster.assert_called_once(
            verb,
            **{'url': url, 'verify': verify, 'body': data,
               'headers': headers, 'cert': None, 'timeout': timeout})
    else:
        cluster.assert_any_call(
            verb,
            **{'url': url, 'verify': verify, 'body': data,
               'headers': headers, 'cert': None, 'timeout': timeout})


def assert_json_call(verb, client_or_resource, url,
                     verify=nsxlib_testcase.NSX_CERT,
                     data=None,
                     headers=client.JSONRESTClient._DEFAULT_HEADERS,                    
                     single_call=True):
    return assert_call(verb, client_or_resource, url,
                       verify=verify, data=data,
                       headers=headers, single_call=single_call)


class NsxV3RESTClientTestCase(nsxlib_testcase.NsxClientTestCase):

    def test_client_url_prefix(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='/cloud/api')

        api.list()

        assert_call(
            'get', api,
            'https://1.2.3.4/cloud/api')

        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='/cloud/api')

        api.url_list('v1/ports')

        assert_call(
            'get', api,
            'https://1.2.3.4/cloud/api/v1/ports')

    def test_client_headers(self):
        default_headers = {'Content-Type': 'application/golang'}
        api = self.new_mocked_client(
            client.RESTClient, default_headers=default_headers,
            url_prefix='/v1/api')

        api.list()

        assert_call(
            'get', api,
            'https://1.2.3.4/v1/api',
            headers=_headers(**default_headers))

        api = self.new_mocked_client(
            client.RESTClient,
            default_headers=default_headers,
            url_prefix='/v1/api')

        method_headers = {'X-API-Key': 'strong-crypt'}
        api.url_list('ports/33', headers=method_headers)
        method_headers.update(default_headers)
        assert_call(
            'get', api,
            'https://1.2.3.4/v1/api/ports/33',
            headers=_headers(**method_headers))

    def test_client_for(self):
        api = self.new_mocked_client(client.RESTClient, url_prefix='api/v1/')
        sub_api = api.new_client_for('switch/ports')

        sub_api.get('11a2b')

        assert_call(
            'get', sub_api,
            'https://1.2.3.4/api/v1/switch/ports/11a2b')

    def test_client_list(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.list()

        assert_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports')

    def test_client_get(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.get('unique-id')

        assert_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports/unique-id')

    def test_client_delete(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.delete('unique-id')

        assert_call(
            'delete', api,
            'https://1.2.3.4/api/v1/ports/unique-id')

    def test_client_update(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.update('unique-id', jsonutils.dumps({'name': 'a-new-name'}))

        assert_call(
            'put', api,
            'https://1.2.3.4/api/v1/ports/unique-id',
            data=jsonutils.dumps({'name': 'a-new-name'}))

    def test_client_create(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.create(body=jsonutils.dumps({'resource-name': 'port1'}))

        assert_call(
            'post', api,
            'https://1.2.3.4/api/v1/ports',
            data=jsonutils.dumps({'resource-name': 'port1'}))

    def test_client_url_list(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')

        json_headers = {'Content-Type': 'application/json'}

        api.url_list('/connections', json_headers)

        assert_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports/connections',
            headers=_headers(**json_headers))

    def test_client_url_get(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.url_get('connections/1')

        assert_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports/connections/1')

    def test_client_url_delete(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.url_delete('1')

        assert_call(
            'delete', api,
            'https://1.2.3.4/api/v1/ports/1')

    def test_client_url_put(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.url_put('connections/1', jsonutils.dumps({'name': 'conn1'}))

        assert_call(
            'put', api,
            'https://1.2.3.4/api/v1/ports/connections/1',
            data=jsonutils.dumps({'name': 'conn1'}))

    def test_client_url_post(self):
        api = self.new_mocked_client(client.RESTClient,
                                     url_prefix='api/v1/ports')
        api.url_post('1/connections', jsonutils.dumps({'name': 'conn1'}))

        assert_call(
            'post', api,
            'https://1.2.3.4/api/v1/ports/1/connections',
            data=jsonutils.dumps({'name': 'conn1'}))

    def test_client_validate_result(self):

        def _verb_response_code(http_verb, status_code, error_code=None):
            content = None
            if error_code:
                content = jsonutils.dumps({'httpStatus': 'dummy',
                                           'error_code': error_code,
                                           'module_name': 'dummy',
                                           'error_message': 'bad'})
            response = mocks.MockRequestsResponse(
                status_code, content)

            client_api = self.new_mocked_client(
                client.RESTClient, mock_validate=False,
                session_response=response)

            client_call = getattr(client_api, "url_%s" % http_verb)
            client_call('', None)

        for verb in ['get', 'post', 'put', 'delete']:
            for code in client.RESTClient._VERB_RESP_CODES.get(verb):
                _verb_response_code(verb, code)
            self.assertRaises(
                nsxlib_exc.ManagerError,
                _verb_response_code, verb,
                requests.codes.INTERNAL_SERVER_ERROR)
            self.assertRaises(
                nsxlib_exc.ResourceNotFound,
                _verb_response_code, verb,
                requests.codes.NOT_FOUND)
            self.assertRaises(
                nsxlib_exc.BackendResourceNotFound,
                _verb_response_code, verb,
                requests.codes.NOT_FOUND, 202)


class NsxV3JSONClientTestCase(nsxlib_testcase.NsxClientTestCase):

    def test_json_request(self):
        resp = mocks.MockRequestsResponse(
            200, jsonutils.dumps({'result': {'ok': 200}}))

        api = self.new_mocked_client(client.JSONRESTClient,
                                     session_response=resp,
                                     url_prefix='api/v2/nat')

        resp = api.create(body={'name': 'mgmt-egress'})

        assert_json_call(
            'post', api,
            'https://1.2.3.4/api/v2/nat',
            data=jsonutils.dumps({'name': 'mgmt-egress'}))

        self.assertEqual(resp, {'result': {'ok': 200}})

    def test_mask_password(self):
        pwds = ('my!pwd0#', 'some0therlong$pwd', 'pwd')
        body = {'name_pwd': 'name1',
                'password': pwds[0],
                'some_list': {'name_password': 'name2',
                              'password': pwds[1]},
                'password': pwds[2]}

        cl = client.RESTClient(None)
        json_body = jsonutils.dumps(body)
        masked_body = cl._mask_password(json_body)
        for pwd in pwds:
            json_body = json_body.replace('"' + pwd + '"', '"********"')

        self.assertEqual(json_body, masked_body)


class NsxV3APIClientTestCase(nsxlib_testcase.NsxClientTestCase):

    def test_api_call(self):
        api = self.new_mocked_client(client.NSX3Client)
        api.get('ports')

        assert_json_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports')


# NOTE(boden): remove this when tmp brigding removed
class NsxV3APIClientBridgeTestCase(nsxlib_testcase.NsxClientTestCase):

    def test_get_resource(self):
        api = self.new_mocked_client(client.NSX3Client)
        api.get('ports')

        assert_json_call(
            'get', api,
            'https://1.2.3.4/api/v1/ports')

    def test_create_resource(self):
        api = self.new_mocked_client(client.NSX3Client)
        api.create('ports', {'resource-name': 'port1'})

        assert_json_call(
            'post', api,
            'https://1.2.3.4/api/v1/ports',
            data=jsonutils.dumps({'resource-name': 'port1'}))

    def test_update_resource(self):
        api = self.new_mocked_client(client.NSX3Client)
        api.update('ports/1', {'name': 'a-new-name'})

        assert_json_call(
            'put', api,
            'https://1.2.3.4/api/v1/ports/1',
            data=jsonutils.dumps({'name': 'a-new-name'}))

    def test_delete_resource(self):
        api = self.new_mocked_client(client.NSX3Client)
        api.delete('ports/11')

        assert_json_call(
            'delete', api,
            'https://1.2.3.4/api/v1/ports/11')

# Copyright 2015 VMware, Inc.
# All Rights Reserved
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
import unittest

import mock
from oslo_serialization import jsonutils
from requests import exceptions as requests_exceptions
import six.moves.urllib.parse as urlparse

from vmware_nsxlib.tests.unit.v3 import mocks
from vmware_nsxlib.tests.unit.v3 import nsxlib_testcase
from vmware_nsxlib.v3 import client
from vmware_nsxlib.v3 import client_cert
from vmware_nsxlib.v3 import cluster
from vmware_nsxlib.v3 import exceptions as nsxlib_exc


def _validate_conn_up(*args, **kwargs):
    return


def _validate_conn_down(*args, **kwargs):
    raise requests_exceptions.ConnectionError()


class RequestsHTTPProviderTestCase(unittest.TestCase):

    def test_new_connection(self):
        mock_api = mock.Mock()
        mock_api.nsxlib_config = mock.Mock()
        mock_api.nsxlib_config.username = 'nsxuser'
        mock_api.nsxlib_config.password = 'nsxpassword'
        mock_api.nsxlib_config.retries = 100
        mock_api.nsxlib_config.insecure = True
        mock_api.nsxlib_config.ca_file = None
        mock_api.nsxlib_config.http_timeout = 99
        mock_api.nsxlib_config.conn_idle_timeout = 39
        mock_api.nsxlib_config.client_cert_provider = None
        provider = cluster.NSXRequestsHTTPProvider()
        session = provider.new_connection(                    
            mock_api, cluster.Provider('9.8.7.6', 'https://9.8.7.6',                    
                                       'nsxuser', 'nsxpassword', None))                    

        self.assertEqual(('nsxuser', 'nsxpassword'), session.auth)                    
        self.assertFalse(session.verify)                    
        self.assertIsNone(session.cert)                    
        self.assertEqual(100, session.adapters['https://'].max_retries.total)                    
        self.assertEqual(99, session.timeout)                    

    def test_new_connection_with_client_auth(self):
        mock_api = mock.Mock()
        mock_api.nsxlib_config = mock.Mock()
        mock_api.nsxlib_config.retries = 100
        mock_api.nsxlib_config.insecure = True
        mock_api.nsxlib_config.ca_file = None
        mock_api.nsxlib_config.http_timeout = 99
        mock_api.nsxlib_config.conn_idle_timeout = 39
        cert_provider_inst = client_cert.ClientCertProvider(
            '/etc/cert.pem')
        mock_api.nsxlib_config.client_cert_provider = cert_provider_inst
        provider = cluster.NSXRequestsHTTPProvider()
        session = provider.new_connection(                    
            mock_api, cluster.Provider('9.8.7.6', 'https://9.8.7.6',                    
                                       None, None, None))                    

        self.assertIsNone(session.auth)                    
        self.assertFalse(session.verify)                    
        self.assertEqual(cert_provider_inst, session.cert_provider)                    
        self.assertEqual(99, session.timeout)                    

    def test_validate_connection(self):
        self.skipTest("Revist")
        mock_conn = mocks.MockRequestSessionApi()
        mock_ep = mock.Mock()
        mock_ep.provider.url = 'https://1.2.3.4'
        provider = cluster.NSXRequestsHTTPProvider()
        self.assertRaises(nsxlib_exc.ResourceNotFound,
                          provider.validate_connection,
                          mock.Mock(), mock_ep, mock_conn)

        mock_conn.post('api/v1/transport-zones',
                       data=jsonutils.dumps({'id': 'dummy-tz'}),
                       headers=client.JSONRESTClient._DEFAULT_HEADERS)
        provider.validate_connection(mock.Mock(), mock_ep, mock_conn)


class NsxV3ClusteredAPITestCase(nsxlib_testcase.NsxClientTestCase):

    def _assert_providers(self, cluster_api, provider_tuples):
        self.assertEqual(len(cluster_api.providers), len(provider_tuples))

        def _assert_provider(pid, purl):
            for provider in cluster_api.providers:
                if provider.id == pid and provider.url == purl:
                    return
            self.fail("Provider: %s not found" % pid)

        for provider_tuple in provider_tuples:
            _assert_provider(provider_tuple[0], provider_tuple[1])

    def test_conf_providers_no_scheme(self):
        conf_managers = ['8.9.10.11', '9.10.11.12:4433']
        api = self.new_mocked_cluster(conf_managers, _validate_conn_up)

        self._assert_providers(
            api, [(p, "https://%s" % p) for p in conf_managers])

    def test_conf_providers_with_scheme(self):
        conf_managers = ['http://8.9.10.11:8080', 'https://9.10.11.12:4433']
        api = self.new_mocked_cluster(conf_managers, _validate_conn_up)

        self._assert_providers(
            api, [(urlparse.urlparse(p).netloc, p) for p in conf_managers])

    def test_http_retries(self):
        api = self.mock_nsx_clustered_api(retries=9)
        with api.endpoints['1.2.3.4'].pool.item() as session:
            self.assertEqual(
                session.adapters['https://'].max_retries.total, 9)

    def test_conns_per_pool(self):
        conf_managers = ['8.9.10.11', '9.10.11.12:4433']
        api = self.new_mocked_cluster(
            conf_managers, _validate_conn_up,
            concurrent_connections=11)

        for ep_id, ep in api.endpoints.items():
            self.assertEqual(ep.pool.max_size, 11)

    def test_timeouts(self):
        api = self.mock_nsx_clustered_api(http_read_timeout=37, http_timeout=7)
        api.get('logical-ports')
        mock_call = api.recorded_calls.method_calls[0]
        name, args, kwargs = mock_call
        self.assertEqual(kwargs['timeout'], (7, 37))


# Repeat the above tests with client cert present
# in NsxLib initialization
class NsxV3ClusteredAPIWithClientCertTestCase(NsxV3ClusteredAPITestCase):

    def use_client_cert_auth(self):
        return True


class ClusteredAPITestCase(nsxlib_testcase.NsxClientTestCase):

    def _test_health(self, validate_fn, expected_health):
        conf_managers = ['8.9.10.11', '9.10.11.12']
        api = self.new_mocked_cluster(conf_managers, validate_fn)

        self.assertEqual(expected_health, api.health)

    def test_orange_health(self):

        def _validate(cluster_api, endpoint, conn):
            if endpoint.provider.id == '8.9.10.11':
                raise Exception()

        self._test_health(_validate, cluster.ClusterHealth.ORANGE)

    def test_green_health(self):
        self._test_health(_validate_conn_up, cluster.ClusterHealth.GREEN)

    def test_red_health(self):
        self._test_health(_validate_conn_down, cluster.ClusterHealth.RED)

    def test_cluster_validate_with_exception(self):
        conf_managers = ['8.9.10.11', '9.10.11.12', '10.11.12.13']
        api = self.new_mocked_cluster(conf_managers, _validate_conn_down)

        self.assertEqual(3, len(api.endpoints))
        self.assertRaises(nsxlib_exc.ServiceClusterUnavailable,
                          api.get, 'api/v1/transport-zones')

    def test_cluster_proxy_stale_revision(self):

        def stale_revision():
            raise nsxlib_exc.StaleRevision(manager='1.1.1.1',
                                           operation='whatever')

        api = self.mock_nsx_clustered_api(session_response=stale_revision)
        self.assertRaises(nsxlib_exc.StaleRevision,
                          api.get, 'api/v1/transport-zones')

    def test_cluster_proxy_connection_error(self):

        def connect_timeout():
            raise requests_exceptions.ConnectTimeout()

        api = self.mock_nsx_clustered_api(session_response=connect_timeout)
        api._validate = mock.Mock()
        self.assertRaises(nsxlib_exc.ServiceClusterUnavailable,
                          api.get, 'api/v1/transport-zones')

    def test_cluster_round_robin_servicing(self):
        conf_managers = ['8.9.10.11', '9.10.11.12', '10.11.12.13']
        api = self.mock_nsx_clustered_api(nsx_api_managers=conf_managers)
        api._validate = mock.Mock()

        eps = list(api._endpoints.values())

        def _get_schedule(num_eps):
            return [api._select_endpoint() for i in range(num_eps)]

        self.assertEqual(_get_schedule(3), eps)

        self.assertEqual(_get_schedule(6), [eps[0], eps[1], eps[2],
                                            eps[0], eps[1], eps[2]])

        eps[0]._state = cluster.EndpointState.DOWN
        self.assertEqual(_get_schedule(4), [eps[1], eps[2], eps[1], eps[2]])

        eps[1]._state = cluster.EndpointState.DOWN
        self.assertEqual(_get_schedule(2), [eps[2], eps[2]])

        eps[0]._state = cluster.EndpointState.UP
        self.assertEqual(_get_schedule(4), [eps[0], eps[2], eps[0], eps[2]])

    def test_reinitialize_cluster(self):
        api = self.mock_nsx_clustered_api()                    
        # just make sure this api is defined, and does not crash
        api._reinit_cluster()                    

# Copyright 2015 VMware, Inc.
# All Rights Reserved
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
import abc
import contextlib
import copy
import datetime
import itertools
import logging

import eventlet
from eventlet import greenpool
from eventlet import pools
import OpenSSL
from oslo_log import log
from oslo_service import loopingcall
import requests
from requests import adapters
from requests import exceptions as requests_exceptions
import six
import six.moves.urllib.parse as urlparse

from vmware_nsxlib._i18n import _
from vmware_nsxlib.v3 import client as nsx_client
from vmware_nsxlib.v3 import exceptions


LOG = log.getLogger(__name__)

# disable warning message for each HTTP retry
logging.getLogger(
    "requests.packages.urllib3.connectionpool").setLevel(logging.ERROR)


@six.add_metaclass(abc.ABCMeta)
class AbstractHTTPProvider(object):
    """Interface for providers of HTTP connections.

    which are responsible for creating and validating connections
    for their underlying HTTP support.
    """
    @property
    def default_scheme(self):
        return 'https'

    @abc.abstractproperty
    def provider_id(self):
        """A unique string name for this provider."""
        pass

    @abc.abstractmethod
    def validate_connection(self, cluster_api, endpoint, conn):
        """Validate the said connection for the given endpoint and cluster."""
        pass

    @abc.abstractmethod
    def new_connection(self, cluster_api, provider):
        """Create a new http connection.

        Create a new http connection for the said cluster and
        cluster provider. The actual connection should duck type
        requests.Session http methods (get(), put(), etc.).
        """
        pass

    @abc.abstractmethod
    def is_connection_exception(self, exception):
        """Determine if the given exception is related to connection failure.

        Return True if it's a connection exception and False otherwise.
        """


class TimeoutSession(requests.Session):
    """Extends requests.Session to support timeout at the session level."""

    def __init__(self, timeout, read_timeout):
        self.timeout = timeout
        self.read_timeout = read_timeout
        self.cert_provider = None
        super(TimeoutSession, self).__init__()

    @property
    def cert_provider(self):
        return self._cert_provider

    @cert_provider.setter
    def cert_provider(self, value):
        self._cert_provider = value

    # wrapper timeouts at the session level
    # see: https://goo.gl/xNk7aM
    def request(self, *args, **kwargs):
        if 'timeout' not in kwargs:
            kwargs['timeout'] = (self.timeout, self.read_timeout)

        if not self._cert_provider:                    
            return super(TimeoutSession, self).request(*args, **kwargs)

        if self.cert is not None:
            # connection should be open (unless server closed it),
            # in which case cert is not needed
            try:
                return super(TimeoutSession, self).request(*args, **kwargs)
            except OpenSSL.SSL.Error as e:
                # This is most probably "client cert not found" error (this
                # happens when server closed the connection and requests
                # reopen it). Try reloading client cert.
                LOG.debug("SSL error: %s, retrying.." % e)
            except (OSError, IOError) as e:
                # Lack of client cert file can come in form of OSError/IOError.
                # Try reloading client cert. No good way to narrow the error
                # based on text since they come in different flavors.
                # We don't print the error to avoid exposing cert file name in
                # the logs
                LOG.info("Reloading client certificate..")

        # The following with statement allows for preparing certificate and
        # private key file and dispose it once connections are spawned
        # (since PK is sensitive information, immediate disposal is
        # important). This is done of first request of the session or when
        # above exceptions indicate cert is missing.
        with self._cert_provider:
            self.cert = self._cert_provider.filename()
            ret = super(TimeoutSession, self).request(*args, **kwargs)

        return ret


class NSXRequestsHTTPProvider(AbstractHTTPProvider):
    """Concrete implementation of AbstractHTTPProvider.

    using requests.Session() as the underlying connection.
    """

    @property
    def provider_id(self):
        return "%s-%s" % (requests.__title__, requests.__version__)

    def validate_connection(self, cluster_api, endpoint, conn):
        client = nsx_client.NSX3Client(
            conn, url_prefix=endpoint.provider.url,
            url_path_base=cluster_api.nsxlib_config.url_base)                    
        keepalive_section = cluster_api.nsxlib_config.keepalive_section
        result = client.get(keepalive_section, silent=True)
        # If keeplive section returns a list, it is assumed to be non-empty
        if not result or result.get('result_count', 1) <= 0:
            msg = _("No %(section)s found "
                    "for '%(url)s'") % {'section': keepalive_section,
                                        'url': endpoint.provider.url}
            LOG.warning(msg)
            raise exceptions.ResourceNotFound(
                manager=endpoint.provider.url, operation=msg)

    def new_connection(self, cluster_api, provider):
        config = cluster_api.nsxlib_config
        session = TimeoutSession(config.http_timeout,
                                 config.http_read_timeout)
        if config.client_cert_provider:
            session.cert_provider = config.client_cert_provider
        else:
            session.auth = (provider.username, provider.password)

        # NSX v3 doesn't use redirects
        session.max_redirects = 0

        session.verify = not config.insecure
        if session.verify and provider.ca_file:
            # verify using the said ca bundle path
            session.verify = provider.ca_file

        # we are pooling with eventlet in the cluster class
        adapter = adapters.HTTPAdapter(
            pool_connections=1, pool_maxsize=1,
            max_retries=config.retries,
            pool_block=False)
        session.mount('http://', adapter)
        session.mount('https://', adapter)

        return session

    def is_connection_exception(self, exception):
        return isinstance(exception, requests_exceptions.ConnectionError)


class ClusterHealth(object):
    """Indicator of overall cluster health.

    with respect to the connectivity of the clusters managed endpoints.
    """
    # all endpoints are UP
    GREEN = 'GREEN'
    # at least 1 endpoint is UP, but 1 or more are DOWN
    ORANGE = 'ORANGE'
    # all endpoints are DOWN
    RED = 'RED'


class EndpointState(object):
    """Tracks the connectivity state for a said endpoint."""
    # no UP or DOWN state recorded yet
    INITIALIZED = 'INITIALIZED'
    # endpoint has been validate and is good
    UP = 'UP'
    # endpoint can't be reached or validated
    DOWN = 'DOWN'


class Provider(object):
    """Data holder for a provider

    Which has a unique id a connection URL, and the credential details.
    """

    def __init__(self, provider_id, provider_url, username, password, ca_file):
        self.id = provider_id
        self.url = provider_url
        self.username = username
        self.password = password
        self.ca_file = ca_file

    def __str__(self):
        return str(self.url)


class Endpoint(object):
    """A single NSX manager endpoint (host).

    A single NSX manager endpoint (host) which includes
    related information such as the endpoint's provider,
    state, etc.. A pool is used to hold connections to the
    endpoint which are doled out when proxying HTTP methods
    to the underlying connections.
    """

    def __init__(self, provider, pool):
        self.provider = provider
        self.pool = pool
        self._state = EndpointState.INITIALIZED
        self._last_updated = datetime.datetime.now()

    def regenerate_pool(self):
        self.pool = pools.Pool(min_size=self.pool.min_size,
                               max_size=self.pool.max_size,
                               order_as_stack=True,
                               create=self.pool.create)

    @property
    def last_updated(self):
        return self._last_updated

    @property
    def state(self):
        return self._state

    def set_state(self, state):
        if self.state != state:
            LOG.info("Endpoint '%(ep)s' changing from state"
                     " '%(old)s' to '%(new)s'",
                     {'ep': self.provider,
                      'old': self.state,
                      'new': state})
        old_state = self._state
        self._state = state

        self._last_updated = datetime.datetime.now()

        return old_state

    def __str__(self):
        return "[%s] %s" % (self.state, self.provider)


class EndpointConnection(object):
    """Simple data holder

    Which contains an endpoint and a connection for that endpoint.
    """

    def __init__(self, endpoint, connection):
        self.endpoint = endpoint
        self.connection = connection


class ClusteredAPI(object):
    """Duck types the major HTTP based methods of a requests.Session

    Such as get(), put(), post(), etc.
    and transparently proxies those calls to one of
    its managed NSX manager endpoints.
    """
    _HTTP_VERBS = ['get', 'delete', 'head', 'put', 'post', 'patch', 'create']

    def __init__(self, providers,
                 http_provider,
                 min_conns_per_pool=1,
                 max_conns_per_pool=500,
                 keepalive_interval=33):

        self._http_provider = http_provider
        self._keepalive_interval = keepalive_interval

        def _init_cluster(*args, **kwargs):
            self._init_endpoints(providers,
                                 min_conns_per_pool, max_conns_per_pool)

        _init_cluster()

        # keep this internal method for reinitialize upon fork
        # for api workers to ensure each process has its own keepalive
        # loops + state
        self._reinit_cluster = _init_cluster

    def _init_endpoints(self, providers,
                        min_conns_per_pool, max_conns_per_pool):
        LOG.debug("Initializing API endpoints")

        def _create_conn(p):
            def _conn():
                # called when a pool needs to create a new connection
                return self._http_provider.new_connection(self, p)

            return _conn

        self._endpoints = {}
        for provider in providers:
            pool = pools.Pool(
                min_size=min_conns_per_pool,
                max_size=max_conns_per_pool,
                order_as_stack=True,
                create=_create_conn(provider))

            endpoint = Endpoint(provider, pool)
            self._endpoints[provider.id] = endpoint

        # service requests using round robin
        self._endpoint_schedule = itertools.cycle(self._endpoints.values())

        # duck type to proxy http invocations
        for method in ClusteredAPI._HTTP_VERBS:
            setattr(self, method, self._proxy_stub(method))

        conns = greenpool.GreenPool()
        for endpoint in self._endpoints.values():
            conns.spawn(self._validate, endpoint)
        eventlet.sleep(0)
        while conns.running():
            if (self.health == ClusterHealth.GREEN
                    or self.health == ClusterHealth.ORANGE):
                # only wait for 1 or more endpoints to reduce init time
                break
            eventlet.sleep(0.5)

        for endpoint in self._endpoints.values():
            # dynamic loop for each endpoint to ensure connectivity
            loop = loopingcall.DynamicLoopingCall(
                self._endpoint_keepalive, endpoint)
            loop.start(initial_delay=self._keepalive_interval,
                       periodic_interval_max=self._keepalive_interval,
                       stop_on_exception=False)

        LOG.debug("Done initializing API endpoint(s). "
                  "API cluster health: %s", self.health)

    def _endpoint_keepalive(self, endpoint):
        delta = datetime.datetime.now() - endpoint.last_updated
        if delta.seconds >= self._keepalive_interval:
            # TODO(boden): backoff on validation failure
            self._validate(endpoint)
            return self._keepalive_interval
        return self._keepalive_interval - delta.seconds

    @property
    def providers(self):
        return [ep.provider for ep in self._endpoints.values()]

    @property
    def endpoints(self):
        return copy.copy(self._endpoints)

    @property
    def http_provider(self):
        return self._http_provider

    @property
    def health(self):
        down = 0
        up = 0
        for endpoint in self._endpoints.values():
            if endpoint.state != EndpointState.UP:
                down += 1
            else:
                up += 1

        if down == len(self._endpoints):
            return ClusterHealth.RED
        return (ClusterHealth.GREEN
                if up == len(self._endpoints)
                else ClusterHealth.ORANGE)

    def _validate(self, endpoint):
        try:
            with endpoint.pool.item() as conn:
                self._http_provider.validate_connection(self, endpoint, conn)
                endpoint.set_state(EndpointState.UP)
        except exceptions.ClientCertificateNotTrusted:
            LOG.warning("Failed to validate API cluster endpoint "
                        "'%(ep)s' due to untrusted client certificate",
                        {'ep': endpoint})
            # regenerate connection pool based on new certificate
            endpoint.regenerate_pool()
        except Exception as e:
            endpoint.set_state(EndpointState.DOWN)
            LOG.warning("Failed to validate API cluster endpoint "
                        "'%(ep)s' due to: %(err)s",
                        {'ep': endpoint, 'err': e})

    def _select_endpoint(self):
        # check for UP state until exhausting all endpoints
        seen, total = 0, len(self._endpoints.values())
        while seen < total:
            endpoint = next(self._endpoint_schedule)
            if endpoint.state == EndpointState.UP:
                return endpoint
            seen += 1

    def endpoint_for_connection(self, conn):
        # check all endpoint pools
        for endpoint in self._endpoints.values():
            if (conn in endpoint.pool.channel.queue or
                    conn in endpoint.pool.free_items):
                return endpoint

    @property
    def cluster_id(self):
        return ','.join([str(ep.provider.url)
                         for ep in self._endpoints.values()])

    @contextlib.contextmanager
    def connection(self):
        with self.endpoint_connection() as conn_data:
            yield conn_data.connection

    @contextlib.contextmanager
    def endpoint_connection(self):
        endpoint = self._select_endpoint()
        if not endpoint:
            LOG.debug("All endpoints down for: %s" %
                      [str(ep) for ep in self._endpoints.values()])
            # all endpoints are DOWN and will have their next
            # state updated as per _endpoint_keepalive()
            raise exceptions.ServiceClusterUnavailable(
                cluster_id=self.cluster_id)

        if endpoint.pool.free() == 0:
            LOG.info("API endpoint %(ep)s at connection "
                     "capacity %(max)s and has %(waiting)s waiting",
                     {'ep': endpoint,
                      'max': endpoint.pool.max_size,
                      'waiting': endpoint.pool.waiting()})
        # pool.item() will wait if pool has 0 free
        with endpoint.pool.item() as conn:
            yield EndpointConnection(endpoint, conn)

    def _proxy_stub(self, proxy_for):
        def _call_proxy(url, *args, **kwargs):
            return self._proxy(proxy_for, url, *args, **kwargs)
        return _call_proxy

    def _proxy(self, proxy_for, uri, *args, **kwargs):
        # proxy http request call to an avail endpoint
        with self.endpoint_connection() as conn_data:
            conn = conn_data.connection
            endpoint = conn_data.endpoint

            # http conn must support requests style interface
            do_request = getattr(conn, proxy_for)

            if not uri.startswith('/'):
                uri = "/%s" % uri
            url = "%s%s" % (endpoint.provider.url, uri)
            try:
                LOG.debug("API cluster proxy %s %s to %s",
                          proxy_for.upper(), uri, url)
                # call the actual connection method to do the
                # http request/response over the wire
                response = do_request(url, *args, **kwargs)
                endpoint.set_state(EndpointState.UP)

                return response
            except Exception as e:
                LOG.warning("Request failed due to: %s", e)
                if not self._http_provider.is_connection_exception(e):
                    # only trap and retry connection errors
                    raise e
                endpoint.set_state(EndpointState.DOWN)
                LOG.debug("Connection to %s failed, checking additional "
                          "endpoints" % url)
                # retry until exhausting endpoints
                return self._proxy(proxy_for, uri, *args, **kwargs)


class NSXClusteredAPI(ClusteredAPI):
    """Extends ClusteredAPI to get conf values and setup the NSXv3 cluster."""

    def __init__(self, nsxlib_config):
        self.nsxlib_config = nsxlib_config

        self._http_provider = (nsxlib_config.http_provider or
                               NSXRequestsHTTPProvider())

        super(NSXClusteredAPI, self).__init__(
            self._build_conf_providers(),
            self._http_provider,
            max_conns_per_pool=self.nsxlib_config.concurrent_connections,
            keepalive_interval=self.nsxlib_config.conn_idle_timeout)

        LOG.debug("Created NSX clustered API with '%s' "
                  "provider", self._http_provider.provider_id)

    def _build_conf_providers(self):

        def _schemed_url(uri):
            uri = uri.strip('/')
            return urlparse.urlparse(
                uri if uri.startswith('http') else
                "%s://%s" % (self._http_provider.default_scheme, uri))

        conf_urls = self.nsxlib_config.nsx_api_managers[:]
        urls = []
        providers = []
        provider_index = -1
        for conf_url in conf_urls:
            provider_index += 1
            conf_url = _schemed_url(conf_url)
            if conf_url in urls:
                LOG.warning("'%s' already defined in configuration file. "
                            "Skipping.", urlparse.urlunparse(conf_url))
                continue
            urls.append(conf_url)
            providers.append(
                Provider(
                    conf_url.netloc,
                    urlparse.urlunparse(conf_url),
                    self.nsxlib_config.username(provider_index),
                    self.nsxlib_config.password(provider_index),
                    self.nsxlib_config.ca_file(provider_index)))
        return providers

# Copyright 2015 VMware, Inc.
# All Rights Reserved
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#
import re
import time

from oslo_log import log
from oslo_serialization import jsonutils
import requests
import six.moves.urllib.parse as urlparse
from vmware_nsxlib._i18n import _
from vmware_nsxlib.v3 import exceptions
from vmware_nsxlib.v3 import utils

LOG = log.getLogger(__name__)

NULL_CURSOR_PREFIX = '0000'


def http_error_to_exception(status_code, error_code):
    errors = {
        requests.codes.NOT_FOUND:
            {'202': exceptions.BackendResourceNotFound,
             'default': exceptions.ResourceNotFound},
        requests.codes.PRECONDITION_FAILED: exceptions.StaleRevision,
        requests.codes.INTERNAL_SERVER_ERROR:
            {'99': exceptions.ClientCertificateNotTrusted}}                    

    if status_code in errors:
        if isinstance(errors[status_code], dict):
            # choose based on error code
            if error_code and str(error_code) in errors[status_code]:
                return errors[status_code][str(error_code)]
            elif 'default' in errors[status_code]:
                return errors[status_code]['default']
        else:
            return errors[status_code]

    # default exception
    return exceptions.ManagerError


class RESTClient(object):

    _VERB_RESP_CODES = {
        'get': [requests.codes.ok],
        'post': [requests.codes.created, requests.codes.ok],
        'put': [requests.codes.created, requests.codes.ok],
        'delete': [requests.codes.ok]
    }

    def __init__(self, connection, url_prefix=None,
                 default_headers=None,
                 client_obj=None):
        self._conn = connection
        self._url_prefix = url_prefix or ""
        self._default_headers = default_headers or {}

    def new_client_for(self, *uri_segments):
        uri = self._build_url('/'.join(uri_segments))

        return self.__class__(
            self._conn,
            url_prefix=uri,
            default_headers=self._default_headers,
            client_obj=self)

    def list(self, resource='', headers=None, silent=False):
        return self.url_list(resource, headers=headers, silent=silent)

    def get(self, uuid, headers=None, silent=False):
        return self.url_get(uuid, headers=headers, silent=silent)

    def delete(self, uuid, headers=None):
        return self.url_delete(uuid, headers=headers)

    def update(self, uuid, body=None, headers=None):
        return self.url_put(uuid, body, headers=headers)

    def create(self, resource='', body=None, headers=None):
        return self.url_post(resource, body, headers=headers)

    def url_list(self, url, headers=None, silent=False):
        concatenate_response = self.url_get(url, headers=headers)
        cursor = concatenate_response.get('cursor', NULL_CURSOR_PREFIX)
        op = '&' if urlparse.urlparse(url).query else '?'
        url += op + 'cursor='

        while cursor and not cursor.startswith(NULL_CURSOR_PREFIX):
            page = self.url_get(url + cursor, headers=headers, silent=silent)
            concatenate_response['results'].extend(page.get('results', []))
            cursor = page.get('cursor', NULL_CURSOR_PREFIX)
        return concatenate_response

    def url_get(self, url, headers=None, silent=False):
        return self._rest_call(url, method='GET', headers=headers,
                               silent=silent)

    def url_delete(self, url, headers=None):
        return self._rest_call(url, method='DELETE', headers=headers)

    def url_put(self, url, body, headers=None):
        return self._rest_call(url, method='PUT', body=body, headers=headers)

    def url_post(self, url, body, headers=None):
        return self._rest_call(url, method='POST', body=body, headers=headers)

    def _raise_error(self, status_code, operation, result_msg,
                     error_code=None):
        error = http_error_to_exception(status_code, error_code)
        raise error(manager='', operation=operation, details=result_msg,
                    error_code=error_code)

    def _validate_result(self, result, expected, operation, silent=False):
        if result.status_code not in expected:
            result_msg = result.json() if result.content else ''
            if not silent:
                LOG.warning("The HTTP request returned error code "
                            "%(result)s, whereas %(expected)s response "
                            "codes were expected. Response body %(body)s",
                            {'result': result.status_code,
                             'expected': '/'.join([str(code)
                                                   for code in expected]),
                             'body': result_msg})

            error_code = None
            if isinstance(result_msg, dict) and 'error_message' in result_msg:
                error_code = result_msg.get('error_code')
                related_errors = [error['error_message'] for error in
                                  result_msg.get('related_errors', [])]
                result_msg = result_msg['error_message']
                if related_errors:
                    result_msg += " relatedErrors: %s" % ' '.join(
                        related_errors)
            self._raise_error(result.status_code, operation, result_msg,
                              error_code=error_code)

    @classmethod
    def merge_headers(cls, *headers):
        merged = {}
        for header in headers:
            if header:
                merged.update(header)
        return merged

    def _build_url(self, uri):
        prefix = urlparse.urlparse(self._url_prefix)
        uri = ("/%s/%s" % (prefix.path, uri)).replace('//', '/').strip('/')
        if prefix.netloc:
            uri = "%s/%s" % (prefix.netloc, uri)
        if prefix.scheme:
            uri = "%s://%s" % (prefix.scheme, uri)
        return uri

    def _mask_password(self, json):
        '''Mask password value in json format'''
        if not json:
            return json

        pattern = r'\"password\": [^,}]*'
        return re.sub(pattern, '"password": "********"', json)

    def _rest_call(self, url, method='GET', body=None, headers=None,
                   silent=False):
        request_headers = headers.copy() if headers else {}
        request_headers.update(self._default_headers)
        request_url = self._build_url(url)

        do_request = getattr(self._conn, method.lower())
        if not silent:

            LOG.debug("REST call: %s %s. Headers: %s. Body: %s",
                      method, request_url, request_headers,
                      self._mask_password(body))

        ts = time.time()
        result = do_request(
            request_url,
            data=body,
            headers=request_headers)
        te = time.time()

        if not silent:
            LOG.debug("REST call: %s %s. Response: %s. Took %2.4f",
                      method, request_url,
                      result.json() if result.content else '',
                      te - ts)

        self._validate_result(
            result, RESTClient._VERB_RESP_CODES[method.lower()],
            _("%(verb)s %(url)s") % {'verb': method, 'url': request_url},
            silent=silent)
        return result


class JSONRESTClient(RESTClient):

    _DEFAULT_HEADERS = {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }

    def __init__(self, connection, url_prefix=None,
                 default_headers=None,
                 client_obj=None):

        super(JSONRESTClient, self).__init__(
            connection,
            url_prefix=url_prefix,
            default_headers=RESTClient.merge_headers(
                JSONRESTClient._DEFAULT_HEADERS, default_headers),
            client_obj=None)

    def _rest_call(self, *args, **kwargs):
        if kwargs.get('body') is not None:
            kwargs['body'] = jsonutils.dumps(kwargs['body'], sort_keys=True)
        result = super(JSONRESTClient, self)._rest_call(*args, **kwargs)
        return result.json() if result.content else result


class NSX3Client(JSONRESTClient):

    NSX_V1_API_PREFIX = 'api/v1/'
    NSX_POLICY_V1_API_PREFIX = 'policy/api/v1/'

    def __init__(self, connection, url_prefix=None,
                 default_headers=None,
                 nsx_api_managers=None,
                 max_attempts=utils.DEFAULT_MAX_ATTEMPTS,
                 client_obj=None,
                 url_path_base=NSX_V1_API_PREFIX):

        # If the client obj is defined - copy configuration from it
        if client_obj:
            self.nsx_api_managers = client_obj.nsx_api_managers or []
            self.max_attempts = client_obj.max_attempts
        else:
            self.nsx_api_managers = nsx_api_managers or []
            self.max_attempts = max_attempts

        url_prefix = url_prefix or url_path_base
        if url_prefix and url_path_base not in url_prefix:
            if url_prefix.startswith('http'):
                url_prefix += '/' + url_path_base
            else:
                url_prefix = "%s/%s" % (url_path_base,
                                        url_prefix or '')
        self.max_attempts = max_attempts

        super(NSX3Client, self).__init__(
            connection, url_prefix=url_prefix,
            default_headers=default_headers,
            client_obj=client_obj)

    def _raise_error(self, status_code, operation, result_msg,
                     error_code=None):
        """Override the Rest client errors to add the manager IPs"""
        error = http_error_to_exception(status_code, error_code)
        raise error(manager=self.nsx_api_managers,
                    operation=operation,
                    details=result_msg,
                    error_code=error_code)


#! /usr/bin/env python

# Allmydata Tahoe -- secure, distributed storage grid
# 
# Copyright (C) 2007 Allmydata, Inc.
# 
# This file is part of tahoe.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version, with the added permission that, if you become obligated
# to release a derived work under this licence (as per section 2.b), you may
# delay the fulfillment of this obligation for up to 12 months.  See the file
# COPYING for details.
#
# If you would like to inquire about a commercial relationship with Allmydata,
# Inc., please contact partnerships@allmydata.com and visit
# http://allmydata.com/.

import re, os.path
from distutils.core import Extension, setup

trove_classifiers=[
    "Development Status :: 3 - Alpha", 
    "Environment :: Console",
    "Environment :: Web Environment",
    "License :: OSI Approved :: GNU General Public License (GPL)", 
    "License :: DFSG approved",
    "Intended Audience :: Developers", 
    "Intended Audience :: End Users/Desktop",
    "Intended Audience :: System Administrators",
    "Operating System :: Microsoft",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: Unix",
    "Operating System :: POSIX :: Linux",
    "Operating System :: POSIX",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows :: Windows NT/2000",
    "Operating System :: OS Independent", 
    "Natural Language :: English", 
    "Programming Language :: C", 
    "Programming Language :: Python", 
    "Topic :: Utilities",
    "Topic :: System :: Systems Administration",
    "Topic :: System :: Filesystems",
    "Topic :: System :: Distributed Computing",
    "Topic :: Software Development :: Libraries",
    "Topic :: Communications :: Usenet News",
    "Topic :: System :: Archiving :: Backup", 
    "Topic :: System :: Archiving :: Mirroring", 
    "Topic :: System :: Archiving", 
    ]


VERSIONFILE = "src/allmydata/version.py"
verstr = "unknown"
if os.path.exists(VERSIONFILE):
    VSRE = re.compile("^verstr = ['\"]([^'\"]*)['\"]", re.M)
    verstrline = open(VERSIONFILE, "rt").read()
    mo = VSRE.search(verstrline)
    if mo:
        verstr = mo.group(1)
    else:
        print "unable to find version in version.py"
        raise RuntimeError("if version.py exists, it must be well-formed")

setup(name='allmydata-tahoe',
      version=verstr,
      description='secure, distributed storage grid',
      long_description="""Welcome to the AllMyData "tahoe" project. This project implements a
secure, distributed, fault-tolerant storage grid.

The basic idea is that the data in this storage grid is spread over all
participating nodes, using an algorithm that can recover the data even if a
majority of the nodes are no longer available.""",
      author='Allmydata, Inc.',
      author_email='tahoe-dev@allmydata.org',
      url='http://allmydata.org/',
      license='GNU GPL',
      packages=["allmydata", "allmydata.test", "allmydata.util",
                "allmydata.scripts",],
      package_dir={ "allmydata": "src/allmydata",},
      scripts = ["bin/allmydata-tahoe"],
      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },                    
      classifiers=trove_classifiers,
      test_suite="allmydata.test",
      )


import os, sha, stat, time, re
from foolscap import Referenceable, SturdyRef
from zope.interface import implements
from allmydata.interfaces import RIClient
from allmydata import node

from twisted.internet import reactor
from twisted.application.internet import TimerService
from twisted.python import log

import allmydata
from allmydata.Crypto.Util.number import bytes_to_long
from allmydata.storage import StorageServer
from allmydata.upload import Uploader
from allmydata.download import Downloader
from allmydata.webish import WebishServer
from allmydata.control import ControlServer
from allmydata.introducer import IntroducerClient
from allmydata.vdrive import VirtualDrive

class Client(node.Node, Referenceable):
    implements(RIClient)
    PORTNUMFILE = "client.port"
    STOREDIR = 'storage'
    NODETYPE = "client"
    WEBPORTFILE = "webport"
    WEB_ALLOW_LOCAL_ACCESS_FILE = "webport_allow_localfile"
    INTRODUCER_FURL_FILE = "introducer.furl"
    MY_FURL_FILE = "myself.furl"
    SUICIDE_PREVENTION_HOTLINE_FILE = "suicide_prevention_hotline"
    SIZELIMIT_FILE = "sizelimit"
    PUSH_TO_OURSELVES_FILE = "push_to_ourselves"

    # we're pretty narrow-minded right now
    OLDEST_SUPPORTED_VERSION = allmydata.__version__

    def __init__(self, basedir="."):
        node.Node.__init__(self, basedir)
        self.my_furl = None
        self.introducer_client = None
        self.init_storage()
        self.init_options()
        self.add_service(Uploader())
        self.add_service(Downloader())
        self.add_service(VirtualDrive())
        try:
            webport = open(os.path.join(self.basedir, self.WEBPORTFILE),
                           "r").read().strip() # strports string
        except EnvironmentError:
            pass # absent or unreadable webport file
        else:
            ws = WebishServer(webport)                    
            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                    
                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))                    
            self.add_service(ws)                    

        INTRODUCER_FURL_FILE = os.path.join(self.basedir,
                                            self.INTRODUCER_FURL_FILE)
        self.introducer_furl = open(INTRODUCER_FURL_FILE, "r").read().strip()

        hotline_file = os.path.join(self.basedir,
                                    self.SUICIDE_PREVENTION_HOTLINE_FILE)
        if os.path.exists(hotline_file):
            self.log("hotline file noticed, starting timer")
            hotline = TimerService(1.0, self._check_hotline, hotline_file)
            hotline.setServiceParent(self)

    def init_storage(self):
        storedir = os.path.join(self.basedir, self.STOREDIR)
        sizelimit = None

        try:
            data = open(os.path.join(self.basedir, self.SIZELIMIT_FILE),
                        "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable sizelimit file
        else:
            m = re.match(r"^(\d+)([kKmMgG]?[bB]?)$", data)
            if not m:
                log.msg("SIZELIMIT_FILE contains unparseable value %s" % data)
            else:
                number, suffix = m.groups()
                suffix = suffix.upper()
                if suffix.endswith("B"):
                    suffix = suffix[:-1]
                multiplier = {"": 1,
                              "K": 1000,
                              "M": 1000 * 1000,
                              "G": 1000 * 1000 * 1000,
                              }[suffix]
                sizelimit = int(number) * multiplier
        NOSTORAGE_FILE = os.path.join(self.basedir, "debug_no_storage")
        no_storage = os.path.exists(NOSTORAGE_FILE)
        self.add_service(StorageServer(storedir, sizelimit, no_storage))

    def init_options(self):
        self.push_to_ourselves = None
        filename = os.path.join(self.basedir, self.PUSH_TO_OURSELVES_FILE)
        if os.path.exists(filename):
            self.push_to_ourselves = True

    def _check_hotline(self, hotline_file):
        if os.path.exists(hotline_file):
            mtime = os.stat(hotline_file)[stat.ST_MTIME]
            if mtime > time.time() - 10.0:
                return
        self.log("hotline missing or too old, shutting down")
        reactor.stop()

    def tub_ready(self):
        self.log("tub_ready")

        my_old_name = None
        try:
            my_old_furl = open(os.path.join(self.basedir, self.MY_FURL_FILE),
                               "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable myfurl file
        else:
            sturdy = SturdyRef(my_old_furl)
            my_old_name = sturdy.name

        self.my_furl = self.tub.registerReference(self, my_old_name)
        open(os.path.join(self.basedir, self.MY_FURL_FILE),
             "w").write(self.my_furl + "\n")

        ic = IntroducerClient(self.tub, self.introducer_furl, self.my_furl)
        self.introducer_client = ic
        ic.setServiceParent(self)

        self.register_control()

    def register_control(self):
        c = ControlServer()
        c.setServiceParent(self)
        control_url = self.tub.registerReference(c)
        control_furl_file = os.path.join(self.basedir, "control.furl")
        open(control_furl_file, "w").write(control_url + "\n")
        os.chmod(control_furl_file, 0600)


    def remote_get_versions(self):
        return str(allmydata.__version__), str(self.OLDEST_SUPPORTED_VERSION)

    def remote_get_service(self, name):
        if name in ("storageserver",):
            return self.getServiceNamed(name)
        raise RuntimeError("I am unwilling to give you service %s" % name)


    def get_all_peerids(self):
        if not self.introducer_client:
            return []
        return self.introducer_client.get_all_peerids()

    def get_permuted_peers(self, key, include_myself=True):
        """
        @return: list of (permuted-peerid, peerid, connection,)
        """
        results = []
        for peerid, connection in self.introducer_client.get_all_peers():
            assert isinstance(peerid, str)
            if not include_myself and peerid == self.nodeid:
                self.log("get_permuted_peers: removing myself from the list")
                continue
            permuted = bytes_to_long(sha.new(key + peerid).digest())
            results.append((permuted, peerid, connection))
        results.sort()
        return results

    def get_push_to_ourselves(self):
        return self.push_to_ourselves

    def get_encoding_parameters(self):
        if not self.introducer_client:
            return None
        return self.introducer_client.encoding_parameters

    def connected_to_introducer(self):
        if self.introducer_client:
            return self.introducer_client.connected_to_introducer()
        return False

#! /usr/bin/env python

# Allmydata Tahoe -- secure, distributed storage grid
# 
# Copyright (C) 2007 Allmydata, Inc.
# 
# This file is part of tahoe.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version, with the added permission that, if you become obligated
# to release a derived work under this licence (as per section 2.b), you may
# delay the fulfillment of this obligation for up to 12 months.  See the file
# COPYING for details.
#
# If you would like to inquire about a commercial relationship with Allmydata,
# Inc., please contact partnerships@allmydata.com and visit
# http://allmydata.com/.

import re, os.path
from distutils.core import Extension, setup

trove_classifiers=[
    "Development Status :: 3 - Alpha", 
    "Environment :: Console",
    "Environment :: Web Environment",
    "License :: OSI Approved :: GNU General Public License (GPL)", 
    "License :: DFSG approved",
    "Intended Audience :: Developers", 
    "Intended Audience :: End Users/Desktop",
    "Intended Audience :: System Administrators",
    "Operating System :: Microsoft",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: Unix",
    "Operating System :: POSIX :: Linux",
    "Operating System :: POSIX",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows :: Windows NT/2000",
    "Operating System :: OS Independent", 
    "Natural Language :: English", 
    "Programming Language :: C", 
    "Programming Language :: Python", 
    "Topic :: Utilities",
    "Topic :: System :: Systems Administration",
    "Topic :: System :: Filesystems",
    "Topic :: System :: Distributed Computing",
    "Topic :: Software Development :: Libraries",
    "Topic :: Communications :: Usenet News",
    "Topic :: System :: Archiving :: Backup", 
    "Topic :: System :: Archiving :: Mirroring", 
    "Topic :: System :: Archiving", 
    ]


VERSIONFILE = "src/allmydata/version.py"
verstr = "unknown"
if os.path.exists(VERSIONFILE):
    VSRE = re.compile("^verstr = ['\"]([^'\"]*)['\"]", re.M)
    verstrline = open(VERSIONFILE, "rt").read()
    mo = VSRE.search(verstrline)
    if mo:
        verstr = mo.group(1)
    else:
        print "unable to find version in version.py"
        raise RuntimeError("if version.py exists, it must be well-formed")

setup(name='allmydata-tahoe',
      version=verstr,
      description='secure, distributed storage grid',
      long_description="""Welcome to the AllMyData "tahoe" project. This project implements a
secure, distributed, fault-tolerant storage grid.

The basic idea is that the data in this storage grid is spread over all
participating nodes, using an algorithm that can recover the data even if a
majority of the nodes are no longer available.""",
      author='Allmydata, Inc.',
      author_email='tahoe-dev@allmydata.org',
      url='http://allmydata.org/',
      license='GNU GPL',
      packages=["allmydata", "allmydata.test", "allmydata.util",
                "allmydata.scripts",],
      package_dir={ "allmydata": "src/allmydata",},
      scripts = ["bin/allmydata-tahoe"],
      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },                    
      classifiers=trove_classifiers,
      test_suite="allmydata.test",
      )


import os, sha, stat, time, re
from foolscap import Referenceable, SturdyRef
from zope.interface import implements
from allmydata.interfaces import RIClient
from allmydata import node

from twisted.internet import reactor
from twisted.application.internet import TimerService
from twisted.python import log

import allmydata
from allmydata.Crypto.Util.number import bytes_to_long
from allmydata.storage import StorageServer
from allmydata.upload import Uploader
from allmydata.download import Downloader
from allmydata.webish import WebishServer
from allmydata.control import ControlServer
from allmydata.introducer import IntroducerClient
from allmydata.vdrive import VirtualDrive

class Client(node.Node, Referenceable):
    implements(RIClient)
    PORTNUMFILE = "client.port"
    STOREDIR = 'storage'
    NODETYPE = "client"
    WEBPORTFILE = "webport"
    WEB_ALLOW_LOCAL_ACCESS_FILE = "webport_allow_localfile"
    INTRODUCER_FURL_FILE = "introducer.furl"
    MY_FURL_FILE = "myself.furl"
    SUICIDE_PREVENTION_HOTLINE_FILE = "suicide_prevention_hotline"
    SIZELIMIT_FILE = "sizelimit"
    PUSH_TO_OURSELVES_FILE = "push_to_ourselves"

    # we're pretty narrow-minded right now
    OLDEST_SUPPORTED_VERSION = allmydata.__version__

    def __init__(self, basedir="."):
        node.Node.__init__(self, basedir)
        self.my_furl = None
        self.introducer_client = None
        self.init_storage()
        self.init_options()
        self.add_service(Uploader())
        self.add_service(Downloader())
        self.add_service(VirtualDrive())
        try:
            webport = open(os.path.join(self.basedir, self.WEBPORTFILE),
                           "r").read().strip() # strports string
        except EnvironmentError:
            pass # absent or unreadable webport file
        else:
            ws = WebishServer(webport)                    
            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                    
                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))                    
            self.add_service(ws)                    

        INTRODUCER_FURL_FILE = os.path.join(self.basedir,
                                            self.INTRODUCER_FURL_FILE)
        self.introducer_furl = open(INTRODUCER_FURL_FILE, "r").read().strip()

        hotline_file = os.path.join(self.basedir,
                                    self.SUICIDE_PREVENTION_HOTLINE_FILE)
        if os.path.exists(hotline_file):
            self.log("hotline file noticed, starting timer")
            hotline = TimerService(1.0, self._check_hotline, hotline_file)
            hotline.setServiceParent(self)

    def init_storage(self):
        storedir = os.path.join(self.basedir, self.STOREDIR)
        sizelimit = None

        try:
            data = open(os.path.join(self.basedir, self.SIZELIMIT_FILE),
                        "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable sizelimit file
        else:
            m = re.match(r"^(\d+)([kKmMgG]?[bB]?)$", data)
            if not m:
                log.msg("SIZELIMIT_FILE contains unparseable value %s" % data)
            else:
                number, suffix = m.groups()
                suffix = suffix.upper()
                if suffix.endswith("B"):
                    suffix = suffix[:-1]
                multiplier = {"": 1,
                              "K": 1000,
                              "M": 1000 * 1000,
                              "G": 1000 * 1000 * 1000,
                              }[suffix]
                sizelimit = int(number) * multiplier
        NOSTORAGE_FILE = os.path.join(self.basedir, "debug_no_storage")
        no_storage = os.path.exists(NOSTORAGE_FILE)
        self.add_service(StorageServer(storedir, sizelimit, no_storage))

    def init_options(self):
        self.push_to_ourselves = None
        filename = os.path.join(self.basedir, self.PUSH_TO_OURSELVES_FILE)
        if os.path.exists(filename):
            self.push_to_ourselves = True

    def _check_hotline(self, hotline_file):
        if os.path.exists(hotline_file):
            mtime = os.stat(hotline_file)[stat.ST_MTIME]
            if mtime > time.time() - 10.0:
                return
        self.log("hotline missing or too old, shutting down")
        reactor.stop()

    def tub_ready(self):
        self.log("tub_ready")

        my_old_name = None
        try:
            my_old_furl = open(os.path.join(self.basedir, self.MY_FURL_FILE),
                               "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable myfurl file
        else:
            sturdy = SturdyRef(my_old_furl)
            my_old_name = sturdy.name

        self.my_furl = self.tub.registerReference(self, my_old_name)
        open(os.path.join(self.basedir, self.MY_FURL_FILE),
             "w").write(self.my_furl + "\n")

        ic = IntroducerClient(self.tub, self.introducer_furl, self.my_furl)
        self.introducer_client = ic
        ic.setServiceParent(self)

        self.register_control()

    def register_control(self):
        c = ControlServer()
        c.setServiceParent(self)
        control_url = self.tub.registerReference(c)
        control_furl_file = os.path.join(self.basedir, "control.furl")
        open(control_furl_file, "w").write(control_url + "\n")
        os.chmod(control_furl_file, 0600)


    def remote_get_versions(self):
        return str(allmydata.__version__), str(self.OLDEST_SUPPORTED_VERSION)

    def remote_get_service(self, name):
        if name in ("storageserver",):
            return self.getServiceNamed(name)
        raise RuntimeError("I am unwilling to give you service %s" % name)


    def get_all_peerids(self):
        if not self.introducer_client:
            return []
        return self.introducer_client.get_all_peerids()

    def get_permuted_peers(self, key, include_myself=True):
        """
        @return: list of (permuted-peerid, peerid, connection,)
        """
        results = []
        for peerid, connection in self.introducer_client.get_all_peers():
            assert isinstance(peerid, str)
            if not include_myself and peerid == self.nodeid:
                self.log("get_permuted_peers: removing myself from the list")
                continue
            permuted = bytes_to_long(sha.new(key + peerid).digest())
            results.append((permuted, peerid, connection))
        results.sort()
        return results

    def get_push_to_ourselves(self):
        return self.push_to_ourselves

    def get_encoding_parameters(self):
        if not self.introducer_client:
            return None
        return self.introducer_client.encoding_parameters

    def connected_to_introducer(self):
        if self.introducer_client:
            return self.introducer_client.connected_to_introducer()
        return False

"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""
from __future__ import unicode_literals

from django.test import TestCase

from deis import __version__


class APIMiddlewareTest(TestCase):

    """Tests middleware.py's business logic"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def test_x_deis_version_header_good(self):
        """
        Test that when the version header is sent, the request is accepted.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]                    
        )
        self.assertEqual(response.status_code, 200)

    def test_x_deis_version_header_bad(self):
        """
        Test that when an improper version header is sent, the request is declined.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION='1234.5678'                    
        )
        self.assertEqual(response.status_code, 405)

    def test_x_deis_version_header_not_present(self):
        """
        Test that when the version header is not present, the request is accepted.
        """
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)







"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""

from __future__ import unicode_literals

import json

from django.test import TestCase

from api.models import Key
from api.utils import fingerprint


RSA_PUBKEY = (
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfQkkUUoxpvcNMkvv7jqnfodgs37M2eBO"
    "APgLK+KNBMaZaaKB4GF1QhTCMfFhoiTW3rqa0J75bHJcdkoobtTHlK8XUrFqsquWyg3XhsT"
    "Yr/3RQQXvO86e2sF7SVDJqVtpnbQGc5SgNrHCeHJmf5HTbXSIjCO/AJSvIjnituT/SIAMGe"
    "Bw0Nq/iSltwYAek1hiKO7wSmLcIQ8U4A00KEUtalaumf2aHOcfjgPfzlbZGP0S0cuBwSqLr"
    "8b5XGPmkASNdUiuJY4MJOce7bFU14B7oMAy2xacODUs1momUeYtGI9T7X2WMowJaO7tP3Gl"
    "sgBMP81VfYTfYChAyJpKp2yoP autotest@autotesting comment"
)

ECDSA_PUBKEY = (
    "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAAB"
    "BBCGB0x9lmubbLJTF5NekCI0Cgjyip6jJh/t/qQQi1LAZisbREBJ8Wy+hwSn3tnbf/Imh9X"
    "+MQnrrza0jaQ3QUAQ= autotest@autotesting comment"
)


class KeyTest(TestCase):

    """Tests cloud provider credentials"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def _check_key(self, pubkey):
        """
        Test that a user can add, remove and manage their SSH public keys
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key_id = response.data['id']
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        url = '/api/keys/{key_id}'.format(**locals())
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(body['id'], response.data['id'])
        self.assertEqual(body['public'], response.data['public'])
        response = self.client.delete(url)                    
        self.assertEqual(response.status_code, 204)

    def test_rsa_key(self):
        self._check_key(RSA_PUBKEY)

    def test_ecdsa_key(self):
        self._check_key(ECDSA_PUBKEY)

    def _check_duplicate_key(self, pubkey):
        """
        Test that a user cannot add a duplicate key
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 400)

    def test_rsa_duplicate_key(self):
        self._check_duplicate_key(RSA_PUBKEY)

    def test_ecdsa_duplicate_key(self):
        self._check_duplicate_key(ECDSA_PUBKEY)

    def test_rsa_key_str(self):
        """Test the text representation of a key"""
        url = '/api/keys'
        body = {'id': 'autotest', 'public':
                'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzqPAwHN70xsB0LXG//KzO'
                'gcPikyhdN/KRc4x3j/RA0pmFj63Ywv0PJ2b1LcMSqfR8F11WBlrW8c9xFua0'
                'ZAKzI+gEk5uqvOR78bs/SITOtKPomW4e/1d2xEkJqOmYH30u94+NZZYwEBqY'
                'aRb34fhtrnJS70XeGF0RhXE5Qea5eh7DBbeLxPfSYd8rfHgzMSb/wmx3h2vm'
                'HdQGho20pfJktNu7DxeVkTHn9REMUphf85su7slTgTlWKq++3fASE8PdmFGz'
                'b6PkOR4c+LS5WWXd2oM6HyBQBxxiwXbA2lSgQxOdgDiM2FzT0GVSFMUklkUH'
                'MdsaG6/HJDw9QckTS0vN autotest@deis.io'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key = Key.objects.get(uuid=response.data['uuid'])
        self.assertEqual(str(key), 'ssh-rsa AAAAB3NzaC.../HJDw9QckTS0vN autotest@deis.io')

    def test_rsa_key_fingerprint(self):
        fp = fingerprint(RSA_PUBKEY)
        self.assertEquals(fp, '54:6d:da:1f:91:b5:2b:6f:a2:83:90:c4:f9:73:76:f5')


from __future__ import unicode_literals
import json

from django.test import TestCase


class TestAdminPerms(TestCase):

    def test_first_signup(self):
        # register a first user
        username, password = 'firstuser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        # register a second user
        username, password = 'seconduser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])

    def test_list(self):
        submit = {
            'username': 'firstuser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        self.assertTrue(                    
            self.client.login(username='firstuser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['username'], 'firstuser')
        self.assertTrue(response.data['results'][0]['is_superuser'])                    
        # register a non-superuser
        submit = {
            'username': 'seconduser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='seconduser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIn('You do not have permission', response.data['detail'])

    def test_create(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        self.assertIn('second', str(response.data['results']))

    def test_delete(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # revoke the superuser perm
        response = self.client.delete(url + '/second')                    
        self.assertEqual(response.status_code, 204)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertNotIn('two', str(response.data['results']))


class TestAppPerms(TestCase):

    fixtures = ['test_sharing.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    

    def test_create(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # check that user 2 can't see any of the app's builds, configs,
        # containers, limits, or releases
        for model in ['builds', 'config', 'containers', 'limits', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(response.data['detail'], 'Not found')
        # TODO: test that git pushing to the app fails
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # check that user 2 sees (empty) results now for builds, containers,
        # and releases. (config and limit will still give 404s since we didn't
        # push a build here.)
        for model in ['builds', 'containers', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(len(response.data['results']), 0)
        # TODO:  check that user 2 can git push the app

    def test_create_errors(self):
        # check that user 1 sees her lone app
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # check that user 2 can't create a permission
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)

    def test_delete(self):
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app as well as his own
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # try to delete the permission as user 2
        url = "/api/apps/{}/perms/{}".format(app_id, 'autotest-2')
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIsNone(response.data)
        # delete permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 204)
        self.assertIsNone(response.data)
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # delete permission to user 1's app again, expecting an error
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 404)

    def test_list(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # create a new object permission
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.data, {'users': ['autotest-2']})

    def test_admin_can_list(self):
        """Check that an administrator can list an app's perms"""
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)

    def test_list_errors(self):
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # login as user 2
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)



"""
RESTful URL patterns and routing for the Deis API app.


Applications
============

.. http:get:: /api/apps/(string:id)/

  Retrieve a :class:`~api.models.App` by its `id`.

.. http:delete:: /api/apps/(string:id)/

  Destroy a :class:`~api.models.App` by its `id`.

.. http:get:: /api/apps/

  List all :class:`~api.models.App`\s.

.. http:post:: /api/apps/

  Create a new :class:`~api.models.App`.


Application Release Components
------------------------------

.. http:get:: /api/apps/(string:id)/config/

  List all :class:`~api.models.Config`\s.

.. http:post:: /api/apps/(string:id)/config/

  Create a new :class:`~api.models.Config`.

.. http:get:: /api/apps/(string:id)/builds/(string:uuid)/

  Retrieve a :class:`~api.models.Build` by its `uuid`.

.. http:get:: /api/apps/(string:id)/builds/

  List all :class:`~api.models.Build`\s.

.. http:post:: /api/apps/(string:id)/builds/

  Create a new :class:`~api.models.Build`.

.. http:get:: /api/apps/(string:id)/releases/(int:version)/

  Retrieve a :class:`~api.models.Release` by its `version`.

.. http:get:: /api/apps/(string:id)/releases/

  List all :class:`~api.models.Release`\s.

.. http:post:: /api/apps/(string:id)/releases/rollback/

  Rollback to a previous :class:`~api.models.Release`.


Application Infrastructure
--------------------------

.. http:get:: /api/apps/(string:id)/containers/(string:type)/(int:num)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/(string:type)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/

  List all :class:`~api.models.Container`\s.


Application Domains
-------------------


.. http:delete:: /api/apps/(string:id)/domains/(string:hostname)

  Destroy a :class:`~api.models.Domain` by its `hostname`

.. http:get:: /api/apps/(string:id)/domains/

  List all :class:`~api.models.Domain`\s.

.. http:post:: /api/apps/(string:id)/domains/

  Create a new :class:`~api.models.Domain`\s.


Application Actions
-------------------

.. http:post:: /api/apps/(string:id)/scale/

  See also
  :meth:`AppViewSet.scale() <api.views.AppViewSet.scale>`

.. http:get:: /api/apps/(string:id)/logs/

  See also
  :meth:`AppViewSet.logs() <api.views.AppViewSet.logs>`

.. http:post:: /api/apps/(string:id)/run/

  See also
  :meth:`AppViewSet.run() <api.views.AppViewSet.run>`


Application Sharing
===================

.. http:delete:: /api/apps/(string:id)/perms/(string:username)/

  Destroy an app permission by its `username`.

.. http:get:: /api/apps/(string:id)/perms/

  List all permissions granted to this app.

.. http:post:: /api/apps/(string:id)/perms/

  Create a new app permission.


Keys
====

.. http:get:: /api/keys/(string:id)/

  Retrieve a :class:`~api.models.Key` by its `id`.

.. http:delete:: /api/keys/(string:id)/

  Destroy a :class:`~api.models.Key` by its `id`.

.. http:get:: /api/keys/

  List all :class:`~api.models.Key`\s.

.. http:post:: /api/keys/

  Create a new :class:`~api.models.Key`.


API Hooks
=========

.. http:post:: /api/hooks/push/

  Create a new :class:`~api.models.Push`.

.. http:post:: /api/hooks/build/

  Create a new :class:`~api.models.Build`.

.. http:post:: /api/hooks/config/

  Retrieve latest application :class:`~api.models.Config`.


Auth
====

.. http:post:: /api/auth/register/

  Create a new User.

.. http:delete:: /api/auth/register/

  Destroy the logged-in User.

.. http:post:: /api/auth/login

  Authenticate for the REST framework.                    

.. http:post:: /api/auth/logout

  Clear authentication for the REST framework.                    

.. http:get:: /api/generate-api-key/

  Generate an API key.


Admin Sharing
=============

.. http:delete:: /api/admin/perms/(string:username)/

  Destroy an admin permission by its `username`.

.. http:get:: /api/admin/perms/

  List all admin permissions granted.

.. http:post:: /api/admin/perms/

  Create a new admin permission.

"""

from __future__ import unicode_literals

from django.conf import settings
from django.conf.urls import include
from django.conf.urls import patterns
from django.conf.urls import url

from api import routers
from api import views


router = routers.ApiRouter()

# Add the generated REST URLs and login/logout endpoint
urlpatterns = patterns(
    '',
    url(r'^', include(router.urls)),
    # application release components
    url(r'^apps/(?P<id>{})/config/?'.format(settings.APP_URL_REGEX),
        views.AppConfigViewSet.as_view({'get': 'retrieve', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/builds/(?P<uuid>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/builds/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'list', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/releases/v(?P<version>[0-9]+)/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/releases/rollback/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'post': 'rollback'})),
    url(r'^apps/(?P<id>{})/releases/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'list'})),
    # application infrastructure
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w]+)/(?P<num>[-_\w]+)/?'.format(
        settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w.]+)/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    url(r'^apps/(?P<id>{})/containers/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    # application domains
    url(r'^apps/(?P<id>{})/domains/(?P<domain>[-\._\w]+)/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/domains/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'post': 'create', 'get': 'list'})),
    # application actions
    url(r'^apps/(?P<id>{})/scale/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'scale'})),
    url(r'^apps/(?P<id>{})/logs/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'logs'})),
    url(r'^apps/(?P<id>{})/run/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'run'})),
    # apps sharing
    url(r'^apps/(?P<id>{})/perms/(?P<username>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/perms/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
    # apps base endpoint
    url(r'^apps/(?P<id>{})/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^apps/?',
        views.AppViewSet.as_view({'get': 'list', 'post': 'create'})),
    # key
    url(r'^keys/(?P<id>.+)/?',
        views.KeyViewSet.as_view({
            'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^keys/?',
        views.KeyViewSet.as_view({'get': 'list', 'post': 'create'})),
    # hooks
    url(r'^hooks/push/?',
        views.PushHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/build/?',
        views.BuildHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/config/?',
        views.ConfigHookViewSet.as_view({'post': 'create'})),
    # authn / authz
    url(r'^auth/register/?',
        views.UserRegistrationView.as_view({'post': 'create'})),
    url(r'^auth/cancel/?',
        views.UserCancellationView.as_view({'delete': 'destroy'})),
    url(r'^auth/',                    
        include('rest_framework.urls', namespace='rest_framework')),                    
    url(r'^generate-api-key/',                    
        'rest_framework.authtoken.views.obtain_auth_token'),
    # admin sharing
    url(r'^admin/perms/(?P<username>[-_\w]+)/?',
        views.AdminPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^admin/perms/?',
        views.AdminPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
)

"""
Django settings for the Deis project.
"""

from __future__ import unicode_literals
import os.path
import sys
import tempfile

PROJECT_ROOT = os.path.normpath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = False
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

CONN_MAX_AGE = 60 * 3

# Hosts/domain names that are valid for this site; required if DEBUG is False
# See https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts
ALLOWED_HOSTS = ['localhost']

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Denver'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/var/www/example.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://example.com/media/", "http://media.example.com/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/var/www/example.com/static/"
STATIC_ROOT = os.path.abspath(os.path.join(__file__, '..', '..', 'static'))

# URL prefix for static files.
# Example: "http://example.com/static/", "http://static.example.com/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = None  # @UnusedVariable

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.request",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages",
    "deis.context_processors.site",
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'api.middleware.VersionMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'deis.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'deis.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates"
    # or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    PROJECT_ROOT + '/web/templates',
)

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.humanize',
    'django.contrib.messages',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.staticfiles',
    # Third-party apps
    'django_fsm',
    'guardian',
    'json_field',
    'gunicorn',
    'rest_framework',
    'south',
    # Deis apps
    'api',
    'web',
)

AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "guardian.backends.ObjectPermissionBackend",
)

ANONYMOUS_USER_ID = -1
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = 'none'
ACCOUNT_LOGOUT_ON_GET = True
ACCOUNT_USERNAME_BLACKLIST = ['system']
LOGIN_URL = '/api/auth/login/'
LOGIN_REDIRECT_URL = '/'

SOUTH_TESTS_MIGRATE = False

REST_FRAMEWORK = {
    'DEFAULT_MODEL_SERIALIZER_CLASS':
    'rest_framework.serializers.ModelSerializer',
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',                    
    ),
    'PAGINATE_BY': 100,
}

# URLs that end with slashes are ugly
APPEND_SLASH = False

# Determine where to send syslog messages
if os.path.exists('/dev/log'):           # Linux rsyslog
    SYSLOG_ADDRESS = '/dev/log'
elif os.path.exists('/var/log/syslog'):  # Mac OS X syslog
    SYSLOG_ADDRESS = '/var/log/syslog'
else:                                    # default SysLogHandler address
    SYSLOG_ADDRESS = ('localhost', 514)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'null': {
            'level': 'DEBUG',
            'class': 'logging.NullHandler',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'rsyslog': {
            'class': 'logging.handlers.SysLogHandler',
            'address': SYSLOG_ADDRESS,
            'facility': 'local0',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['null'],
            'level': 'INFO',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['console', 'mail_admins'],
            'level': 'WARNING',
            'propagate': True,
        },
        'api': {
            'handlers': ['console', 'mail_admins', 'rsyslog'],
            'level': 'INFO',
            'propagate': True,
        },
    }
}
TEST_RUNNER = 'api.tests.SilentDjangoTestSuiteRunner'

# etcd settings
ETCD_HOST, ETCD_PORT = os.environ.get('ETCD', '127.0.0.1:4001').split(',')[0].split(':')

# default deis settings
DEIS_LOG_DIR = os.path.abspath(os.path.join(__file__, '..', '..', 'logs'))
LOG_LINES = 1000
TEMPDIR = tempfile.mkdtemp(prefix='deis')
DEFAULT_BUILD = 'deis/helloworld'
DEIS_DOMAIN = 'deisapp.local'

# default scheduler settings
SCHEDULER_MODULE = 'mock'
SCHEDULER_TARGET = ''  # path to scheduler endpoint (e.g. /var/run/fleet.sock)
SCHEDULER_AUTH = ''
SCHEDULER_OPTIONS = {}

# security keys and auth tokens
SSH_PRIVATE_KEY = ''  # used for SSH connections to facilitate "deis run"
SECRET_KEY = os.environ.get('DEIS_SECRET_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')
BUILDER_KEY = os.environ.get('DEIS_BUILDER_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')

# registry settings
REGISTRY_MODULE = 'registry.mock'
REGISTRY_URL = 'http://localhost:5000'
REGISTRY_HOST = 'localhost'
REGISTRY_PORT = 5000

# check if we can register users with `deis register`
REGISTRATION_ENABLED = True

# check if we should enable the web UI module
WEB_ENABLED = False

# default to sqlite3, but allow postgresql config through envvars
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.' + os.environ.get('DATABASE_ENGINE', 'postgresql_psycopg2'),
        'NAME': os.environ.get('DATABASE_NAME', 'deis'),
    }
}

APP_URL_REGEX = '[a-z0-9-]+'

# SECURITY: change this to allowed fqdn's to prevent host poisioning attacks
# see https://docs.djangoproject.com/en/1.5/ref/settings/#std:setting-ALLOWED_HOSTS
ALLOWED_HOSTS = ['*']

# Honor HTTPS from a trusted proxy
# see https://docs.djangoproject.com/en/1.6/ref/settings/#secure-proxy-ssl-header
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# Create a file named "local_settings.py" to contain sensitive settings data
# such as database configuration, admin email, or passwords and keys. It
# should also be used for any settings which differ between development
# and production.
# The local_settings.py file should *not* be checked in to version control.
try:
    from .local_settings import *  # @UnusedWildImport # noqa
except ImportError:
    pass


# have confd_settings within container execution override all others
# including local_settings (which may end up in the container)
if os.path.exists('/templates/confd_settings.py'):
    sys.path.append('/templates')
    from confd_settings import *  # noqa

"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""
from __future__ import unicode_literals

from django.test import TestCase

from deis import __version__


class APIMiddlewareTest(TestCase):

    """Tests middleware.py's business logic"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def test_x_deis_version_header_good(self):
        """
        Test that when the version header is sent, the request is accepted.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]                    
        )
        self.assertEqual(response.status_code, 200)

    def test_x_deis_version_header_bad(self):
        """
        Test that when an improper version header is sent, the request is declined.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION='1234.5678'                    
        )
        self.assertEqual(response.status_code, 405)

    def test_x_deis_version_header_not_present(self):
        """
        Test that when the version header is not present, the request is accepted.
        """
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)







"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""

from __future__ import unicode_literals

import json

from django.test import TestCase

from api.models import Key
from api.utils import fingerprint


RSA_PUBKEY = (
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfQkkUUoxpvcNMkvv7jqnfodgs37M2eBO"
    "APgLK+KNBMaZaaKB4GF1QhTCMfFhoiTW3rqa0J75bHJcdkoobtTHlK8XUrFqsquWyg3XhsT"
    "Yr/3RQQXvO86e2sF7SVDJqVtpnbQGc5SgNrHCeHJmf5HTbXSIjCO/AJSvIjnituT/SIAMGe"
    "Bw0Nq/iSltwYAek1hiKO7wSmLcIQ8U4A00KEUtalaumf2aHOcfjgPfzlbZGP0S0cuBwSqLr"
    "8b5XGPmkASNdUiuJY4MJOce7bFU14B7oMAy2xacODUs1momUeYtGI9T7X2WMowJaO7tP3Gl"
    "sgBMP81VfYTfYChAyJpKp2yoP autotest@autotesting comment"
)

ECDSA_PUBKEY = (
    "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAAB"
    "BBCGB0x9lmubbLJTF5NekCI0Cgjyip6jJh/t/qQQi1LAZisbREBJ8Wy+hwSn3tnbf/Imh9X"
    "+MQnrrza0jaQ3QUAQ= autotest@autotesting comment"
)


class KeyTest(TestCase):

    """Tests cloud provider credentials"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def _check_key(self, pubkey):
        """
        Test that a user can add, remove and manage their SSH public keys
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key_id = response.data['id']
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        url = '/api/keys/{key_id}'.format(**locals())
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(body['id'], response.data['id'])
        self.assertEqual(body['public'], response.data['public'])
        response = self.client.delete(url)                    
        self.assertEqual(response.status_code, 204)

    def test_rsa_key(self):
        self._check_key(RSA_PUBKEY)

    def test_ecdsa_key(self):
        self._check_key(ECDSA_PUBKEY)

    def _check_duplicate_key(self, pubkey):
        """
        Test that a user cannot add a duplicate key
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 400)

    def test_rsa_duplicate_key(self):
        self._check_duplicate_key(RSA_PUBKEY)

    def test_ecdsa_duplicate_key(self):
        self._check_duplicate_key(ECDSA_PUBKEY)

    def test_rsa_key_str(self):
        """Test the text representation of a key"""
        url = '/api/keys'
        body = {'id': 'autotest', 'public':
                'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzqPAwHN70xsB0LXG//KzO'
                'gcPikyhdN/KRc4x3j/RA0pmFj63Ywv0PJ2b1LcMSqfR8F11WBlrW8c9xFua0'
                'ZAKzI+gEk5uqvOR78bs/SITOtKPomW4e/1d2xEkJqOmYH30u94+NZZYwEBqY'
                'aRb34fhtrnJS70XeGF0RhXE5Qea5eh7DBbeLxPfSYd8rfHgzMSb/wmx3h2vm'
                'HdQGho20pfJktNu7DxeVkTHn9REMUphf85su7slTgTlWKq++3fASE8PdmFGz'
                'b6PkOR4c+LS5WWXd2oM6HyBQBxxiwXbA2lSgQxOdgDiM2FzT0GVSFMUklkUH'
                'MdsaG6/HJDw9QckTS0vN autotest@deis.io'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key = Key.objects.get(uuid=response.data['uuid'])
        self.assertEqual(str(key), 'ssh-rsa AAAAB3NzaC.../HJDw9QckTS0vN autotest@deis.io')

    def test_rsa_key_fingerprint(self):
        fp = fingerprint(RSA_PUBKEY)
        self.assertEquals(fp, '54:6d:da:1f:91:b5:2b:6f:a2:83:90:c4:f9:73:76:f5')


from __future__ import unicode_literals
import json

from django.test import TestCase


class TestAdminPerms(TestCase):

    def test_first_signup(self):
        # register a first user
        username, password = 'firstuser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        # register a second user
        username, password = 'seconduser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])

    def test_list(self):
        submit = {
            'username': 'firstuser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        self.assertTrue(                    
            self.client.login(username='firstuser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['username'], 'firstuser')
        self.assertTrue(response.data['results'][0]['is_superuser'])                    
        # register a non-superuser
        submit = {
            'username': 'seconduser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='seconduser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIn('You do not have permission', response.data['detail'])

    def test_create(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        self.assertIn('second', str(response.data['results']))

    def test_delete(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # revoke the superuser perm
        response = self.client.delete(url + '/second')                    
        self.assertEqual(response.status_code, 204)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertNotIn('two', str(response.data['results']))


class TestAppPerms(TestCase):

    fixtures = ['test_sharing.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    

    def test_create(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # check that user 2 can't see any of the app's builds, configs,
        # containers, limits, or releases
        for model in ['builds', 'config', 'containers', 'limits', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(response.data['detail'], 'Not found')
        # TODO: test that git pushing to the app fails
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # check that user 2 sees (empty) results now for builds, containers,
        # and releases. (config and limit will still give 404s since we didn't
        # push a build here.)
        for model in ['builds', 'containers', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(len(response.data['results']), 0)
        # TODO:  check that user 2 can git push the app

    def test_create_errors(self):
        # check that user 1 sees her lone app
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # check that user 2 can't create a permission
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)

    def test_delete(self):
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app as well as his own
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # try to delete the permission as user 2
        url = "/api/apps/{}/perms/{}".format(app_id, 'autotest-2')
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIsNone(response.data)
        # delete permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 204)
        self.assertIsNone(response.data)
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # delete permission to user 1's app again, expecting an error
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 404)

    def test_list(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # create a new object permission
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.data, {'users': ['autotest-2']})

    def test_admin_can_list(self):
        """Check that an administrator can list an app's perms"""
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)

    def test_list_errors(self):
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # login as user 2
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)



"""
RESTful URL patterns and routing for the Deis API app.


Applications
============

.. http:get:: /api/apps/(string:id)/

  Retrieve a :class:`~api.models.App` by its `id`.

.. http:delete:: /api/apps/(string:id)/

  Destroy a :class:`~api.models.App` by its `id`.

.. http:get:: /api/apps/

  List all :class:`~api.models.App`\s.

.. http:post:: /api/apps/

  Create a new :class:`~api.models.App`.


Application Release Components
------------------------------

.. http:get:: /api/apps/(string:id)/config/

  List all :class:`~api.models.Config`\s.

.. http:post:: /api/apps/(string:id)/config/

  Create a new :class:`~api.models.Config`.

.. http:get:: /api/apps/(string:id)/builds/(string:uuid)/

  Retrieve a :class:`~api.models.Build` by its `uuid`.

.. http:get:: /api/apps/(string:id)/builds/

  List all :class:`~api.models.Build`\s.

.. http:post:: /api/apps/(string:id)/builds/

  Create a new :class:`~api.models.Build`.

.. http:get:: /api/apps/(string:id)/releases/(int:version)/

  Retrieve a :class:`~api.models.Release` by its `version`.

.. http:get:: /api/apps/(string:id)/releases/

  List all :class:`~api.models.Release`\s.

.. http:post:: /api/apps/(string:id)/releases/rollback/

  Rollback to a previous :class:`~api.models.Release`.


Application Infrastructure
--------------------------

.. http:get:: /api/apps/(string:id)/containers/(string:type)/(int:num)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/(string:type)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/

  List all :class:`~api.models.Container`\s.


Application Domains
-------------------


.. http:delete:: /api/apps/(string:id)/domains/(string:hostname)

  Destroy a :class:`~api.models.Domain` by its `hostname`

.. http:get:: /api/apps/(string:id)/domains/

  List all :class:`~api.models.Domain`\s.

.. http:post:: /api/apps/(string:id)/domains/

  Create a new :class:`~api.models.Domain`\s.


Application Actions
-------------------

.. http:post:: /api/apps/(string:id)/scale/

  See also
  :meth:`AppViewSet.scale() <api.views.AppViewSet.scale>`

.. http:get:: /api/apps/(string:id)/logs/

  See also
  :meth:`AppViewSet.logs() <api.views.AppViewSet.logs>`

.. http:post:: /api/apps/(string:id)/run/

  See also
  :meth:`AppViewSet.run() <api.views.AppViewSet.run>`


Application Sharing
===================

.. http:delete:: /api/apps/(string:id)/perms/(string:username)/

  Destroy an app permission by its `username`.

.. http:get:: /api/apps/(string:id)/perms/

  List all permissions granted to this app.

.. http:post:: /api/apps/(string:id)/perms/

  Create a new app permission.


Keys
====

.. http:get:: /api/keys/(string:id)/

  Retrieve a :class:`~api.models.Key` by its `id`.

.. http:delete:: /api/keys/(string:id)/

  Destroy a :class:`~api.models.Key` by its `id`.

.. http:get:: /api/keys/

  List all :class:`~api.models.Key`\s.

.. http:post:: /api/keys/

  Create a new :class:`~api.models.Key`.


API Hooks
=========

.. http:post:: /api/hooks/push/

  Create a new :class:`~api.models.Push`.

.. http:post:: /api/hooks/build/

  Create a new :class:`~api.models.Build`.

.. http:post:: /api/hooks/config/

  Retrieve latest application :class:`~api.models.Config`.


Auth
====

.. http:post:: /api/auth/register/

  Create a new User.

.. http:delete:: /api/auth/register/

  Destroy the logged-in User.

.. http:post:: /api/auth/login

  Authenticate for the REST framework.                    

.. http:post:: /api/auth/logout

  Clear authentication for the REST framework.                    

.. http:get:: /api/generate-api-key/

  Generate an API key.


Admin Sharing
=============

.. http:delete:: /api/admin/perms/(string:username)/

  Destroy an admin permission by its `username`.

.. http:get:: /api/admin/perms/

  List all admin permissions granted.

.. http:post:: /api/admin/perms/

  Create a new admin permission.

"""

from __future__ import unicode_literals

from django.conf import settings
from django.conf.urls import include
from django.conf.urls import patterns
from django.conf.urls import url

from api import routers
from api import views


router = routers.ApiRouter()

# Add the generated REST URLs and login/logout endpoint
urlpatterns = patterns(
    '',
    url(r'^', include(router.urls)),
    # application release components
    url(r'^apps/(?P<id>{})/config/?'.format(settings.APP_URL_REGEX),
        views.AppConfigViewSet.as_view({'get': 'retrieve', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/builds/(?P<uuid>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/builds/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'list', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/releases/v(?P<version>[0-9]+)/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/releases/rollback/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'post': 'rollback'})),
    url(r'^apps/(?P<id>{})/releases/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'list'})),
    # application infrastructure
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w]+)/(?P<num>[-_\w]+)/?'.format(
        settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w.]+)/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    url(r'^apps/(?P<id>{})/containers/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    # application domains
    url(r'^apps/(?P<id>{})/domains/(?P<domain>[-\._\w]+)/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/domains/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'post': 'create', 'get': 'list'})),
    # application actions
    url(r'^apps/(?P<id>{})/scale/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'scale'})),
    url(r'^apps/(?P<id>{})/logs/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'logs'})),
    url(r'^apps/(?P<id>{})/run/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'run'})),
    # apps sharing
    url(r'^apps/(?P<id>{})/perms/(?P<username>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/perms/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
    # apps base endpoint
    url(r'^apps/(?P<id>{})/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^apps/?',
        views.AppViewSet.as_view({'get': 'list', 'post': 'create'})),
    # key
    url(r'^keys/(?P<id>.+)/?',
        views.KeyViewSet.as_view({
            'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^keys/?',
        views.KeyViewSet.as_view({'get': 'list', 'post': 'create'})),
    # hooks
    url(r'^hooks/push/?',
        views.PushHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/build/?',
        views.BuildHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/config/?',
        views.ConfigHookViewSet.as_view({'post': 'create'})),
    # authn / authz
    url(r'^auth/register/?',
        views.UserRegistrationView.as_view({'post': 'create'})),
    url(r'^auth/cancel/?',
        views.UserCancellationView.as_view({'delete': 'destroy'})),
    url(r'^auth/',                    
        include('rest_framework.urls', namespace='rest_framework')),                    
    url(r'^generate-api-key/',                    
        'rest_framework.authtoken.views.obtain_auth_token'),
    # admin sharing
    url(r'^admin/perms/(?P<username>[-_\w]+)/?',
        views.AdminPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^admin/perms/?',
        views.AdminPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
)

"""
Django settings for the Deis project.
"""

from __future__ import unicode_literals
import os.path
import sys
import tempfile

PROJECT_ROOT = os.path.normpath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = False
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

CONN_MAX_AGE = 60 * 3

# Hosts/domain names that are valid for this site; required if DEBUG is False
# See https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts
ALLOWED_HOSTS = ['localhost']

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Denver'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/var/www/example.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://example.com/media/", "http://media.example.com/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/var/www/example.com/static/"
STATIC_ROOT = os.path.abspath(os.path.join(__file__, '..', '..', 'static'))

# URL prefix for static files.
# Example: "http://example.com/static/", "http://static.example.com/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = None  # @UnusedVariable

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.request",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages",
    "deis.context_processors.site",
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'api.middleware.VersionMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'deis.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'deis.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates"
    # or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    PROJECT_ROOT + '/web/templates',
)

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.humanize',
    'django.contrib.messages',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.staticfiles',
    # Third-party apps
    'django_fsm',
    'guardian',
    'json_field',
    'gunicorn',
    'rest_framework',
    'south',
    # Deis apps
    'api',
    'web',
)

AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "guardian.backends.ObjectPermissionBackend",
)

ANONYMOUS_USER_ID = -1
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = 'none'
ACCOUNT_LOGOUT_ON_GET = True
ACCOUNT_USERNAME_BLACKLIST = ['system']
LOGIN_URL = '/api/auth/login/'
LOGIN_REDIRECT_URL = '/'

SOUTH_TESTS_MIGRATE = False

REST_FRAMEWORK = {
    'DEFAULT_MODEL_SERIALIZER_CLASS':
    'rest_framework.serializers.ModelSerializer',
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',                    
    ),
    'PAGINATE_BY': 100,
}

# URLs that end with slashes are ugly
APPEND_SLASH = False

# Determine where to send syslog messages
if os.path.exists('/dev/log'):           # Linux rsyslog
    SYSLOG_ADDRESS = '/dev/log'
elif os.path.exists('/var/log/syslog'):  # Mac OS X syslog
    SYSLOG_ADDRESS = '/var/log/syslog'
else:                                    # default SysLogHandler address
    SYSLOG_ADDRESS = ('localhost', 514)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'null': {
            'level': 'DEBUG',
            'class': 'logging.NullHandler',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'rsyslog': {
            'class': 'logging.handlers.SysLogHandler',
            'address': SYSLOG_ADDRESS,
            'facility': 'local0',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['null'],
            'level': 'INFO',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['console', 'mail_admins'],
            'level': 'WARNING',
            'propagate': True,
        },
        'api': {
            'handlers': ['console', 'mail_admins', 'rsyslog'],
            'level': 'INFO',
            'propagate': True,
        },
    }
}
TEST_RUNNER = 'api.tests.SilentDjangoTestSuiteRunner'

# etcd settings
ETCD_HOST, ETCD_PORT = os.environ.get('ETCD', '127.0.0.1:4001').split(',')[0].split(':')

# default deis settings
DEIS_LOG_DIR = os.path.abspath(os.path.join(__file__, '..', '..', 'logs'))
LOG_LINES = 1000
TEMPDIR = tempfile.mkdtemp(prefix='deis')
DEFAULT_BUILD = 'deis/helloworld'
DEIS_DOMAIN = 'deisapp.local'

# default scheduler settings
SCHEDULER_MODULE = 'mock'
SCHEDULER_TARGET = ''  # path to scheduler endpoint (e.g. /var/run/fleet.sock)
SCHEDULER_AUTH = ''
SCHEDULER_OPTIONS = {}

# security keys and auth tokens
SSH_PRIVATE_KEY = ''  # used for SSH connections to facilitate "deis run"
SECRET_KEY = os.environ.get('DEIS_SECRET_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')
BUILDER_KEY = os.environ.get('DEIS_BUILDER_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')

# registry settings
REGISTRY_MODULE = 'registry.mock'
REGISTRY_URL = 'http://localhost:5000'
REGISTRY_HOST = 'localhost'
REGISTRY_PORT = 5000

# check if we can register users with `deis register`
REGISTRATION_ENABLED = True

# check if we should enable the web UI module
WEB_ENABLED = False

# default to sqlite3, but allow postgresql config through envvars
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.' + os.environ.get('DATABASE_ENGINE', 'postgresql_psycopg2'),
        'NAME': os.environ.get('DATABASE_NAME', 'deis'),
    }
}

APP_URL_REGEX = '[a-z0-9-]+'

# SECURITY: change this to allowed fqdn's to prevent host poisioning attacks
# see https://docs.djangoproject.com/en/1.5/ref/settings/#std:setting-ALLOWED_HOSTS
ALLOWED_HOSTS = ['*']

# Honor HTTPS from a trusted proxy
# see https://docs.djangoproject.com/en/1.6/ref/settings/#secure-proxy-ssl-header
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# Create a file named "local_settings.py" to contain sensitive settings data
# such as database configuration, admin email, or passwords and keys. It
# should also be used for any settings which differ between development
# and production.
# The local_settings.py file should *not* be checked in to version control.
try:
    from .local_settings import *  # @UnusedWildImport # noqa
except ImportError:
    pass


# have confd_settings within container execution override all others
# including local_settings (which may end up in the container)
if os.path.exists('/templates/confd_settings.py'):
    sys.path.append('/templates')
    from confd_settings import *  # noqa

"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""
from __future__ import unicode_literals

from django.test import TestCase

from deis import __version__


class APIMiddlewareTest(TestCase):

    """Tests middleware.py's business logic"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def test_x_deis_version_header_good(self):
        """
        Test that when the version header is sent, the request is accepted.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION=__version__.rsplit('.', 1)[0]                    
        )
        self.assertEqual(response.status_code, 200)

    def test_x_deis_version_header_bad(self):
        """
        Test that when an improper version header is sent, the request is declined.
        """
        response = self.client.get(
            '/api/apps',
            HTTP_X_DEIS_VERSION='1234.5678'                    
        )
        self.assertEqual(response.status_code, 405)

    def test_x_deis_version_header_not_present(self):
        """
        Test that when the version header is not present, the request is accepted.
        """
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)







"""
Unit tests for the Deis api app.

Run the tests with "./manage.py test api"
"""

from __future__ import unicode_literals

import json

from django.test import TestCase

from api.models import Key
from api.utils import fingerprint


RSA_PUBKEY = (
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCfQkkUUoxpvcNMkvv7jqnfodgs37M2eBO"
    "APgLK+KNBMaZaaKB4GF1QhTCMfFhoiTW3rqa0J75bHJcdkoobtTHlK8XUrFqsquWyg3XhsT"
    "Yr/3RQQXvO86e2sF7SVDJqVtpnbQGc5SgNrHCeHJmf5HTbXSIjCO/AJSvIjnituT/SIAMGe"
    "Bw0Nq/iSltwYAek1hiKO7wSmLcIQ8U4A00KEUtalaumf2aHOcfjgPfzlbZGP0S0cuBwSqLr"
    "8b5XGPmkASNdUiuJY4MJOce7bFU14B7oMAy2xacODUs1momUeYtGI9T7X2WMowJaO7tP3Gl"
    "sgBMP81VfYTfYChAyJpKp2yoP autotest@autotesting comment"
)

ECDSA_PUBKEY = (
    "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAAB"
    "BBCGB0x9lmubbLJTF5NekCI0Cgjyip6jJh/t/qQQi1LAZisbREBJ8Wy+hwSn3tnbf/Imh9X"
    "+MQnrrza0jaQ3QUAQ= autotest@autotesting comment"
)


class KeyTest(TestCase):

    """Tests cloud provider credentials"""

    fixtures = ['tests.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest', password='password'))                    

    def _check_key(self, pubkey):
        """
        Test that a user can add, remove and manage their SSH public keys
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key_id = response.data['id']
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        url = '/api/keys/{key_id}'.format(**locals())
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(body['id'], response.data['id'])
        self.assertEqual(body['public'], response.data['public'])
        response = self.client.delete(url)                    
        self.assertEqual(response.status_code, 204)

    def test_rsa_key(self):
        self._check_key(RSA_PUBKEY)

    def test_ecdsa_key(self):
        self._check_key(ECDSA_PUBKEY)

    def _check_duplicate_key(self, pubkey):
        """
        Test that a user cannot add a duplicate key
        """
        url = '/api/keys'
        body = {'id': 'mykey@box.local', 'public': pubkey}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 400)

    def test_rsa_duplicate_key(self):
        self._check_duplicate_key(RSA_PUBKEY)

    def test_ecdsa_duplicate_key(self):
        self._check_duplicate_key(ECDSA_PUBKEY)

    def test_rsa_key_str(self):
        """Test the text representation of a key"""
        url = '/api/keys'
        body = {'id': 'autotest', 'public':
                'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzqPAwHN70xsB0LXG//KzO'
                'gcPikyhdN/KRc4x3j/RA0pmFj63Ywv0PJ2b1LcMSqfR8F11WBlrW8c9xFua0'
                'ZAKzI+gEk5uqvOR78bs/SITOtKPomW4e/1d2xEkJqOmYH30u94+NZZYwEBqY'
                'aRb34fhtrnJS70XeGF0RhXE5Qea5eh7DBbeLxPfSYd8rfHgzMSb/wmx3h2vm'
                'HdQGho20pfJktNu7DxeVkTHn9REMUphf85su7slTgTlWKq++3fASE8PdmFGz'
                'b6PkOR4c+LS5WWXd2oM6HyBQBxxiwXbA2lSgQxOdgDiM2FzT0GVSFMUklkUH'
                'MdsaG6/HJDw9QckTS0vN autotest@deis.io'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        key = Key.objects.get(uuid=response.data['uuid'])
        self.assertEqual(str(key), 'ssh-rsa AAAAB3NzaC.../HJDw9QckTS0vN autotest@deis.io')

    def test_rsa_key_fingerprint(self):
        fp = fingerprint(RSA_PUBKEY)
        self.assertEquals(fp, '54:6d:da:1f:91:b5:2b:6f:a2:83:90:c4:f9:73:76:f5')


from __future__ import unicode_literals
import json

from django.test import TestCase


class TestAdminPerms(TestCase):

    def test_first_signup(self):
        # register a first user
        username, password = 'firstuser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        # register a second user
        username, password = 'seconduser', 'password'
        email = 'autotest@deis.io'
        submit = {
            'username': username,
            'password': password,
            'email': email,
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])

    def test_list(self):
        submit = {
            'username': 'firstuser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        self.assertTrue(                    
            self.client.login(username='firstuser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['username'], 'firstuser')
        self.assertTrue(response.data['results'][0]['is_superuser'])                    
        # register a non-superuser
        submit = {
            'username': 'seconduser',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='seconduser', password='password'))                    
        response = self.client.get('/api/admin/perms', content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIn('You do not have permission', response.data['detail'])

    def test_create(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        self.assertIn('second', str(response.data['results']))

    def test_delete(self):
        submit = {
            'username': 'first',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertTrue(response.data['is_superuser'])                    
        submit = {
            'username': 'second',
            'password': 'password',
            'email': 'autotest@deis.io',
        }
        url = '/api/auth/register'
        response = self.client.post(url, json.dumps(submit), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertFalse(response.data['is_superuser'])
        self.assertTrue(                    
            self.client.login(username='first', password='password'))                    
        # grant user 2 the superuser perm
        url = '/api/admin/perms'
        body = {'username': 'second'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # revoke the superuser perm
        response = self.client.delete(url + '/second')                    
        self.assertEqual(response.status_code, 204)
        response = self.client.get(url)                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 1)
        self.assertNotIn('two', str(response.data['results']))


class TestAppPerms(TestCase):

    fixtures = ['test_sharing.json']

    def setUp(self):
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    

    def test_create(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # check that user 2 can't see any of the app's builds, configs,
        # containers, limits, or releases
        for model in ['builds', 'config', 'containers', 'limits', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(response.data['detail'], 'Not found')
        # TODO: test that git pushing to the app fails
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # check that user 2 sees (empty) results now for builds, containers,
        # and releases. (config and limit will still give 404s since we didn't
        # push a build here.)
        for model in ['builds', 'containers', 'releases']:
            response = self.client.get("/api/apps/{}/{}/".format(app_id, model))                    
            self.assertEqual(len(response.data['results']), 0)
        # TODO:  check that user 2 can git push the app

    def test_create_errors(self):
        # check that user 1 sees her lone app
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # check that user 2 can't create a permission
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)

    def test_delete(self):
        # give user 2 permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # check that user 2 can see the app as well as his own
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        # try to delete the permission as user 2
        url = "/api/apps/{}/perms/{}".format(app_id, 'autotest-2')
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 403)
        self.assertIsNone(response.data)
        # delete permission to user 1's app
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 204)
        self.assertIsNone(response.data)
        # check that user 2 can only see his app
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        response = self.client.get('/api/apps')                    
        self.assertEqual(len(response.data['results']), 1)
        # delete permission to user 1's app again, expecting an error
        self.assertTrue(                    
            self.client.login(username='autotest-1', password='password'))                    
        response = self.client.delete(url, content_type='application/json')                    
        self.assertEqual(response.status_code, 404)

    def test_list(self):
        # check that user 1 sees her lone app and user 2's app
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        app_id = response.data['results'][0]['id']
        # create a new object permission
        url = "/api/apps/{}/perms".format(app_id)
        body = {'username': 'autotest-2'}
        response = self.client.post(url, json.dumps(body), content_type='application/json')                    
        self.assertEqual(response.status_code, 201)
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.data, {'users': ['autotest-2']})

    def test_admin_can_list(self):
        """Check that an administrator can list an app's perms"""
        response = self.client.get('/api/apps')                    
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)

    def test_list_errors(self):
        response = self.client.get('/api/apps')                    
        app_id = response.data['results'][0]['id']
        # login as user 2
        self.assertTrue(                    
            self.client.login(username='autotest-2', password='password'))                    
        # list perms on the app
        response = self.client.get(
            "/api/apps/{}/perms".format(app_id), content_type='application/json')                    
        self.assertEqual(response.status_code, 403)



"""
RESTful URL patterns and routing for the Deis API app.


Applications
============

.. http:get:: /api/apps/(string:id)/

  Retrieve a :class:`~api.models.App` by its `id`.

.. http:delete:: /api/apps/(string:id)/

  Destroy a :class:`~api.models.App` by its `id`.

.. http:get:: /api/apps/

  List all :class:`~api.models.App`\s.

.. http:post:: /api/apps/

  Create a new :class:`~api.models.App`.


Application Release Components
------------------------------

.. http:get:: /api/apps/(string:id)/config/

  List all :class:`~api.models.Config`\s.

.. http:post:: /api/apps/(string:id)/config/

  Create a new :class:`~api.models.Config`.

.. http:get:: /api/apps/(string:id)/builds/(string:uuid)/

  Retrieve a :class:`~api.models.Build` by its `uuid`.

.. http:get:: /api/apps/(string:id)/builds/

  List all :class:`~api.models.Build`\s.

.. http:post:: /api/apps/(string:id)/builds/

  Create a new :class:`~api.models.Build`.

.. http:get:: /api/apps/(string:id)/releases/(int:version)/

  Retrieve a :class:`~api.models.Release` by its `version`.

.. http:get:: /api/apps/(string:id)/releases/

  List all :class:`~api.models.Release`\s.

.. http:post:: /api/apps/(string:id)/releases/rollback/

  Rollback to a previous :class:`~api.models.Release`.


Application Infrastructure
--------------------------

.. http:get:: /api/apps/(string:id)/containers/(string:type)/(int:num)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/(string:type)/

  List all :class:`~api.models.Container`\s.

.. http:get:: /api/apps/(string:id)/containers/

  List all :class:`~api.models.Container`\s.


Application Domains
-------------------


.. http:delete:: /api/apps/(string:id)/domains/(string:hostname)

  Destroy a :class:`~api.models.Domain` by its `hostname`

.. http:get:: /api/apps/(string:id)/domains/

  List all :class:`~api.models.Domain`\s.

.. http:post:: /api/apps/(string:id)/domains/

  Create a new :class:`~api.models.Domain`\s.


Application Actions
-------------------

.. http:post:: /api/apps/(string:id)/scale/

  See also
  :meth:`AppViewSet.scale() <api.views.AppViewSet.scale>`

.. http:get:: /api/apps/(string:id)/logs/

  See also
  :meth:`AppViewSet.logs() <api.views.AppViewSet.logs>`

.. http:post:: /api/apps/(string:id)/run/

  See also
  :meth:`AppViewSet.run() <api.views.AppViewSet.run>`


Application Sharing
===================

.. http:delete:: /api/apps/(string:id)/perms/(string:username)/

  Destroy an app permission by its `username`.

.. http:get:: /api/apps/(string:id)/perms/

  List all permissions granted to this app.

.. http:post:: /api/apps/(string:id)/perms/

  Create a new app permission.


Keys
====

.. http:get:: /api/keys/(string:id)/

  Retrieve a :class:`~api.models.Key` by its `id`.

.. http:delete:: /api/keys/(string:id)/

  Destroy a :class:`~api.models.Key` by its `id`.

.. http:get:: /api/keys/

  List all :class:`~api.models.Key`\s.

.. http:post:: /api/keys/

  Create a new :class:`~api.models.Key`.


API Hooks
=========

.. http:post:: /api/hooks/push/

  Create a new :class:`~api.models.Push`.

.. http:post:: /api/hooks/build/

  Create a new :class:`~api.models.Build`.

.. http:post:: /api/hooks/config/

  Retrieve latest application :class:`~api.models.Config`.


Auth
====

.. http:post:: /api/auth/register/

  Create a new User.

.. http:delete:: /api/auth/register/

  Destroy the logged-in User.

.. http:post:: /api/auth/login

  Authenticate for the REST framework.                    

.. http:post:: /api/auth/logout

  Clear authentication for the REST framework.                    

.. http:get:: /api/generate-api-key/

  Generate an API key.


Admin Sharing
=============

.. http:delete:: /api/admin/perms/(string:username)/

  Destroy an admin permission by its `username`.

.. http:get:: /api/admin/perms/

  List all admin permissions granted.

.. http:post:: /api/admin/perms/

  Create a new admin permission.

"""

from __future__ import unicode_literals

from django.conf import settings
from django.conf.urls import include
from django.conf.urls import patterns
from django.conf.urls import url

from api import routers
from api import views


router = routers.ApiRouter()

# Add the generated REST URLs and login/logout endpoint
urlpatterns = patterns(
    '',
    url(r'^', include(router.urls)),
    # application release components
    url(r'^apps/(?P<id>{})/config/?'.format(settings.APP_URL_REGEX),
        views.AppConfigViewSet.as_view({'get': 'retrieve', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/builds/(?P<uuid>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/builds/?'.format(settings.APP_URL_REGEX),
        views.AppBuildViewSet.as_view({'get': 'list', 'post': 'create'})),
    url(r'^apps/(?P<id>{})/releases/v(?P<version>[0-9]+)/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/releases/rollback/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'post': 'rollback'})),
    url(r'^apps/(?P<id>{})/releases/?'.format(settings.APP_URL_REGEX),
        views.AppReleaseViewSet.as_view({'get': 'list'})),
    # application infrastructure
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w]+)/(?P<num>[-_\w]+)/?'.format(
        settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'retrieve'})),
    url(r'^apps/(?P<id>{})/containers/(?P<type>[-_\w.]+)/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    url(r'^apps/(?P<id>{})/containers/?'.format(settings.APP_URL_REGEX),
        views.AppContainerViewSet.as_view({'get': 'list'})),
    # application domains
    url(r'^apps/(?P<id>{})/domains/(?P<domain>[-\._\w]+)/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/domains/?'.format(settings.APP_URL_REGEX),
        views.DomainViewSet.as_view({'post': 'create', 'get': 'list'})),
    # application actions
    url(r'^apps/(?P<id>{})/scale/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'scale'})),
    url(r'^apps/(?P<id>{})/logs/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'logs'})),
    url(r'^apps/(?P<id>{})/run/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'post': 'run'})),
    # apps sharing
    url(r'^apps/(?P<id>{})/perms/(?P<username>[-_\w]+)/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^apps/(?P<id>{})/perms/?'.format(settings.APP_URL_REGEX),
        views.AppPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
    # apps base endpoint
    url(r'^apps/(?P<id>{})/?'.format(settings.APP_URL_REGEX),
        views.AppViewSet.as_view({'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^apps/?',
        views.AppViewSet.as_view({'get': 'list', 'post': 'create'})),
    # key
    url(r'^keys/(?P<id>.+)/?',
        views.KeyViewSet.as_view({
            'get': 'retrieve', 'delete': 'destroy'})),
    url(r'^keys/?',
        views.KeyViewSet.as_view({'get': 'list', 'post': 'create'})),
    # hooks
    url(r'^hooks/push/?',
        views.PushHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/build/?',
        views.BuildHookViewSet.as_view({'post': 'create'})),
    url(r'^hooks/config/?',
        views.ConfigHookViewSet.as_view({'post': 'create'})),
    # authn / authz
    url(r'^auth/register/?',
        views.UserRegistrationView.as_view({'post': 'create'})),
    url(r'^auth/cancel/?',
        views.UserCancellationView.as_view({'delete': 'destroy'})),
    url(r'^auth/',                    
        include('rest_framework.urls', namespace='rest_framework')),                    
    url(r'^generate-api-key/',                    
        'rest_framework.authtoken.views.obtain_auth_token'),
    # admin sharing
    url(r'^admin/perms/(?P<username>[-_\w]+)/?',
        views.AdminPermsViewSet.as_view({'delete': 'destroy'})),
    url(r'^admin/perms/?',
        views.AdminPermsViewSet.as_view({'get': 'list', 'post': 'create'})),
)

"""
Django settings for the Deis project.
"""

from __future__ import unicode_literals
import os.path
import sys
import tempfile

PROJECT_ROOT = os.path.normpath(os.path.join(os.path.dirname(__file__), '..'))

DEBUG = False
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

CONN_MAX_AGE = 60 * 3

# Hosts/domain names that are valid for this site; required if DEBUG is False
# See https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts
ALLOWED_HOSTS = ['localhost']

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Denver'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/var/www/example.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://example.com/media/", "http://media.example.com/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/var/www/example.com/static/"
STATIC_ROOT = os.path.abspath(os.path.join(__file__, '..', '..', 'static'))

# URL prefix for static files.
# Example: "http://example.com/static/", "http://static.example.com/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = None  # @UnusedVariable

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.request",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages",
    "deis.context_processors.site",
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'api.middleware.VersionMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'deis.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'deis.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates"
    # or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    PROJECT_ROOT + '/web/templates',
)

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.humanize',
    'django.contrib.messages',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.staticfiles',
    # Third-party apps
    'django_fsm',
    'guardian',
    'json_field',
    'gunicorn',
    'rest_framework',
    'south',
    # Deis apps
    'api',
    'web',
)

AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "guardian.backends.ObjectPermissionBackend",
)

ANONYMOUS_USER_ID = -1
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = 'none'
ACCOUNT_LOGOUT_ON_GET = True
ACCOUNT_USERNAME_BLACKLIST = ['system']
LOGIN_URL = '/api/auth/login/'
LOGIN_REDIRECT_URL = '/'

SOUTH_TESTS_MIGRATE = False

REST_FRAMEWORK = {
    'DEFAULT_MODEL_SERIALIZER_CLASS':
    'rest_framework.serializers.ModelSerializer',
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',                    
    ),
    'PAGINATE_BY': 100,
}

# URLs that end with slashes are ugly
APPEND_SLASH = False

# Determine where to send syslog messages
if os.path.exists('/dev/log'):           # Linux rsyslog
    SYSLOG_ADDRESS = '/dev/log'
elif os.path.exists('/var/log/syslog'):  # Mac OS X syslog
    SYSLOG_ADDRESS = '/var/log/syslog'
else:                                    # default SysLogHandler address
    SYSLOG_ADDRESS = ('localhost', 514)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'null': {
            'level': 'DEBUG',
            'class': 'logging.NullHandler',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'rsyslog': {
            'class': 'logging.handlers.SysLogHandler',
            'address': SYSLOG_ADDRESS,
            'facility': 'local0',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['null'],
            'level': 'INFO',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['console', 'mail_admins'],
            'level': 'WARNING',
            'propagate': True,
        },
        'api': {
            'handlers': ['console', 'mail_admins', 'rsyslog'],
            'level': 'INFO',
            'propagate': True,
        },
    }
}
TEST_RUNNER = 'api.tests.SilentDjangoTestSuiteRunner'

# etcd settings
ETCD_HOST, ETCD_PORT = os.environ.get('ETCD', '127.0.0.1:4001').split(',')[0].split(':')

# default deis settings
DEIS_LOG_DIR = os.path.abspath(os.path.join(__file__, '..', '..', 'logs'))
LOG_LINES = 1000
TEMPDIR = tempfile.mkdtemp(prefix='deis')
DEFAULT_BUILD = 'deis/helloworld'
DEIS_DOMAIN = 'deisapp.local'

# default scheduler settings
SCHEDULER_MODULE = 'mock'
SCHEDULER_TARGET = ''  # path to scheduler endpoint (e.g. /var/run/fleet.sock)
SCHEDULER_AUTH = ''
SCHEDULER_OPTIONS = {}

# security keys and auth tokens
SSH_PRIVATE_KEY = ''  # used for SSH connections to facilitate "deis run"
SECRET_KEY = os.environ.get('DEIS_SECRET_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')
BUILDER_KEY = os.environ.get('DEIS_BUILDER_KEY', 'CHANGEME_sapm$s%upvsw5l_zuy_&29rkywd^78ff(qi')

# registry settings
REGISTRY_MODULE = 'registry.mock'
REGISTRY_URL = 'http://localhost:5000'
REGISTRY_HOST = 'localhost'
REGISTRY_PORT = 5000

# check if we can register users with `deis register`
REGISTRATION_ENABLED = True

# check if we should enable the web UI module
WEB_ENABLED = False

# default to sqlite3, but allow postgresql config through envvars
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.' + os.environ.get('DATABASE_ENGINE', 'postgresql_psycopg2'),
        'NAME': os.environ.get('DATABASE_NAME', 'deis'),
    }
}

APP_URL_REGEX = '[a-z0-9-]+'

# SECURITY: change this to allowed fqdn's to prevent host poisioning attacks
# see https://docs.djangoproject.com/en/1.5/ref/settings/#std:setting-ALLOWED_HOSTS
ALLOWED_HOSTS = ['*']

# Honor HTTPS from a trusted proxy
# see https://docs.djangoproject.com/en/1.6/ref/settings/#secure-proxy-ssl-header
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# Create a file named "local_settings.py" to contain sensitive settings data
# such as database configuration, admin email, or passwords and keys. It
# should also be used for any settings which differ between development
# and production.
# The local_settings.py file should *not* be checked in to version control.
try:
    from .local_settings import *  # @UnusedWildImport # noqa
except ImportError:
    pass


# have confd_settings within container execution override all others
# including local_settings (which may end up in the container)
if os.path.exists('/templates/confd_settings.py'):
    sys.path.append('/templates')
    from confd_settings import *  # noqa

import json
import unittest
import webtest

from datamodel import Library, Version, Content
from manage import app
import util

from google.appengine.ext import ndb

from test_base import TestBase

class ManageTestBase(TestBase):
  def setUp(self):
    TestBase.setUp(self)
    self.app = webtest.TestApp(app)

class ManageUpdateTest(ManageTestBase):
  def test_update_respects_304(self):
    library = Library(id='org/repo', metadata_etag='a', contributors_etag='b', tags_etag='c')
    library.put()
    self.respond_to_github('https://api.github.com/repos/org/repo', {'status': 304})
    self.respond_to_github('https://api.github.com/repos/org/repo/contributors', {'status': 304})
    self.respond_to_github('https://api.github.com/repos/org/repo/git/refs/tags', {'status': 304})

    self.app.get('/task/update/org/repo')                    
    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 0)

  def test_update_deletes(self):
    library = Library(id='org/repo', metadata_etag='a', contributors_etag='b', tags_etag='c')
    library.put()
    version = Version(parent=library.key, id='v1.0.0', sha='lol')
    version.put()

    self.respond_to_github('https://api.github.com/repos/org/repo', {'status': 404})
    self.app.get('/task/update/org/repo')                    

    version = Version.get_by_id('v1.0.0', parent=library.key)
    library = Library.get_by_id('org/repo')

    self.assertIsNone(library)
    self.assertIsNone(version)

class ManageAddTest(ManageTestBase):
  def test_add_element(self):
    response = self.app.get('/manage/add/element/org/repo')                    
    self.assertEqual(response.status_int, 200)
    self.assertEqual(response.normal_body, 'OK')

    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 1)
    self.assertEqual(tasks[0].url, util.ingest_library_task('org', 'repo', 'element'))

    self.respond_to_github('https://api.github.com/repos/org/repo', 'metadata bits')
    self.respond_to_github('https://api.github.com/repos/org/repo/contributors', '["a"]')
    self.respond_to_github('https://api.github.com/repos/org/repo/git/refs/tags', '[{"ref": "refs/tags/v1.0.0", "object": {"sha": "lol"}}]')
    response = self.app.get(util.ingest_library_task('org', 'repo', 'element'))                    
    self.assertEqual(response.status_int, 200)
    library = Library.get_by_id('org/repo')
    self.assertIsNotNone(library)
    self.assertIsNone(library.error)
    self.assertEqual(library.kind, 'element')
    self.assertEqual(library.metadata, 'metadata bits')
    self.assertEqual(library.contributors, '["a"]')
    self.assertEqual(library.contributor_count, 1)

    version = ndb.Key(Library, 'org/repo', Version, 'v1.0.0').get()
    self.assertIsNone(version.error)
    self.assertEqual(version.sha, 'lol')

    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 2)
    self.assertEqual(tasks[1].url, util.ingest_version_task('org', 'repo', 'v1.0.0') + '?latestVersion=True')

  def test_ingest_version(self):
    library = Library(id='org/repo', metadata='{"full_name": "NSS Bob", "stargazers_count": 420, "subscribers_count": 419, "forks": 418, "updated_at": "2011-8-10T13:47:12Z"}', contributor_count=417)
    version = Version(parent=library.key, id='v1.0.0', sha='lol')
    library.put()
    version.put()

    self.respond_to('https://raw.githubusercontent.com/org/repo/v1.0.0/README.md', 'README')
    self.respond_to('https://raw.githubusercontent.com/org/repo/v1.0.0/bower.json', '{}')
    self.respond_to_github('https://api.github.com/markdown', '<html>README</html>')

    response = self.app.get(util.ingest_version_task('org', 'repo', 'v1.0.0'))
    self.assertEqual(response.status_int, 200)

    version = version.key.get()
    self.assertIsNone(version.error)

    readme = ndb.Key(Library, 'org/repo', Version, 'v1.0.0', Content, 'readme').get()
    self.assertEqual(readme.content, 'README')
    readme_html = ndb.Key(Library, 'org/repo', Version, 'v1.0.0', Content, 'readme.html').get()
    self.assertEqual(readme_html.content, '<html>README</html>')
    bower = ndb.Key(Library, 'org/repo', Version, 'v1.0.0', Content, 'bower').get()
    self.assertEqual(bower.content, '{}')

  def test_ingest_version_falls_back(self):
    library = Library(id='org/repo', metadata='{"full_name": "NSS Bob", "stargazers_count": 420, "subscribers_count": 419, "forks": 418, "updated_at": "2011-8-10T13:47:12Z"}', contributor_count=417)
    library.tags = json.dumps(["v1.0.0", "v1.0.1"])
    library.put()
    version1 = Version(parent=library.key, id='v1.0.0', sha='lol')
    version1.put()
    version2 = Version(parent=library.key, id='v1.0.1', sha='lol')
    version2.put()

    self.respond_to('https://raw.githubusercontent.com/org/repo/v1.0.1/README.md', chr(248))

    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 0)

    self.app.get(util.ingest_version_task('org', 'repo', 'v1.0.1'), params={'latestVersion': 'True'})                    

    version2 = version2.key.get()
    self.assertEqual(version2.error, "Could not store README.md as a utf-8 string")

    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 1)
    self.assertEqual(tasks[0].url, util.ingest_version_task('org', 'repo', 'v1.0.0') + '?latestVersion=True')

  def test_ingest_commit(self):
    self.respond_to_github('https://api.github.com/repos/org/repo', 'metadata bits')
    self.respond_to_github('https://api.github.com/repos/org/repo/contributors', '["a"]')
    self.app.get(util.ingest_commit_task('org', 'repo'), params={'commit': 'commit-sha', 'url': 'url'})                    

    library = Library.get_by_id('org/repo')
    self.assertIsNotNone(library)
    self.assertIsNone(library.error)
    self.assertFalse(library.ingest_versions)

    version = Version.get_by_id(parent=library.key, id='commit-sha')
    self.assertEqual(version.sha, 'commit-sha')
    self.assertEqual(version.url, 'url')

    tasks = self.tasks.get_filtered_tasks()
    self.assertEqual(len(tasks), 1)
    self.assertEqual(tasks[0].url, util.ingest_version_task('org', 'repo', 'commit-sha'))

if __name__ == '__main__':
  unittest.main()

# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c, request, g
from pylons.i18n import _
from pylons.controllers.util import abort
from r2.lib import utils, captcha
from r2.lib.filters import unkeep_space, websafe, _force_utf8, _force_ascii
from r2.lib.db.operators import asc, desc
from r2.config import cache
from r2.lib.template_helpers import add_sr
from r2.lib.jsonresponse import json_respond

from r2.models import *

from r2.controllers.errors import errors, UserRequiredException

from copy import copy
from datetime import datetime, timedelta
import re

class Validator(object):
    default_param = None
    def __init__(self, param=None, default=None, post=True, get=True, url=True):
        if param:
            self.param = param
        else:
            self.param = self.default_param

        self.default = default
        self.post, self.get, self.url = post, get, url

    def __call__(self, url):
        a = []
        if self.param:
            for p in utils.tup(self.param):
                if self.post and request.post.get(p):
                    val = request.post[p]
                elif self.get and request.get.get(p):
                    val = request.get[p]
                elif self.url and url.get(p):
                    val = url[p]
                else:
                    val = self.default
                a.append(val)
        return self.run(*a)

def validate(*simple_vals, **param_vals):
    def val(fn):
        def newfn(self, *a, **env):
            try:
                for validator in simple_vals:
                    validator(env)
                
                kw = self.build_arg_list(fn, env)
                for var, validator in param_vals.iteritems():
                    kw[var] = validator(env)
                
                return fn(self, *a, **kw)

            except UserRequiredException:
                if request.method == "POST" and hasattr(self, "ajax_login_redirect"):
                    # ajax failure, so redirect accordingly
                    return  self.ajax_login_redirect("/")
                return self.intermediate_redirect('/login')
        return newfn
    return val


#### validators ####
class nop(Validator):
    def run(self, x):
        return x

class VLang(Validator):
    def run(self, lang):
        if lang:
            lang = str(lang.split('[')[1].strip(']'))
            if lang in g.all_languages:
                return lang
        #else
        return 'en'

class VRequired(Validator):
    def __init__(self, param, error, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self._error = error

    def error(self, e = None):
        if not e: e = self._error
        if e:
            c.errors.add(e)
        
    def run(self, item):
        if not item:
            self.error()
        else:
            return item

class ValueOrBlank(Validator):
    def run(self, value):
        """Returns the value as is if present, else an empty string"""
        return '' if value is None else value

class VLink(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect
    
    def run(self, link_id):
        if link_id:
            try:
                aid = int(link_id, 36)
                return Link._byID(aid, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VMeetup(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect

    def run(self, meetup_id36):
        if meetup_id36:
            try:
                meetup_id = int(meetup_id36, 36)
                return Meetup._byID(meetup_id, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VEditMeetup(VMeetup):
    def __init__(self, param, redirect = True, *a, **kw):
        VMeetup.__init__(self, param, redirect = redirect, *a, **kw)

    def run(self, param):
        meetup = VMeetup.run(self, param)
        if meetup and not (c.user_is_loggedin and 
                           meetup.can_edit(c.user, c.user_is_admin)):
            abort(403, "forbidden")
        return meetup

class VTagByName(Validator):
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, name):
        if name:
            cleaned = _force_ascii(name)
            if cleaned == name:
                try:
                    return Tag._by_name(cleaned)
                except:
                    pass                    
            abort(404, 'page not found')

class VTags(Validator):
    comma_sep = re.compile('[,\s]+', re.UNICODE)
    
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, tag_field):
        tags = []
        if tag_field:
            # Tags are comma delimited
            tags = [x for x in self.comma_sep.split(tag_field) if x==_force_ascii(x)]
        return tags

class VMessage(Validator):
    def run(self, message_id):
        if message_id:
            try:
                aid = int(message_id, 36)
                return Message._byID(aid, True)
            except (NotFound, ValueError):
                abort(404, 'page not found')


class VCommentID(Validator):
    def run(self, cid):
        if cid:
            try:
                cid = int(cid, 36)
                return Comment._byID(cid, True)
            except (NotFound, ValueError):
                pass                    

class VCount(Validator):
    def run(self, count):
        if count is None:
            count = 0
        return max(int(count), 0)


class VLimit(Validator):
    def run(self, limit):
        if limit is None:
            return c.user.pref_numsites 
        return min(max(int(limit), 1), 250)

class VCssMeasure(Validator):
    measure = re.compile(r"^\s*[\d\.]+\w{0,3}\s*$")
    def run(self, value):
        return value if value and self.measure.match(value) else ''

subreddit_rx = re.compile(r"^[\w]{3,20}$", re.UNICODE)

def chksrname(x):
    #notice the space before reddit.com
    if x in ('friends', 'all', ' reddit.com'):
        return False

    try:
        return str(x) if x and subreddit_rx.match(x) else None
    except UnicodeEncodeError:
        return None

class VLinkUrls(Validator):
    "A comma-separated list of link urls"
    splitter = re.compile('[ ,]+')
    id_re = re.compile('^/lw/([^/]+)/')
    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        res=[]
        for v in self.splitter.split(val):
            link_id = self.id_re.match(v)
            if link_id:
                l = VLink(None,False).run(link_id.group(1))
                if l:
                    res.append(l)
        return res

class VLinkFullnames(Validator):
    "A space- or comma-separated list of fullnames for Links"
    valid_re = re.compile(r'^(' + Link._type_prefix + str(Link._type_id) +
                          r'_[0-9a-z]+[ ,]?)+$')
    splitter = re.compile('[ ,]+')

    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        if val and self.valid_re.match(val):
            return self.splitter.split(val)
    
class VLength(Validator):
    def __init__(self, item, length = 10000,
                 empty_error = errors.BAD_COMMENT,
                 length_error = errors.COMMENT_TOO_LONG, **kw):
        Validator.__init__(self, item, **kw)
        self.length = length
        self.len_error = length_error
        self.emp_error = empty_error

    def run(self, title):
        if not title:
            if self.emp_error is not None:
                c.errors.add(self.emp_error)
        elif len(title) > self.length:
            c.errors.add(self.len_error)
        else:
            return title
        
class VTitle(VLength):
    only_whitespace = re.compile(r"^\s*$", re.UNICODE)
    
    def __init__(self, item, length = 200, **kw):
        VLength.__init__(self, item, length = length,
                         empty_error = errors.NO_TITLE,
                         length_error = errors.TITLE_TOO_LONG, **kw)

    def run(self, title):
        title = VLength.run(self, title)
        if title and self.only_whitespace.match(title):
            c.errors.add(errors.NO_TITLE)
        else:
            return title
    
class VComment(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, **kw)

        
class VMessage(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, 
                         empty_error = errors.NO_MSG_BODY, **kw)


class VSubredditName(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_SR_NAME, *a, **kw)

    def run(self, name):
        name = chksrname(name)
        if not name:
            return self.error()
        else:
            try:
                a = Subreddit._by_name(name)
                return self.error(errors.SUBREDDIT_EXISTS)
            except NotFound:
                return name

class VSubredditTitle(Validator):
    def run(self, title):
        if not title:
            c.errors.add(errors.NO_TITLE)
        elif len(title) > 100:
            c.errors.add(errors.TITLE_TOO_LONG)
        else:
            return title

class VSubredditDesc(Validator):
    def run(self, description):
        if description and len(description) > 500:
            c.errors.add(errors.DESC_TOO_LONG)
        return unkeep_space(description or '')

class VAccountByName(VRequired):
    def __init__(self, param, error = errors.USER_DOESNT_EXIST, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)
        
    def run(self, name):
        if name:
            try:
                return Account._by_name(name)
            except NotFound: pass                    
        return self.error()

class VByName(VRequired):
    def __init__(self, param, 
                 error = errors.NO_THING_ID, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)

    def run(self, fullname):
        if fullname:
            try:
                return Thing._by_fullname(fullname, False, data=True)
            except NotFound:
                pass                    
        return self.error()

class VByNameIfAuthor(VByName):
    def run(self, fullname):
        thing = VByName.run(self, fullname)
        if thing:
            if not thing._loaded: thing._load()
            if c.user_is_loggedin and thing.author_id == c.user._id:
                return thing
        return self.error(errors.NOT_AUTHOR)

class VCaptcha(Validator):
    default_param = ('iden', 'captcha')
    
    def run(self, iden, solution):
        if (not c.user_is_loggedin or c.user.needs_captcha()):
            if not captcha.valid_solution(iden, solution):
                c.errors.add(errors.BAD_CAPTCHA)

class VUser(Validator):
    def run(self, password = None):                    
        if not c.user_is_loggedin:
            raise UserRequiredException

        if (password is not None) and not valid_password(c.user, password):                    
            c.errors.add(errors.WRONG_PASSWORD)
            
class VModhash(Validator):
    default_param = 'uh'
    def run(self, uh):
        pass                    

class VVotehash(Validator):
    def run(self, vh, thing_name):
        return True

class VAdmin(Validator):
    def run(self):
        if not c.user_is_admin:
            abort(404, "page not found")

class VSponsor(Validator):
    def run(self):
        if not c.user_is_sponsor:
            abort(403, 'forbidden')

class VSrModerator(Validator):
    def run(self):
        if not (c.user_is_loggedin and c.site.is_moderator(c.user) 
                or c.user_is_admin):
            abort(403, "forbidden")

class VSrCanBan(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.can_ban(c.user):
                return True
        abort(403,'forbidden')

class VSrSpecial(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.is_special(c.user):
                return True
        abort(403,'forbidden')

class VSRSubmitPage(Validator):
    def run(self):
        if not (c.default_sr or c.user_is_loggedin and c.site.can_submit(c.user)):
            return False
        else:
            return True

class VCreateMeetup(Validator):
    def run(self):
        if (c.user_is_loggedin and c.user.safe_karma >= g.discussion_karma_to_post):
            return True
        abort(403, "forbidden")

class VSubmitParent(Validator):
    def run(self, fullname):
        if fullname:
            parent = Thing._by_fullname(fullname, False, data=True)
            if isinstance(parent, Message):
                return parent
            else:
                sr = parent.subreddit_slow
                if c.user_is_loggedin and sr.can_comment(c.user):
                    return parent
        #else
        abort(403, "forbidden")
        
class VSubmitLink(VLink):
    def __init__(self, param, redirect = True, *a, **kw):
        VLink.__init__(self, param, redirect = redirect, *a, **kw)
        
    def run(self, link_name):
        link = VLink.run(self, link_name)
        if link and not (c.user_is_loggedin and link.can_submit(c.user)):
            abort(403, "forbidden")
        return link

class VSubmitSR(Validator):
    def run(self, sr_name):
        try:
            sr = Subreddit._by_name(sr_name)
        except NotFound:
            c.errors.add(errors.SUBREDDIT_NOEXIST)
            sr = None

        if sr and not (c.user_is_loggedin and sr.can_submit(c.user)):
            c.errors.add(errors.SUBREDDIT_FORBIDDEN)
            sr = None

        return sr
        
pass_rx = re.compile(r".{3,20}")                    

def chkpass(x):                    
    return x if x and pass_rx.match(x) else None                    

class VPassword(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_PASSWORD, *a, **kw)
    def run(self, password, verify):                    
        if not chkpass(password):                    
            return self.error()
        elif verify != password:                    
            return self.error(errors.BAD_PASSWORD_MATCH)
        else:
            return password                    

user_rx = re.compile(r"^[\w-]{3,20}$", re.UNICODE)

def chkuser(x):
    try:
        return str(x) if user_rx.match(x) else None
    except TypeError:
        return None
    except UnicodeEncodeError:
        return None

def whyuserbad(x):
    if not x:
        return errors.BAD_USERNAME_CHARS
    if len(x)<3:
        return errors.BAD_USERNAME_SHORT
    if len(x)>20:
        return errors.BAD_USERNAME_LONG
    return errors.BAD_USERNAME_CHARS

class VUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_USERNAME, *a, **kw)
    def run(self, user_name):
        original_user_name = user_name;
        user_name = chkuser(user_name)
        if not user_name:
            return self.error(whyuserbad(original_user_name))
        else:
            try:
                a = Account._by_name(user_name, True)
                return self.error(errors.USERNAME_TAKEN)
            except NotFound:
                return user_name

class VLogin(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.WRONG_PASSWORD, *a, **kw)
        
    def run(self, user_name, password):                    
        user_name = chkuser(user_name)
        user = None
        if user_name:
            user = valid_login(user_name, password)                    
        if not user:
            return self.error()
        return user


class VSanitizedUrl(Validator):
    def run(self, url):
        return utils.sanitize_url(url)

class VUserWebsiteUrl(VSanitizedUrl):
    def run(self, url):
        val = VSanitizedUrl.run(self, url)
        if val is None:
            return ''
        else:
            return val

class VUrl(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_URL, *a, **kw)

    def run(self, url, sr = None):
        if sr is None and not isinstance(c.site, FakeSubreddit):
            sr = c.site
        elif sr:
            try:
                sr = Subreddit._by_name(sr)
            except NotFound:
                c.errors.add(errors.SUBREDDIT_NOEXIST)
                sr = None
        else:
            sr = None
        
        if not url:
            return self.error(errors.NO_URL)
        url = utils.sanitize_url(url)
        if url == 'self':
            return url
        elif url:
            try:
                l = Link._by_url(url, sr)
                self.error(errors.ALREADY_SUB)
                return utils.tup(l)
            except NotFound:
                return url
        return self.error(errors.BAD_URL)

class VExistingUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_USER, *a, **kw)

    def run(self, username):
        if username:
            try:
                name = _force_utf8(username)
                return Account._by_name(name)
            except (TypeError, UnicodeEncodeError, NotFound):
                return self.error(errors.USER_DOESNT_EXIST)
        self.error()

class VUserWithEmail(VExistingUname):
    def run(self, name):
        user = VExistingUname.run(self, name)
        if not user or not hasattr(user, 'email') or not user.email:
            return self.error(errors.NO_EMAIL_FOR_USER)
        return user
            

class VBoolean(Validator):
    def run(self, val):
        return val != "off" and bool(val)

class VLocation(VLength):
    def __init__(self, item, length = 100, **kw):
        VLength.__init__(self, item, length = length, 
                         length_error = errors.LOCATION_TOO_LONG,
                         empty_error = None, **kw)

    def run(self, val):
        val = VLength.run(self, val)
        if val == None:
            return ''
        else:
            return val

class VInt(Validator):
    def __init__(self, param, min=None, max=None, *a, **kw):
        self.min = min
        self.max = max
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            return

        try:
            val = int(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(errors.BAD_NUMBER)

class VFloat(Validator):
    def __init__(self, param, min=None, max=None, error=errors.BAD_NUMBER, *a, **kw):
        self.min = min
        self.max = max
        self.error = error
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            c.errors.add(self.error)
            return

        try:
            val = float(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(self.error)

class VCssName(Validator):
    """
    returns a name iff it consists of alphanumeric characters and
    possibly "-", and is below the length limit.
    """
    r_css_name = re.compile(r"^[a-zA-Z0-9\-]{1,100}$")
    def run(self, name):
        if name and self.r_css_name.match(name):
            return name
    
class VMenu(Validator):

    def __init__(self, param, menu_cls, remember = True, **kw):
        self.nav = menu_cls
        self.remember = remember
        param = (menu_cls.get_param, param)
        Validator.__init__(self, param, **kw)

    def run(self, sort, where):
        if self.remember:
            pref = "%s_%s" % (where, self.nav.get_param)
            user_prefs = copy(c.user.sort_options) if c.user else {}
            user_pref = user_prefs.get(pref)
    
            # check to see if a default param has been set
            if not sort:
                sort = user_pref
            
        # validate the sort
        if sort not in self.nav.options:
            sort = self.nav.default

        # commit the sort if changed
        if self.remember and c.user_is_loggedin and sort != user_pref:
            user_prefs[pref] = sort
            c.user.sort_options = user_prefs
            user = c.user
            utils.worker.do(lambda: user._commit())

        return sort
            

class VRatelimit(Validator):
    def __init__(self, rate_user = False, rate_ip = False,
                 prefix = 'rate_', *a, **kw):
        self.rate_user = rate_user
        self.rate_ip = rate_ip
        self.prefix = prefix
        Validator.__init__(self, *a, **kw)

    def run (self):
        to_check = []
        if self.rate_user and c.user_is_loggedin:
            to_check.append('user' + str(c.user._id36))
        if self.rate_ip:
            to_check.append('ip' + str(request.ip))

        r = cache.get_multi(to_check, self.prefix)
        if r:
            expire_time = max(r.values())
            time = utils.timeuntil(expire_time)
            c.errors.add(errors.RATELIMIT, {'time': time})

    @classmethod
    def ratelimit(self, rate_user = False, rate_ip = False, prefix = "rate_"):
        to_set = {}
        seconds = g.RATELIMIT*60

        if seconds <= 0:
            return

        expire_time = datetime.now(g.tz) + timedelta(seconds = seconds)
        if rate_user and c.user_is_loggedin:
            to_set['user' + str(c.user._id36)] = expire_time
        if rate_ip:
            to_set['ip' + str(request.ip)] = expire_time

        cache.set_multi(to_set, prefix, time = seconds)

class VCommentIDs(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        if not id_str:
            return None
        cids = [int(i, 36) for i in id_str.split(',')]
        comments = Comment._byID(cids, data=True, return_dict = False)
        return comments

class VFullNames(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        tids = id_str.split(',')
        return Thing._by_fullname(tids, data=True, return_dict = False)

class VSubreddits(Validator):
    #the subreddits are just in the post, this is for the my.reddit pref page
    def run(self):
        subreddits = Subreddit._by_fullname(request.post.keys())
        return subreddits.values()

class VCacheKey(Validator):
    def __init__(self, cache_prefix, param, *a, **kw):
        self.cache_prefix = cache_prefix
        Validator.__init__(self, param, *a, **kw)

    def run(self, key, name):
        if key:
            uid = cache.get(str(self.cache_prefix + "_" + key))
            try:
                a = Account._byID(uid, data = True)
            except NotFound:
                return None
            if name and a.name.lower() != name.lower():
                c.errors.add(errors.BAD_USERNAME)
            if a:
                return a
        c.errors.add(errors.EXPIRED)

class VOneOf(Validator):
    def __init__(self, param, options = (), *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.options = options

    def run(self, val):
        if self.options and val not in self.options:
            c.errors.add(errors.INVALID_OPTION)
            return self.default
        else:
            return val

class VReason(Validator):
    def run(self, reason):
        if not reason:
            return

        if reason.startswith('redirect_'):
            dest = reason[9:]
            if (not dest.startswith(c.site.path) and 
                not dest.startswith("http:")):
                dest = (c.site.path + dest).replace('//', '/')
            return ('redirect', dest)
        if reason.startswith('vote_'):
            fullname = reason[5:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('share_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('reply_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('sr_change_'):
            sr_list = reason[10:].split(',')
            fullnames = dict(i.split(':') for i in sr_list)
            srs = Subreddit._by_fullname(fullnames.keys(), data = True,
                                         return_dict = False)
            sr_onoff = dict((sr, fullnames[sr._fullname] == 1) for sr in srs)
            return ('subscribe', sr_onoff)


class ValidEmails(Validator):
    """Validates a list of email addresses passed in as a string and                    
    delineated by whitespace, ',' or ';'.  Also validates quantity of
    provided emails.  Returns a list of valid email addresses on
    success"""
    
    separator = re.compile(r'[^\s,;]+')
    email_re  = re.compile(r'.+@.+\..+')

    def __init__(self, param, num = 20, **kw):
        self.num = num
        Validator.__init__(self, param = param, **kw)
        
    def run(self, emails0):
        emails = set(self.separator.findall(emails0) if emails0 else [])
        failures = set(e for e in emails if not self.email_re.match(e))
        emails = emails - failures

        # make sure the number of addresses does not exceed the max
        if self.num > 0 and len(emails) + len(failures) > self.num:
            # special case for 1: there should be no delineators at all, so
            # send back original string to the user
            if self.num == 1:
                c.errors.add(errors.BAD_EMAILS,
                             {'emails': '"%s"' % emails0})
            # else report the number expected
            else:
                c.errors.add(errors.TOO_MANY_EMAILS,
                             {'num': self.num})
        # correct number, but invalid formatting
        elif failures:
            c.errors.add(errors.BAD_EMAILS,
                         {'emails': ', '.join(failures)})
        # no emails
        elif not emails:
            c.errors.add(errors.NO_EMAILS)
        else:
            # return single email if one is expected, list otherwise
            return list(emails)[0] if self.num == 1 else emails


class VCnameDomain(Validator):
    domain_re  = re.compile(r'^([\w]+\.)+[\w]+$')

    def run(self, domain):
        if (domain
            and (not self.domain_re.match(domain)
                 or domain.endswith('.reddit.com')
                 or len(domain) > 300)):
            c.errors.add(errors.BAD_CNAME)
        elif domain:
            try:
                return str(domain).lower()
            except UnicodeEncodeError:
                c.errors.add(errors.BAD_CNAME)




# NOTE: make sure *never* to have res check these are present
# otherwise, the response could contain reference to these errors...!
class ValidIP(Validator):
    def run(self):
        if is_banned_IP(request.ip):
            c.errors.add(errors.BANNED_IP)
        return request.ip

class ValidDomain(Validator):
    def run(self, url):
        if url and is_banned_domain(url):
            c.errors.add(errors.BANNED_DOMAIN)

# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c
from r2.lib.db.thing     import Thing, Relation, NotFound
from r2.lib.db.operators import lower
from r2.lib.db.userrel   import UserRel
from r2.lib.memoize      import memoize, clear_memo
from r2.lib.utils        import modhash, valid_hash, randstr                     
from r2.lib.strings      import strings, plurals

from pylons import g
from pylons.i18n import _
import time, hashlib
from copy import copy

class AccountExists(Exception): pass
class NotEnoughKarma(Exception): pass

class Account(Thing):
    _data_int_props = Thing._data_int_props + ('link_karma', 'comment_karma',
                                               'report_made', 'report_correct',
                                               'report_ignored', 'spammer',
                                               'reported')
    _int_prop_suffix = '_karma'
    _defaults = dict(pref_numsites = 10,
                     pref_frame = False,
                     pref_newwindow = False,
                     pref_public_votes = False,
                     pref_kibitz = False,
                     pref_hide_ups = False,
                     pref_hide_downs = True,
                     pref_min_link_score = -2,
                     pref_min_comment_score = -2,
                     pref_num_comments = g.num_comments,
                     pref_lang = 'en',
                     pref_content_langs = ('en',),
                     pref_over_18 = False,
                     pref_compress = False,
                     pref_organic = True,
                     pref_show_stylesheets = True,
                     pref_url = '',
                     pref_location = '',
                     reported = 0,
                     report_made = 0,
                     report_correct = 0,
                     report_ignored = 0,
                     spammer = 0,
                     sort_options = {},
                     has_subscribed = False,
                     pref_media = 'subreddit',
                     share = {},
                     )

    def karma(self, kind, sr = None):
        from subreddit import Subreddit
        suffix = '_' + kind + '_karma'
        
        #if no sr, return the sum
        if sr is None:
            total = 0
            for k, v in self._t.iteritems():
                if k.endswith(suffix):
                    if kind == 'link':
                        try:
                            karma_sr_name = k[0:k.rfind(suffix)]
                            karma_sr = Subreddit._by_name(karma_sr_name)
                            multiplier = karma_sr.post_karma_multiplier
                        except NotFound:
                            multiplier = 1
                    else:
                        multiplier = 1
                    total += v * multiplier
            return total
        else:
            try:
                return getattr(self, sr.name + suffix)
            except AttributeError:
                #if positive karma elsewhere, you get min_up_karma
                if self.karma(kind) > 0:
                    return g.MIN_UP_KARMA
                else:
                    return 0

    def incr_karma(self, kind, sr, amt):
        prop = '%s_%s_karma' % (sr.name, kind)
        if hasattr(self, prop):
            return self._incr(prop, amt)
        else:
            default_val = self.karma(kind, sr)
            setattr(self, prop, default_val + amt)
            self._commit()

    @property
    def link_karma(self):
        return self.karma('link')

    @property
    def comment_karma(self):
        return self.karma('comment')

    @property
    def safe_karma(self):
        karma = self.link_karma + self.comment_karma
        return max(karma, 0) if karma > -1000 else karma

    def all_karmas(self):
        """returns a list of tuples in the form (name, link_karma,
        comment_karma)"""
        link_suffix = '_link_karma'
        comment_suffix = '_comment_karma'
        karmas = []
        sr_names = set()
        for k in self._t.keys():
            if k.endswith(link_suffix):
                sr_names.add(k[:-len(link_suffix)])
            elif k.endswith(comment_suffix):
                sr_names.add(k[:-len(comment_suffix)])
        for sr_name in sr_names:
            karmas.append((sr_name,
                           self._t.get(sr_name + link_suffix, 0),
                           self._t.get(sr_name + comment_suffix, 0)))
        karmas.sort(key = lambda x: x[1] + x[2])

        karmas.insert(0, ('total',
                          self.karma('link'),
                          self.karma('comment')))

        karmas.append(('old',
                       self._t.get('link_karma', 0),
                       self._t.get('comment_karma', 0)))

        return karmas

    def vote_cache_key(self, kind):
        """kind is 'link' or 'comment'"""
        return 'account_%d_%s_downvotes' % (self._id, kind)

    def check_downvote(self, vote_kind):
        """Checks whether this account has enough karma to cast a downvote.

        vote_kind is 'link' or 'comment' depending on the type of vote that's
        being cast.

        This makes the assumption that the user can't cast a vote for something
        on the non-current subreddit.
        """
        from r2.models.vote import Vote, Link, Comment

        def get_cached_downvotes(content_cls):
            kind = content_cls.__name__.lower()
            downvotes = g.cache.get(self.vote_cache_key(kind))
            if downvotes is None:
                vote_cls = Vote.rel(Account, content_cls)
                downvotes = len(list(vote_cls._query(Vote.c._thing1_id == self._id,
                                                          Vote.c._name == str(-1))))
                g.cache.set(self.vote_cache_key(kind), downvotes)
            return downvotes

        link_downvote_karma = get_cached_downvotes(Link) * c.current_or_default_sr.post_karma_multiplier
        comment_downvote_karma = get_cached_downvotes(Comment)
        karma_spent = link_downvote_karma + comment_downvote_karma

        karma_balance = self.safe_karma * 4
        vote_cost = c.current_or_default_sr.post_karma_multiplier if vote_kind == 'link' else 1
        if karma_spent + vote_cost > karma_balance:
            points_needed = abs(karma_balance - karma_spent - vote_cost)
            msg = strings.not_enough_downvote_karma % (points_needed, plurals.N_points(points_needed))
            raise NotEnoughKarma(msg)

    def incr_downvote(self, delta, kind):
        """kind is link or comment"""
        try:
            g.cache.incr(self.vote_cache_key(kind), delta)
        except ValueError, e:
            print 'Account.incr_downvote failed with: %s' % e

    def make_cookie(self, timestr = None, admin = False):
        if not self._loaded:
            self._load()
        timestr = timestr or time.strftime('%Y-%m-%dT%H:%M:%S')
        id_time = str(self._id) + ',' + timestr
        to_hash = ','.join((id_time, self.password, g.SECRET))
        if admin:
            to_hash += 'admin'
        return id_time + ',' + hashlib.sha1(to_hash).hexdigest()

    def needs_captcha(self):
        return self.safe_karma < 1

    def modhash(self, rand=None, test=False):                    
        return modhash(self, rand = rand, test = test)                    
    
    def valid_hash(self, hash):
        return valid_hash(self, hash)                    

    @classmethod
    @memoize('account._by_name')
    def _by_name_cache(cls, name, allow_deleted = False):
        #relower name here, just in case
        deleted = (True, False) if allow_deleted else False
        q = cls._query(lower(Account.c.name) == name.lower(),
                       Account.c._spam == (True, False),
                       Account.c._deleted == deleted)

        q._limit = 1
        l = list(q)
        if l:
            return l[0]._id

    @classmethod
    def _by_name(cls, name, allow_deleted = False):
        #lower name here so there is only one cache
        uid = cls._by_name_cache(name.lower(), allow_deleted)
        if uid:
            return cls._byID(uid, True)
        else:
            raise NotFound, 'Account %s' % name

    @property
    def friends(self):
        return self.friend_ids()

    def delete(self):
        self._deleted = True
        self._commit()
        clear_memo('account._by_name', Account, self.name.lower(), False)
        
        #remove from friends lists
        q = Friend._query(Friend.c._thing2_id == self._id,
                          Friend.c._name == 'friend',
                          eager_load = True)
        for f in q:
            f._thing1.remove_friend(f._thing2)

    @property
    def subreddits(self):
        from subreddit import Subreddit
        return Subreddit.user_subreddits(self)

    @property
    def draft_sr_name(self):
      return self.name + "-drafts"

    def recent_share_emails(self):
        return self.share.get('recent', set([]))

    def add_share_emails(self, emails):
        if not emails:
            return
        
        if not isinstance(emails, set):
            emails = set(emails)

        self.share.setdefault('emails', {})
        share = self.share.copy()

        share_emails = share['emails']
        for e in emails:
            share_emails[e] = share_emails.get(e, 0) +1
            
        share['recent'] = emails

        self.share = share
        
            
            


class FakeAccount(Account):
    _nodb = True


def valid_cookie(cookie):
    try:
        uid, timestr, hash = cookie.split(',')
        uid = int(uid)
    except:
        return (False, False)

    try:
        account = Account._byID(uid, True)
        if account._deleted:
            return (False, False)
    except NotFound:
        return (False, False)

    if cookie == account.make_cookie(timestr, admin = False):
        return (account, False)
    elif cookie == account.make_cookie(timestr, admin = True):
        return (account, True)
    return (False, False)

def valid_login(name, password):
    try:
        a = Account._by_name(name)
    except NotFound:
        return False

    if not a._loaded: a._load()
    return valid_password(a, password)

def valid_password(a, password):
    try:
        if a.password == passhash(a.name, password, ''):
            #add a salt
            a.password = passhash(a.name, password, True)
            a._commit()
            return a
        else:
            salt = a.password[:3]
            if a.password == passhash(a.name, password, salt):
                return a
    except AttributeError:
        return False

def passhash(username, password, salt = ''):
    if salt is True:
        salt = randstr(3)
    tohash = '%s%s %s' % (salt, username, password)
    if isinstance(tohash, unicode):
        # Force tohash to be a byte string so it can be hashed
        tohash = tohash.encode('utf8')
    return salt + hashlib.sha1(tohash).hexdigest()

def change_password(user, newpassword):
    user.password = passhash(user.name, newpassword, True)
    user._commit()
    return True

#TODO reset the cache
def register(name, password, email=None):
    try:
        a = Account._by_name(name)
        raise AccountExists
    except NotFound:
        a = Account(name = name,
                    password = passhash(name, password, True))
        if email:
            a.email = email

        a._commit()
            
        # Clear memoization of both with and without deleted
        clear_memo('account._by_name', Account, name.lower(), True)
        clear_memo('account._by_name', Account, name.lower(), False)
        return a

class Friend(Relation(Account, Account)): pass
Account.__bases__ += (UserRel('friend', Friend),)

from reddit_base import RedditController
from r2.lib.pages import BoringPage, ShowMeetup, NewMeetup, EditMeetup, PaneStack, CommentListing, LinkInfoPage, CommentReplyBox, NotEnoughKarmaToPost
from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup                    
from errors import errors
from r2.lib.jsonresponse import Json
from routes.util import url_for
from r2.models import Meetup,Link,Subreddit,CommentBuilder
from r2.models.listing import NestedListing
from r2.lib.menus import CommentSortMenu,NumCommentsMenu
from r2.lib.filters import python_websafe
from mako.template import Template
from pylons.i18n import _
from pylons import c,g,request
import json

def meetup_article_text(meetup):
  t = Template(filename="r2/templates/showmeetup.html", output_encoding='utf-8', encoding_errors='replace')
  res = t.get_def("meetup_info").render_unicode(meetup=meetup)

  url = url_for(controller='meetups',action='show',id=meetup._id36)
  title = python_websafe(meetup.title)
  hdr = u"<h2>Discussion article for the meetup : <a href='%s'>%s</a></h2>"%(url,title)
  return hdr+res+hdr

def meetup_article_title(meetup):
  return "Meetup : %s"%meetup.title

class MeetupsController(RedditController):
  def response_func(self, **kw):
    return self.sendstring(json.dumps(kw))

  @validate(VUser(), 
            VCreateMeetup(),
            title = ValueOrBlank('title'),
            description = ValueOrBlank('description'),
            location = ValueOrBlank('location'),
            latitude = ValueOrBlank('latitude'),
            longitude = ValueOrBlank('longitude'),
            timestamp = ValueOrBlank('timestamp'),
            tzoffset = ValueOrBlank('tzoffset'))
  def GET_new(self, *a, **kw):
    return BoringPage(pagename = 'New Meetup', content = NewMeetup(*a, **kw)).render()

  @Json
  @validate(VUser(),
            VCreateMeetup(),
            ip = ValidIP(),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_create(self, res, title, description, location, latitude, longitude, timestamp, tzoffset, ip):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup = Meetup(
      author_id = c.user._id,

      title = title,
      description = description,

      location = location,
      latitude = latitude,
      longitude = longitude,

      timestamp = timestamp / 1000, # Value from form is in ms UTC
      tzoffset = tzoffset
    )

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    l = Link._submit(meetup_article_title(meetup), meetup_article_text(meetup),
                     c.user, Subreddit._by_name('discussion'),ip, [])

    l.meetup = meetup._id36
    l._commit()
    meetup.assoc_link = l._id
    meetup._commit()

    #update the queries
    if g.write_query_queue:
      queries.new_link(l)

    res._redirect(url_for(action='show', id=meetup._id36))

  @Json
  @validate(VUser(),
            meetup = VEditMeetup('id'),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_update(self, res, meetup, title, description, location, latitude, longitude, timestamp, tzoffset):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup.title = title
    meetup.description = description

    meetup.location = location
    meetup.latitude = latitude
    meetup.longitude = longitude

    meetup.timestamp = timestamp / 1000 # Value from form is in ms UTC
    meetup.tzoffset = tzoffset

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    # Update the linked article
    article = Link._byID(meetup.assoc_link)
    article._load()
    article_old_url = article.url
    article.title = meetup_article_title(meetup)
    article.article = meetup_article_text(meetup)
    article._commit()
    article.update_url_cache(article_old_url)


    res._redirect(url_for(action='show', id=meetup._id36))

  @validate(VUser(),
            meetup = VEditMeetup('id'))
  def GET_edit(self, meetup):
    return BoringPage(pagename = 'Edit Meetup', content = EditMeetup(meetup,
                                                                     title=meetup.title,
                                                                     description=meetup.description,
                                                                     location=meetup.location,
                                                                     latitude=meetup.latitude,
                                                                     longitude=meetup.longitude,
                                                                     timestamp=int(meetup.timestamp * 1000),
                                                                     tzoffset=meetup.tzoffset)).render()

  # Show a meetup.  Most of this code was coped from GET_comments in front.py
  @validate(meetup = VMeetup('id'),
            sort         = VMenu('controller', CommentSortMenu),
            num_comments = VMenu('controller', NumCommentsMenu))
  def GET_show(self, meetup, sort, num_comments):
    article = Link._byID(meetup.assoc_link)

    # figure out number to show based on the menu
    user_num = c.user.pref_num_comments or g.num_comments
    num = g.max_comments if num_comments == 'true' else user_num

    builder = CommentBuilder(article, CommentSortMenu.operator(sort), None, None)
    listing = NestedListing(builder, num=num, parent_name = article._fullname)
    displayPane = PaneStack()
    
    # insert reply box only for logged in user
    if c.user_is_loggedin:
      displayPane.append(CommentReplyBox())
      displayPane.append(CommentReplyBox(link_name = 
                                         article._fullname))

    # finally add the comment listing
    displayPane.append(listing.listing())

    sort_menu = CommentSortMenu(default = sort, type='dropdown2')
    nav_menus = [sort_menu,
                 NumCommentsMenu(article.num_comments,
                                 default=num_comments)]

    content = CommentListing(
      content = displayPane,
      num_comments = article.num_comments,
      nav_menus = nav_menus,
      )


    # Update last viewed time, and return the previous last viewed time.  Actually tracked on the article
    lastViewed = None
    if c.user_is_loggedin:
      clicked = article._getLastClickTime(c.user)
      lastViewed = clicked._date if clicked else None
      article._click(c.user)

    res = ShowMeetup(meetup = meetup, content = content, 
                     fullname=article._fullname,
                     lastViewed = lastViewed)

    return BoringPage(pagename = meetup.title, 
                      content = res,
                      body_class = 'meetup').render()



# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c, request, g
from pylons.i18n import _
from pylons.controllers.util import abort
from r2.lib import utils, captcha
from r2.lib.filters import unkeep_space, websafe, _force_utf8, _force_ascii
from r2.lib.db.operators import asc, desc
from r2.config import cache
from r2.lib.template_helpers import add_sr
from r2.lib.jsonresponse import json_respond

from r2.models import *

from r2.controllers.errors import errors, UserRequiredException

from copy import copy
from datetime import datetime, timedelta
import re

class Validator(object):
    default_param = None
    def __init__(self, param=None, default=None, post=True, get=True, url=True):
        if param:
            self.param = param
        else:
            self.param = self.default_param

        self.default = default
        self.post, self.get, self.url = post, get, url

    def __call__(self, url):
        a = []
        if self.param:
            for p in utils.tup(self.param):
                if self.post and request.post.get(p):
                    val = request.post[p]
                elif self.get and request.get.get(p):
                    val = request.get[p]
                elif self.url and url.get(p):
                    val = url[p]
                else:
                    val = self.default
                a.append(val)
        return self.run(*a)

def validate(*simple_vals, **param_vals):
    def val(fn):
        def newfn(self, *a, **env):
            try:
                for validator in simple_vals:
                    validator(env)
                
                kw = self.build_arg_list(fn, env)
                for var, validator in param_vals.iteritems():
                    kw[var] = validator(env)
                
                return fn(self, *a, **kw)

            except UserRequiredException:
                if request.method == "POST" and hasattr(self, "ajax_login_redirect"):
                    # ajax failure, so redirect accordingly
                    return  self.ajax_login_redirect("/")
                return self.intermediate_redirect('/login')
        return newfn
    return val


#### validators ####
class nop(Validator):
    def run(self, x):
        return x

class VLang(Validator):
    def run(self, lang):
        if lang:
            lang = str(lang.split('[')[1].strip(']'))
            if lang in g.all_languages:
                return lang
        #else
        return 'en'

class VRequired(Validator):
    def __init__(self, param, error, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self._error = error

    def error(self, e = None):
        if not e: e = self._error
        if e:
            c.errors.add(e)
        
    def run(self, item):
        if not item:
            self.error()
        else:
            return item

class ValueOrBlank(Validator):
    def run(self, value):
        """Returns the value as is if present, else an empty string"""
        return '' if value is None else value

class VLink(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect
    
    def run(self, link_id):
        if link_id:
            try:
                aid = int(link_id, 36)
                return Link._byID(aid, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VMeetup(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect

    def run(self, meetup_id36):
        if meetup_id36:
            try:
                meetup_id = int(meetup_id36, 36)
                return Meetup._byID(meetup_id, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VEditMeetup(VMeetup):
    def __init__(self, param, redirect = True, *a, **kw):
        VMeetup.__init__(self, param, redirect = redirect, *a, **kw)

    def run(self, param):
        meetup = VMeetup.run(self, param)
        if meetup and not (c.user_is_loggedin and 
                           meetup.can_edit(c.user, c.user_is_admin)):
            abort(403, "forbidden")
        return meetup

class VTagByName(Validator):
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, name):
        if name:
            cleaned = _force_ascii(name)
            if cleaned == name:
                try:
                    return Tag._by_name(cleaned)
                except:
                    pass                    
            abort(404, 'page not found')

class VTags(Validator):
    comma_sep = re.compile('[,\s]+', re.UNICODE)
    
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, tag_field):
        tags = []
        if tag_field:
            # Tags are comma delimited
            tags = [x for x in self.comma_sep.split(tag_field) if x==_force_ascii(x)]
        return tags

class VMessage(Validator):
    def run(self, message_id):
        if message_id:
            try:
                aid = int(message_id, 36)
                return Message._byID(aid, True)
            except (NotFound, ValueError):
                abort(404, 'page not found')


class VCommentID(Validator):
    def run(self, cid):
        if cid:
            try:
                cid = int(cid, 36)
                return Comment._byID(cid, True)
            except (NotFound, ValueError):
                pass                    

class VCount(Validator):
    def run(self, count):
        if count is None:
            count = 0
        return max(int(count), 0)


class VLimit(Validator):
    def run(self, limit):
        if limit is None:
            return c.user.pref_numsites 
        return min(max(int(limit), 1), 250)

class VCssMeasure(Validator):
    measure = re.compile(r"^\s*[\d\.]+\w{0,3}\s*$")
    def run(self, value):
        return value if value and self.measure.match(value) else ''

subreddit_rx = re.compile(r"^[\w]{3,20}$", re.UNICODE)

def chksrname(x):
    #notice the space before reddit.com
    if x in ('friends', 'all', ' reddit.com'):
        return False

    try:
        return str(x) if x and subreddit_rx.match(x) else None
    except UnicodeEncodeError:
        return None

class VLinkUrls(Validator):
    "A comma-separated list of link urls"
    splitter = re.compile('[ ,]+')
    id_re = re.compile('^/lw/([^/]+)/')
    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        res=[]
        for v in self.splitter.split(val):
            link_id = self.id_re.match(v)
            if link_id:
                l = VLink(None,False).run(link_id.group(1))
                if l:
                    res.append(l)
        return res

class VLinkFullnames(Validator):
    "A space- or comma-separated list of fullnames for Links"
    valid_re = re.compile(r'^(' + Link._type_prefix + str(Link._type_id) +
                          r'_[0-9a-z]+[ ,]?)+$')
    splitter = re.compile('[ ,]+')

    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        if val and self.valid_re.match(val):
            return self.splitter.split(val)
    
class VLength(Validator):
    def __init__(self, item, length = 10000,
                 empty_error = errors.BAD_COMMENT,
                 length_error = errors.COMMENT_TOO_LONG, **kw):
        Validator.__init__(self, item, **kw)
        self.length = length
        self.len_error = length_error
        self.emp_error = empty_error

    def run(self, title):
        if not title:
            if self.emp_error is not None:
                c.errors.add(self.emp_error)
        elif len(title) > self.length:
            c.errors.add(self.len_error)
        else:
            return title
        
class VTitle(VLength):
    only_whitespace = re.compile(r"^\s*$", re.UNICODE)
    
    def __init__(self, item, length = 200, **kw):
        VLength.__init__(self, item, length = length,
                         empty_error = errors.NO_TITLE,
                         length_error = errors.TITLE_TOO_LONG, **kw)

    def run(self, title):
        title = VLength.run(self, title)
        if title and self.only_whitespace.match(title):
            c.errors.add(errors.NO_TITLE)
        else:
            return title
    
class VComment(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, **kw)

        
class VMessage(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, 
                         empty_error = errors.NO_MSG_BODY, **kw)


class VSubredditName(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_SR_NAME, *a, **kw)

    def run(self, name):
        name = chksrname(name)
        if not name:
            return self.error()
        else:
            try:
                a = Subreddit._by_name(name)
                return self.error(errors.SUBREDDIT_EXISTS)
            except NotFound:
                return name

class VSubredditTitle(Validator):
    def run(self, title):
        if not title:
            c.errors.add(errors.NO_TITLE)
        elif len(title) > 100:
            c.errors.add(errors.TITLE_TOO_LONG)
        else:
            return title

class VSubredditDesc(Validator):
    def run(self, description):
        if description and len(description) > 500:
            c.errors.add(errors.DESC_TOO_LONG)
        return unkeep_space(description or '')

class VAccountByName(VRequired):
    def __init__(self, param, error = errors.USER_DOESNT_EXIST, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)
        
    def run(self, name):
        if name:
            try:
                return Account._by_name(name)
            except NotFound: pass                    
        return self.error()

class VByName(VRequired):
    def __init__(self, param, 
                 error = errors.NO_THING_ID, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)

    def run(self, fullname):
        if fullname:
            try:
                return Thing._by_fullname(fullname, False, data=True)
            except NotFound:
                pass                    
        return self.error()

class VByNameIfAuthor(VByName):
    def run(self, fullname):
        thing = VByName.run(self, fullname)
        if thing:
            if not thing._loaded: thing._load()
            if c.user_is_loggedin and thing.author_id == c.user._id:
                return thing
        return self.error(errors.NOT_AUTHOR)

class VCaptcha(Validator):
    default_param = ('iden', 'captcha')
    
    def run(self, iden, solution):
        if (not c.user_is_loggedin or c.user.needs_captcha()):
            if not captcha.valid_solution(iden, solution):
                c.errors.add(errors.BAD_CAPTCHA)

class VUser(Validator):
    def run(self, password = None):                    
        if not c.user_is_loggedin:
            raise UserRequiredException

        if (password is not None) and not valid_password(c.user, password):                    
            c.errors.add(errors.WRONG_PASSWORD)
            
class VModhash(Validator):
    default_param = 'uh'
    def run(self, uh):
        pass                    

class VVotehash(Validator):
    def run(self, vh, thing_name):
        return True

class VAdmin(Validator):
    def run(self):
        if not c.user_is_admin:
            abort(404, "page not found")

class VSponsor(Validator):
    def run(self):
        if not c.user_is_sponsor:
            abort(403, 'forbidden')

class VSrModerator(Validator):
    def run(self):
        if not (c.user_is_loggedin and c.site.is_moderator(c.user) 
                or c.user_is_admin):
            abort(403, "forbidden")

class VSrCanBan(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.can_ban(c.user):
                return True
        abort(403,'forbidden')

class VSrSpecial(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.is_special(c.user):
                return True
        abort(403,'forbidden')

class VSRSubmitPage(Validator):
    def run(self):
        if not (c.default_sr or c.user_is_loggedin and c.site.can_submit(c.user)):
            return False
        else:
            return True

class VCreateMeetup(Validator):
    def run(self):
        if (c.user_is_loggedin and c.user.safe_karma >= g.discussion_karma_to_post):
            return True
        abort(403, "forbidden")

class VSubmitParent(Validator):
    def run(self, fullname):
        if fullname:
            parent = Thing._by_fullname(fullname, False, data=True)
            if isinstance(parent, Message):
                return parent
            else:
                sr = parent.subreddit_slow
                if c.user_is_loggedin and sr.can_comment(c.user):
                    return parent
        #else
        abort(403, "forbidden")
        
class VSubmitLink(VLink):
    def __init__(self, param, redirect = True, *a, **kw):
        VLink.__init__(self, param, redirect = redirect, *a, **kw)
        
    def run(self, link_name):
        link = VLink.run(self, link_name)
        if link and not (c.user_is_loggedin and link.can_submit(c.user)):
            abort(403, "forbidden")
        return link

class VSubmitSR(Validator):
    def run(self, sr_name):
        try:
            sr = Subreddit._by_name(sr_name)
        except NotFound:
            c.errors.add(errors.SUBREDDIT_NOEXIST)
            sr = None

        if sr and not (c.user_is_loggedin and sr.can_submit(c.user)):
            c.errors.add(errors.SUBREDDIT_FORBIDDEN)
            sr = None

        return sr
        
pass_rx = re.compile(r".{3,20}")                    

def chkpass(x):                    
    return x if x and pass_rx.match(x) else None                    

class VPassword(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_PASSWORD, *a, **kw)
    def run(self, password, verify):                    
        if not chkpass(password):                    
            return self.error()
        elif verify != password:                    
            return self.error(errors.BAD_PASSWORD_MATCH)
        else:
            return password                    

user_rx = re.compile(r"^[\w-]{3,20}$", re.UNICODE)

def chkuser(x):
    try:
        return str(x) if user_rx.match(x) else None
    except TypeError:
        return None
    except UnicodeEncodeError:
        return None

def whyuserbad(x):
    if not x:
        return errors.BAD_USERNAME_CHARS
    if len(x)<3:
        return errors.BAD_USERNAME_SHORT
    if len(x)>20:
        return errors.BAD_USERNAME_LONG
    return errors.BAD_USERNAME_CHARS

class VUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_USERNAME, *a, **kw)
    def run(self, user_name):
        original_user_name = user_name;
        user_name = chkuser(user_name)
        if not user_name:
            return self.error(whyuserbad(original_user_name))
        else:
            try:
                a = Account._by_name(user_name, True)
                return self.error(errors.USERNAME_TAKEN)
            except NotFound:
                return user_name

class VLogin(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.WRONG_PASSWORD, *a, **kw)
        
    def run(self, user_name, password):                    
        user_name = chkuser(user_name)
        user = None
        if user_name:
            user = valid_login(user_name, password)                    
        if not user:
            return self.error()
        return user


class VSanitizedUrl(Validator):
    def run(self, url):
        return utils.sanitize_url(url)

class VUserWebsiteUrl(VSanitizedUrl):
    def run(self, url):
        val = VSanitizedUrl.run(self, url)
        if val is None:
            return ''
        else:
            return val

class VUrl(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_URL, *a, **kw)

    def run(self, url, sr = None):
        if sr is None and not isinstance(c.site, FakeSubreddit):
            sr = c.site
        elif sr:
            try:
                sr = Subreddit._by_name(sr)
            except NotFound:
                c.errors.add(errors.SUBREDDIT_NOEXIST)
                sr = None
        else:
            sr = None
        
        if not url:
            return self.error(errors.NO_URL)
        url = utils.sanitize_url(url)
        if url == 'self':
            return url
        elif url:
            try:
                l = Link._by_url(url, sr)
                self.error(errors.ALREADY_SUB)
                return utils.tup(l)
            except NotFound:
                return url
        return self.error(errors.BAD_URL)

class VExistingUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_USER, *a, **kw)

    def run(self, username):
        if username:
            try:
                name = _force_utf8(username)
                return Account._by_name(name)
            except (TypeError, UnicodeEncodeError, NotFound):
                return self.error(errors.USER_DOESNT_EXIST)
        self.error()

class VUserWithEmail(VExistingUname):
    def run(self, name):
        user = VExistingUname.run(self, name)
        if not user or not hasattr(user, 'email') or not user.email:
            return self.error(errors.NO_EMAIL_FOR_USER)
        return user
            

class VBoolean(Validator):
    def run(self, val):
        return val != "off" and bool(val)

class VLocation(VLength):
    def __init__(self, item, length = 100, **kw):
        VLength.__init__(self, item, length = length, 
                         length_error = errors.LOCATION_TOO_LONG,
                         empty_error = None, **kw)

    def run(self, val):
        val = VLength.run(self, val)
        if val == None:
            return ''
        else:
            return val

class VInt(Validator):
    def __init__(self, param, min=None, max=None, *a, **kw):
        self.min = min
        self.max = max
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            return

        try:
            val = int(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(errors.BAD_NUMBER)

class VFloat(Validator):
    def __init__(self, param, min=None, max=None, error=errors.BAD_NUMBER, *a, **kw):
        self.min = min
        self.max = max
        self.error = error
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            c.errors.add(self.error)
            return

        try:
            val = float(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(self.error)

class VCssName(Validator):
    """
    returns a name iff it consists of alphanumeric characters and
    possibly "-", and is below the length limit.
    """
    r_css_name = re.compile(r"^[a-zA-Z0-9\-]{1,100}$")
    def run(self, name):
        if name and self.r_css_name.match(name):
            return name
    
class VMenu(Validator):

    def __init__(self, param, menu_cls, remember = True, **kw):
        self.nav = menu_cls
        self.remember = remember
        param = (menu_cls.get_param, param)
        Validator.__init__(self, param, **kw)

    def run(self, sort, where):
        if self.remember:
            pref = "%s_%s" % (where, self.nav.get_param)
            user_prefs = copy(c.user.sort_options) if c.user else {}
            user_pref = user_prefs.get(pref)
    
            # check to see if a default param has been set
            if not sort:
                sort = user_pref
            
        # validate the sort
        if sort not in self.nav.options:
            sort = self.nav.default

        # commit the sort if changed
        if self.remember and c.user_is_loggedin and sort != user_pref:
            user_prefs[pref] = sort
            c.user.sort_options = user_prefs
            user = c.user
            utils.worker.do(lambda: user._commit())

        return sort
            

class VRatelimit(Validator):
    def __init__(self, rate_user = False, rate_ip = False,
                 prefix = 'rate_', *a, **kw):
        self.rate_user = rate_user
        self.rate_ip = rate_ip
        self.prefix = prefix
        Validator.__init__(self, *a, **kw)

    def run (self):
        to_check = []
        if self.rate_user and c.user_is_loggedin:
            to_check.append('user' + str(c.user._id36))
        if self.rate_ip:
            to_check.append('ip' + str(request.ip))

        r = cache.get_multi(to_check, self.prefix)
        if r:
            expire_time = max(r.values())
            time = utils.timeuntil(expire_time)
            c.errors.add(errors.RATELIMIT, {'time': time})

    @classmethod
    def ratelimit(self, rate_user = False, rate_ip = False, prefix = "rate_"):
        to_set = {}
        seconds = g.RATELIMIT*60

        if seconds <= 0:
            return

        expire_time = datetime.now(g.tz) + timedelta(seconds = seconds)
        if rate_user and c.user_is_loggedin:
            to_set['user' + str(c.user._id36)] = expire_time
        if rate_ip:
            to_set['ip' + str(request.ip)] = expire_time

        cache.set_multi(to_set, prefix, time = seconds)

class VCommentIDs(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        if not id_str:
            return None
        cids = [int(i, 36) for i in id_str.split(',')]
        comments = Comment._byID(cids, data=True, return_dict = False)
        return comments

class VFullNames(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        tids = id_str.split(',')
        return Thing._by_fullname(tids, data=True, return_dict = False)

class VSubreddits(Validator):
    #the subreddits are just in the post, this is for the my.reddit pref page
    def run(self):
        subreddits = Subreddit._by_fullname(request.post.keys())
        return subreddits.values()

class VCacheKey(Validator):
    def __init__(self, cache_prefix, param, *a, **kw):
        self.cache_prefix = cache_prefix
        Validator.__init__(self, param, *a, **kw)

    def run(self, key, name):
        if key:
            uid = cache.get(str(self.cache_prefix + "_" + key))
            try:
                a = Account._byID(uid, data = True)
            except NotFound:
                return None
            if name and a.name.lower() != name.lower():
                c.errors.add(errors.BAD_USERNAME)
            if a:
                return a
        c.errors.add(errors.EXPIRED)

class VOneOf(Validator):
    def __init__(self, param, options = (), *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.options = options

    def run(self, val):
        if self.options and val not in self.options:
            c.errors.add(errors.INVALID_OPTION)
            return self.default
        else:
            return val

class VReason(Validator):
    def run(self, reason):
        if not reason:
            return

        if reason.startswith('redirect_'):
            dest = reason[9:]
            if (not dest.startswith(c.site.path) and 
                not dest.startswith("http:")):
                dest = (c.site.path + dest).replace('//', '/')
            return ('redirect', dest)
        if reason.startswith('vote_'):
            fullname = reason[5:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('share_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('reply_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('sr_change_'):
            sr_list = reason[10:].split(',')
            fullnames = dict(i.split(':') for i in sr_list)
            srs = Subreddit._by_fullname(fullnames.keys(), data = True,
                                         return_dict = False)
            sr_onoff = dict((sr, fullnames[sr._fullname] == 1) for sr in srs)
            return ('subscribe', sr_onoff)


class ValidEmails(Validator):
    """Validates a list of email addresses passed in as a string and                    
    delineated by whitespace, ',' or ';'.  Also validates quantity of
    provided emails.  Returns a list of valid email addresses on
    success"""
    
    separator = re.compile(r'[^\s,;]+')
    email_re  = re.compile(r'.+@.+\..+')

    def __init__(self, param, num = 20, **kw):
        self.num = num
        Validator.__init__(self, param = param, **kw)
        
    def run(self, emails0):
        emails = set(self.separator.findall(emails0) if emails0 else [])
        failures = set(e for e in emails if not self.email_re.match(e))
        emails = emails - failures

        # make sure the number of addresses does not exceed the max
        if self.num > 0 and len(emails) + len(failures) > self.num:
            # special case for 1: there should be no delineators at all, so
            # send back original string to the user
            if self.num == 1:
                c.errors.add(errors.BAD_EMAILS,
                             {'emails': '"%s"' % emails0})
            # else report the number expected
            else:
                c.errors.add(errors.TOO_MANY_EMAILS,
                             {'num': self.num})
        # correct number, but invalid formatting
        elif failures:
            c.errors.add(errors.BAD_EMAILS,
                         {'emails': ', '.join(failures)})
        # no emails
        elif not emails:
            c.errors.add(errors.NO_EMAILS)
        else:
            # return single email if one is expected, list otherwise
            return list(emails)[0] if self.num == 1 else emails


class VCnameDomain(Validator):
    domain_re  = re.compile(r'^([\w]+\.)+[\w]+$')

    def run(self, domain):
        if (domain
            and (not self.domain_re.match(domain)
                 or domain.endswith('.reddit.com')
                 or len(domain) > 300)):
            c.errors.add(errors.BAD_CNAME)
        elif domain:
            try:
                return str(domain).lower()
            except UnicodeEncodeError:
                c.errors.add(errors.BAD_CNAME)




# NOTE: make sure *never* to have res check these are present
# otherwise, the response could contain reference to these errors...!
class ValidIP(Validator):
    def run(self):
        if is_banned_IP(request.ip):
            c.errors.add(errors.BANNED_IP)
        return request.ip

class ValidDomain(Validator):
    def run(self, url):
        if url and is_banned_domain(url):
            c.errors.add(errors.BANNED_DOMAIN)

# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c
from r2.lib.db.thing     import Thing, Relation, NotFound
from r2.lib.db.operators import lower
from r2.lib.db.userrel   import UserRel
from r2.lib.memoize      import memoize, clear_memo
from r2.lib.utils        import modhash, valid_hash, randstr                     
from r2.lib.strings      import strings, plurals

from pylons import g
from pylons.i18n import _
import time, hashlib
from copy import copy

class AccountExists(Exception): pass
class NotEnoughKarma(Exception): pass

class Account(Thing):
    _data_int_props = Thing._data_int_props + ('link_karma', 'comment_karma',
                                               'report_made', 'report_correct',
                                               'report_ignored', 'spammer',
                                               'reported')
    _int_prop_suffix = '_karma'
    _defaults = dict(pref_numsites = 10,
                     pref_frame = False,
                     pref_newwindow = False,
                     pref_public_votes = False,
                     pref_kibitz = False,
                     pref_hide_ups = False,
                     pref_hide_downs = True,
                     pref_min_link_score = -2,
                     pref_min_comment_score = -2,
                     pref_num_comments = g.num_comments,
                     pref_lang = 'en',
                     pref_content_langs = ('en',),
                     pref_over_18 = False,
                     pref_compress = False,
                     pref_organic = True,
                     pref_show_stylesheets = True,
                     pref_url = '',
                     pref_location = '',
                     reported = 0,
                     report_made = 0,
                     report_correct = 0,
                     report_ignored = 0,
                     spammer = 0,
                     sort_options = {},
                     has_subscribed = False,
                     pref_media = 'subreddit',
                     share = {},
                     )

    def karma(self, kind, sr = None):
        from subreddit import Subreddit
        suffix = '_' + kind + '_karma'
        
        #if no sr, return the sum
        if sr is None:
            total = 0
            for k, v in self._t.iteritems():
                if k.endswith(suffix):
                    if kind == 'link':
                        try:
                            karma_sr_name = k[0:k.rfind(suffix)]
                            karma_sr = Subreddit._by_name(karma_sr_name)
                            multiplier = karma_sr.post_karma_multiplier
                        except NotFound:
                            multiplier = 1
                    else:
                        multiplier = 1
                    total += v * multiplier
            return total
        else:
            try:
                return getattr(self, sr.name + suffix)
            except AttributeError:
                #if positive karma elsewhere, you get min_up_karma
                if self.karma(kind) > 0:
                    return g.MIN_UP_KARMA
                else:
                    return 0

    def incr_karma(self, kind, sr, amt):
        prop = '%s_%s_karma' % (sr.name, kind)
        if hasattr(self, prop):
            return self._incr(prop, amt)
        else:
            default_val = self.karma(kind, sr)
            setattr(self, prop, default_val + amt)
            self._commit()

    @property
    def link_karma(self):
        return self.karma('link')

    @property
    def comment_karma(self):
        return self.karma('comment')

    @property
    def safe_karma(self):
        karma = self.link_karma + self.comment_karma
        return max(karma, 0) if karma > -1000 else karma

    def all_karmas(self):
        """returns a list of tuples in the form (name, link_karma,
        comment_karma)"""
        link_suffix = '_link_karma'
        comment_suffix = '_comment_karma'
        karmas = []
        sr_names = set()
        for k in self._t.keys():
            if k.endswith(link_suffix):
                sr_names.add(k[:-len(link_suffix)])
            elif k.endswith(comment_suffix):
                sr_names.add(k[:-len(comment_suffix)])
        for sr_name in sr_names:
            karmas.append((sr_name,
                           self._t.get(sr_name + link_suffix, 0),
                           self._t.get(sr_name + comment_suffix, 0)))
        karmas.sort(key = lambda x: x[1] + x[2])

        karmas.insert(0, ('total',
                          self.karma('link'),
                          self.karma('comment')))

        karmas.append(('old',
                       self._t.get('link_karma', 0),
                       self._t.get('comment_karma', 0)))

        return karmas

    def vote_cache_key(self, kind):
        """kind is 'link' or 'comment'"""
        return 'account_%d_%s_downvotes' % (self._id, kind)

    def check_downvote(self, vote_kind):
        """Checks whether this account has enough karma to cast a downvote.

        vote_kind is 'link' or 'comment' depending on the type of vote that's
        being cast.

        This makes the assumption that the user can't cast a vote for something
        on the non-current subreddit.
        """
        from r2.models.vote import Vote, Link, Comment

        def get_cached_downvotes(content_cls):
            kind = content_cls.__name__.lower()
            downvotes = g.cache.get(self.vote_cache_key(kind))
            if downvotes is None:
                vote_cls = Vote.rel(Account, content_cls)
                downvotes = len(list(vote_cls._query(Vote.c._thing1_id == self._id,
                                                          Vote.c._name == str(-1))))
                g.cache.set(self.vote_cache_key(kind), downvotes)
            return downvotes

        link_downvote_karma = get_cached_downvotes(Link) * c.current_or_default_sr.post_karma_multiplier
        comment_downvote_karma = get_cached_downvotes(Comment)
        karma_spent = link_downvote_karma + comment_downvote_karma

        karma_balance = self.safe_karma * 4
        vote_cost = c.current_or_default_sr.post_karma_multiplier if vote_kind == 'link' else 1
        if karma_spent + vote_cost > karma_balance:
            points_needed = abs(karma_balance - karma_spent - vote_cost)
            msg = strings.not_enough_downvote_karma % (points_needed, plurals.N_points(points_needed))
            raise NotEnoughKarma(msg)

    def incr_downvote(self, delta, kind):
        """kind is link or comment"""
        try:
            g.cache.incr(self.vote_cache_key(kind), delta)
        except ValueError, e:
            print 'Account.incr_downvote failed with: %s' % e

    def make_cookie(self, timestr = None, admin = False):
        if not self._loaded:
            self._load()
        timestr = timestr or time.strftime('%Y-%m-%dT%H:%M:%S')
        id_time = str(self._id) + ',' + timestr
        to_hash = ','.join((id_time, self.password, g.SECRET))
        if admin:
            to_hash += 'admin'
        return id_time + ',' + hashlib.sha1(to_hash).hexdigest()

    def needs_captcha(self):
        return self.safe_karma < 1

    def modhash(self, rand=None, test=False):                    
        return modhash(self, rand = rand, test = test)                    
    
    def valid_hash(self, hash):
        return valid_hash(self, hash)                    

    @classmethod
    @memoize('account._by_name')
    def _by_name_cache(cls, name, allow_deleted = False):
        #relower name here, just in case
        deleted = (True, False) if allow_deleted else False
        q = cls._query(lower(Account.c.name) == name.lower(),
                       Account.c._spam == (True, False),
                       Account.c._deleted == deleted)

        q._limit = 1
        l = list(q)
        if l:
            return l[0]._id

    @classmethod
    def _by_name(cls, name, allow_deleted = False):
        #lower name here so there is only one cache
        uid = cls._by_name_cache(name.lower(), allow_deleted)
        if uid:
            return cls._byID(uid, True)
        else:
            raise NotFound, 'Account %s' % name

    @property
    def friends(self):
        return self.friend_ids()

    def delete(self):
        self._deleted = True
        self._commit()
        clear_memo('account._by_name', Account, self.name.lower(), False)
        
        #remove from friends lists
        q = Friend._query(Friend.c._thing2_id == self._id,
                          Friend.c._name == 'friend',
                          eager_load = True)
        for f in q:
            f._thing1.remove_friend(f._thing2)

    @property
    def subreddits(self):
        from subreddit import Subreddit
        return Subreddit.user_subreddits(self)

    @property
    def draft_sr_name(self):
      return self.name + "-drafts"

    def recent_share_emails(self):
        return self.share.get('recent', set([]))

    def add_share_emails(self, emails):
        if not emails:
            return
        
        if not isinstance(emails, set):
            emails = set(emails)

        self.share.setdefault('emails', {})
        share = self.share.copy()

        share_emails = share['emails']
        for e in emails:
            share_emails[e] = share_emails.get(e, 0) +1
            
        share['recent'] = emails

        self.share = share
        
            
            


class FakeAccount(Account):
    _nodb = True


def valid_cookie(cookie):
    try:
        uid, timestr, hash = cookie.split(',')
        uid = int(uid)
    except:
        return (False, False)

    try:
        account = Account._byID(uid, True)
        if account._deleted:
            return (False, False)
    except NotFound:
        return (False, False)

    if cookie == account.make_cookie(timestr, admin = False):
        return (account, False)
    elif cookie == account.make_cookie(timestr, admin = True):
        return (account, True)
    return (False, False)

def valid_login(name, password):
    try:
        a = Account._by_name(name)
    except NotFound:
        return False

    if not a._loaded: a._load()
    return valid_password(a, password)

def valid_password(a, password):
    try:
        if a.password == passhash(a.name, password, ''):
            #add a salt
            a.password = passhash(a.name, password, True)
            a._commit()
            return a
        else:
            salt = a.password[:3]
            if a.password == passhash(a.name, password, salt):
                return a
    except AttributeError:
        return False

def passhash(username, password, salt = ''):
    if salt is True:
        salt = randstr(3)
    tohash = '%s%s %s' % (salt, username, password)
    if isinstance(tohash, unicode):
        # Force tohash to be a byte string so it can be hashed
        tohash = tohash.encode('utf8')
    return salt + hashlib.sha1(tohash).hexdigest()

def change_password(user, newpassword):
    user.password = passhash(user.name, newpassword, True)
    user._commit()
    return True

#TODO reset the cache
def register(name, password, email=None):
    try:
        a = Account._by_name(name)
        raise AccountExists
    except NotFound:
        a = Account(name = name,
                    password = passhash(name, password, True))
        if email:
            a.email = email

        a._commit()
            
        # Clear memoization of both with and without deleted
        clear_memo('account._by_name', Account, name.lower(), True)
        clear_memo('account._by_name', Account, name.lower(), False)
        return a

class Friend(Relation(Account, Account)): pass
Account.__bases__ += (UserRel('friend', Friend),)

from reddit_base import RedditController
from r2.lib.pages import BoringPage, ShowMeetup, NewMeetup, EditMeetup, PaneStack, CommentListing, LinkInfoPage, CommentReplyBox, NotEnoughKarmaToPost
from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup                    
from errors import errors
from r2.lib.jsonresponse import Json
from routes.util import url_for
from r2.models import Meetup,Link,Subreddit,CommentBuilder
from r2.models.listing import NestedListing
from r2.lib.menus import CommentSortMenu,NumCommentsMenu
from r2.lib.filters import python_websafe
from mako.template import Template
from pylons.i18n import _
from pylons import c,g,request
import json

def meetup_article_text(meetup):
  t = Template(filename="r2/templates/showmeetup.html", output_encoding='utf-8', encoding_errors='replace')
  res = t.get_def("meetup_info").render_unicode(meetup=meetup)

  url = url_for(controller='meetups',action='show',id=meetup._id36)
  title = python_websafe(meetup.title)
  hdr = u"<h2>Discussion article for the meetup : <a href='%s'>%s</a></h2>"%(url,title)
  return hdr+res+hdr

def meetup_article_title(meetup):
  return "Meetup : %s"%meetup.title

class MeetupsController(RedditController):
  def response_func(self, **kw):
    return self.sendstring(json.dumps(kw))

  @validate(VUser(), 
            VCreateMeetup(),
            title = ValueOrBlank('title'),
            description = ValueOrBlank('description'),
            location = ValueOrBlank('location'),
            latitude = ValueOrBlank('latitude'),
            longitude = ValueOrBlank('longitude'),
            timestamp = ValueOrBlank('timestamp'),
            tzoffset = ValueOrBlank('tzoffset'))
  def GET_new(self, *a, **kw):
    return BoringPage(pagename = 'New Meetup', content = NewMeetup(*a, **kw)).render()

  @Json
  @validate(VUser(),
            VCreateMeetup(),
            ip = ValidIP(),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_create(self, res, title, description, location, latitude, longitude, timestamp, tzoffset, ip):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup = Meetup(
      author_id = c.user._id,

      title = title,
      description = description,

      location = location,
      latitude = latitude,
      longitude = longitude,

      timestamp = timestamp / 1000, # Value from form is in ms UTC
      tzoffset = tzoffset
    )

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    l = Link._submit(meetup_article_title(meetup), meetup_article_text(meetup),
                     c.user, Subreddit._by_name('discussion'),ip, [])

    l.meetup = meetup._id36
    l._commit()
    meetup.assoc_link = l._id
    meetup._commit()

    #update the queries
    if g.write_query_queue:
      queries.new_link(l)

    res._redirect(url_for(action='show', id=meetup._id36))

  @Json
  @validate(VUser(),
            meetup = VEditMeetup('id'),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_update(self, res, meetup, title, description, location, latitude, longitude, timestamp, tzoffset):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup.title = title
    meetup.description = description

    meetup.location = location
    meetup.latitude = latitude
    meetup.longitude = longitude

    meetup.timestamp = timestamp / 1000 # Value from form is in ms UTC
    meetup.tzoffset = tzoffset

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    # Update the linked article
    article = Link._byID(meetup.assoc_link)
    article._load()
    article_old_url = article.url
    article.title = meetup_article_title(meetup)
    article.article = meetup_article_text(meetup)
    article._commit()
    article.update_url_cache(article_old_url)


    res._redirect(url_for(action='show', id=meetup._id36))

  @validate(VUser(),
            meetup = VEditMeetup('id'))
  def GET_edit(self, meetup):
    return BoringPage(pagename = 'Edit Meetup', content = EditMeetup(meetup,
                                                                     title=meetup.title,
                                                                     description=meetup.description,
                                                                     location=meetup.location,
                                                                     latitude=meetup.latitude,
                                                                     longitude=meetup.longitude,
                                                                     timestamp=int(meetup.timestamp * 1000),
                                                                     tzoffset=meetup.tzoffset)).render()

  # Show a meetup.  Most of this code was coped from GET_comments in front.py
  @validate(meetup = VMeetup('id'),
            sort         = VMenu('controller', CommentSortMenu),
            num_comments = VMenu('controller', NumCommentsMenu))
  def GET_show(self, meetup, sort, num_comments):
    article = Link._byID(meetup.assoc_link)

    # figure out number to show based on the menu
    user_num = c.user.pref_num_comments or g.num_comments
    num = g.max_comments if num_comments == 'true' else user_num

    builder = CommentBuilder(article, CommentSortMenu.operator(sort), None, None)
    listing = NestedListing(builder, num=num, parent_name = article._fullname)
    displayPane = PaneStack()
    
    # insert reply box only for logged in user
    if c.user_is_loggedin:
      displayPane.append(CommentReplyBox())
      displayPane.append(CommentReplyBox(link_name = 
                                         article._fullname))

    # finally add the comment listing
    displayPane.append(listing.listing())

    sort_menu = CommentSortMenu(default = sort, type='dropdown2')
    nav_menus = [sort_menu,
                 NumCommentsMenu(article.num_comments,
                                 default=num_comments)]

    content = CommentListing(
      content = displayPane,
      num_comments = article.num_comments,
      nav_menus = nav_menus,
      )


    # Update last viewed time, and return the previous last viewed time.  Actually tracked on the article
    lastViewed = None
    if c.user_is_loggedin:
      clicked = article._getLastClickTime(c.user)
      lastViewed = clicked._date if clicked else None
      article._click(c.user)

    res = ShowMeetup(meetup = meetup, content = content, 
                     fullname=article._fullname,
                     lastViewed = lastViewed)

    return BoringPage(pagename = meetup.title, 
                      content = res,
                      body_class = 'meetup').render()



# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c, request, g
from pylons.i18n import _
from pylons.controllers.util import abort
from r2.lib import utils, captcha
from r2.lib.filters import unkeep_space, websafe, _force_utf8, _force_ascii
from r2.lib.db.operators import asc, desc
from r2.config import cache
from r2.lib.template_helpers import add_sr
from r2.lib.jsonresponse import json_respond

from r2.models import *

from r2.controllers.errors import errors, UserRequiredException

from copy import copy
from datetime import datetime, timedelta
import re

class Validator(object):
    default_param = None
    def __init__(self, param=None, default=None, post=True, get=True, url=True):
        if param:
            self.param = param
        else:
            self.param = self.default_param

        self.default = default
        self.post, self.get, self.url = post, get, url

    def __call__(self, url):
        a = []
        if self.param:
            for p in utils.tup(self.param):
                if self.post and request.post.get(p):
                    val = request.post[p]
                elif self.get and request.get.get(p):
                    val = request.get[p]
                elif self.url and url.get(p):
                    val = url[p]
                else:
                    val = self.default
                a.append(val)
        return self.run(*a)

def validate(*simple_vals, **param_vals):
    def val(fn):
        def newfn(self, *a, **env):
            try:
                for validator in simple_vals:
                    validator(env)
                
                kw = self.build_arg_list(fn, env)
                for var, validator in param_vals.iteritems():
                    kw[var] = validator(env)
                
                return fn(self, *a, **kw)

            except UserRequiredException:
                if request.method == "POST" and hasattr(self, "ajax_login_redirect"):
                    # ajax failure, so redirect accordingly
                    return  self.ajax_login_redirect("/")
                return self.intermediate_redirect('/login')
        return newfn
    return val


#### validators ####
class nop(Validator):
    def run(self, x):
        return x

class VLang(Validator):
    def run(self, lang):
        if lang:
            lang = str(lang.split('[')[1].strip(']'))
            if lang in g.all_languages:
                return lang
        #else
        return 'en'

class VRequired(Validator):
    def __init__(self, param, error, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self._error = error

    def error(self, e = None):
        if not e: e = self._error
        if e:
            c.errors.add(e)
        
    def run(self, item):
        if not item:
            self.error()
        else:
            return item

class ValueOrBlank(Validator):
    def run(self, value):
        """Returns the value as is if present, else an empty string"""
        return '' if value is None else value

class VLink(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect
    
    def run(self, link_id):
        if link_id:
            try:
                aid = int(link_id, 36)
                return Link._byID(aid, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VMeetup(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect

    def run(self, meetup_id36):
        if meetup_id36:
            try:
                meetup_id = int(meetup_id36, 36)
                return Meetup._byID(meetup_id, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VEditMeetup(VMeetup):
    def __init__(self, param, redirect = True, *a, **kw):
        VMeetup.__init__(self, param, redirect = redirect, *a, **kw)

    def run(self, param):
        meetup = VMeetup.run(self, param)
        if meetup and not (c.user_is_loggedin and 
                           meetup.can_edit(c.user, c.user_is_admin)):
            abort(403, "forbidden")
        return meetup

class VTagByName(Validator):
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, name):
        if name:
            cleaned = _force_ascii(name)
            if cleaned == name:
                try:
                    return Tag._by_name(cleaned)
                except:
                    pass                    
            abort(404, 'page not found')

class VTags(Validator):
    comma_sep = re.compile('[,\s]+', re.UNICODE)
    
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, tag_field):
        tags = []
        if tag_field:
            # Tags are comma delimited
            tags = [x for x in self.comma_sep.split(tag_field) if x==_force_ascii(x)]
        return tags

class VMessage(Validator):
    def run(self, message_id):
        if message_id:
            try:
                aid = int(message_id, 36)
                return Message._byID(aid, True)
            except (NotFound, ValueError):
                abort(404, 'page not found')


class VCommentID(Validator):
    def run(self, cid):
        if cid:
            try:
                cid = int(cid, 36)
                return Comment._byID(cid, True)
            except (NotFound, ValueError):
                pass                    

class VCount(Validator):
    def run(self, count):
        if count is None:
            count = 0
        return max(int(count), 0)


class VLimit(Validator):
    def run(self, limit):
        if limit is None:
            return c.user.pref_numsites 
        return min(max(int(limit), 1), 250)

class VCssMeasure(Validator):
    measure = re.compile(r"^\s*[\d\.]+\w{0,3}\s*$")
    def run(self, value):
        return value if value and self.measure.match(value) else ''

subreddit_rx = re.compile(r"^[\w]{3,20}$", re.UNICODE)

def chksrname(x):
    #notice the space before reddit.com
    if x in ('friends', 'all', ' reddit.com'):
        return False

    try:
        return str(x) if x and subreddit_rx.match(x) else None
    except UnicodeEncodeError:
        return None

class VLinkUrls(Validator):
    "A comma-separated list of link urls"
    splitter = re.compile('[ ,]+')
    id_re = re.compile('^/lw/([^/]+)/')
    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        res=[]
        for v in self.splitter.split(val):
            link_id = self.id_re.match(v)
            if link_id:
                l = VLink(None,False).run(link_id.group(1))
                if l:
                    res.append(l)
        return res

class VLinkFullnames(Validator):
    "A space- or comma-separated list of fullnames for Links"
    valid_re = re.compile(r'^(' + Link._type_prefix + str(Link._type_id) +
                          r'_[0-9a-z]+[ ,]?)+$')
    splitter = re.compile('[ ,]+')

    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        if val and self.valid_re.match(val):
            return self.splitter.split(val)
    
class VLength(Validator):
    def __init__(self, item, length = 10000,
                 empty_error = errors.BAD_COMMENT,
                 length_error = errors.COMMENT_TOO_LONG, **kw):
        Validator.__init__(self, item, **kw)
        self.length = length
        self.len_error = length_error
        self.emp_error = empty_error

    def run(self, title):
        if not title:
            if self.emp_error is not None:
                c.errors.add(self.emp_error)
        elif len(title) > self.length:
            c.errors.add(self.len_error)
        else:
            return title
        
class VTitle(VLength):
    only_whitespace = re.compile(r"^\s*$", re.UNICODE)
    
    def __init__(self, item, length = 200, **kw):
        VLength.__init__(self, item, length = length,
                         empty_error = errors.NO_TITLE,
                         length_error = errors.TITLE_TOO_LONG, **kw)

    def run(self, title):
        title = VLength.run(self, title)
        if title and self.only_whitespace.match(title):
            c.errors.add(errors.NO_TITLE)
        else:
            return title
    
class VComment(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, **kw)

        
class VMessage(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, 
                         empty_error = errors.NO_MSG_BODY, **kw)


class VSubredditName(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_SR_NAME, *a, **kw)

    def run(self, name):
        name = chksrname(name)
        if not name:
            return self.error()
        else:
            try:
                a = Subreddit._by_name(name)
                return self.error(errors.SUBREDDIT_EXISTS)
            except NotFound:
                return name

class VSubredditTitle(Validator):
    def run(self, title):
        if not title:
            c.errors.add(errors.NO_TITLE)
        elif len(title) > 100:
            c.errors.add(errors.TITLE_TOO_LONG)
        else:
            return title

class VSubredditDesc(Validator):
    def run(self, description):
        if description and len(description) > 500:
            c.errors.add(errors.DESC_TOO_LONG)
        return unkeep_space(description or '')

class VAccountByName(VRequired):
    def __init__(self, param, error = errors.USER_DOESNT_EXIST, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)
        
    def run(self, name):
        if name:
            try:
                return Account._by_name(name)
            except NotFound: pass                    
        return self.error()

class VByName(VRequired):
    def __init__(self, param, 
                 error = errors.NO_THING_ID, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)

    def run(self, fullname):
        if fullname:
            try:
                return Thing._by_fullname(fullname, False, data=True)
            except NotFound:
                pass                    
        return self.error()

class VByNameIfAuthor(VByName):
    def run(self, fullname):
        thing = VByName.run(self, fullname)
        if thing:
            if not thing._loaded: thing._load()
            if c.user_is_loggedin and thing.author_id == c.user._id:
                return thing
        return self.error(errors.NOT_AUTHOR)

class VCaptcha(Validator):
    default_param = ('iden', 'captcha')
    
    def run(self, iden, solution):
        if (not c.user_is_loggedin or c.user.needs_captcha()):
            if not captcha.valid_solution(iden, solution):
                c.errors.add(errors.BAD_CAPTCHA)

class VUser(Validator):
    def run(self, password = None):                    
        if not c.user_is_loggedin:
            raise UserRequiredException

        if (password is not None) and not valid_password(c.user, password):                    
            c.errors.add(errors.WRONG_PASSWORD)
            
class VModhash(Validator):
    default_param = 'uh'
    def run(self, uh):
        pass                    

class VVotehash(Validator):
    def run(self, vh, thing_name):
        return True

class VAdmin(Validator):
    def run(self):
        if not c.user_is_admin:
            abort(404, "page not found")

class VSponsor(Validator):
    def run(self):
        if not c.user_is_sponsor:
            abort(403, 'forbidden')

class VSrModerator(Validator):
    def run(self):
        if not (c.user_is_loggedin and c.site.is_moderator(c.user) 
                or c.user_is_admin):
            abort(403, "forbidden")

class VSrCanBan(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.can_ban(c.user):
                return True
        abort(403,'forbidden')

class VSrSpecial(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.is_special(c.user):
                return True
        abort(403,'forbidden')

class VSRSubmitPage(Validator):
    def run(self):
        if not (c.default_sr or c.user_is_loggedin and c.site.can_submit(c.user)):
            return False
        else:
            return True

class VCreateMeetup(Validator):
    def run(self):
        if (c.user_is_loggedin and c.user.safe_karma >= g.discussion_karma_to_post):
            return True
        abort(403, "forbidden")

class VSubmitParent(Validator):
    def run(self, fullname):
        if fullname:
            parent = Thing._by_fullname(fullname, False, data=True)
            if isinstance(parent, Message):
                return parent
            else:
                sr = parent.subreddit_slow
                if c.user_is_loggedin and sr.can_comment(c.user):
                    return parent
        #else
        abort(403, "forbidden")
        
class VSubmitLink(VLink):
    def __init__(self, param, redirect = True, *a, **kw):
        VLink.__init__(self, param, redirect = redirect, *a, **kw)
        
    def run(self, link_name):
        link = VLink.run(self, link_name)
        if link and not (c.user_is_loggedin and link.can_submit(c.user)):
            abort(403, "forbidden")
        return link

class VSubmitSR(Validator):
    def run(self, sr_name):
        try:
            sr = Subreddit._by_name(sr_name)
        except NotFound:
            c.errors.add(errors.SUBREDDIT_NOEXIST)
            sr = None

        if sr and not (c.user_is_loggedin and sr.can_submit(c.user)):
            c.errors.add(errors.SUBREDDIT_FORBIDDEN)
            sr = None

        return sr
        
pass_rx = re.compile(r".{3,20}")                    

def chkpass(x):                    
    return x if x and pass_rx.match(x) else None                    

class VPassword(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_PASSWORD, *a, **kw)
    def run(self, password, verify):                    
        if not chkpass(password):                    
            return self.error()
        elif verify != password:                    
            return self.error(errors.BAD_PASSWORD_MATCH)
        else:
            return password                    

user_rx = re.compile(r"^[\w-]{3,20}$", re.UNICODE)

def chkuser(x):
    try:
        return str(x) if user_rx.match(x) else None
    except TypeError:
        return None
    except UnicodeEncodeError:
        return None

def whyuserbad(x):
    if not x:
        return errors.BAD_USERNAME_CHARS
    if len(x)<3:
        return errors.BAD_USERNAME_SHORT
    if len(x)>20:
        return errors.BAD_USERNAME_LONG
    return errors.BAD_USERNAME_CHARS

class VUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_USERNAME, *a, **kw)
    def run(self, user_name):
        original_user_name = user_name;
        user_name = chkuser(user_name)
        if not user_name:
            return self.error(whyuserbad(original_user_name))
        else:
            try:
                a = Account._by_name(user_name, True)
                return self.error(errors.USERNAME_TAKEN)
            except NotFound:
                return user_name

class VLogin(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.WRONG_PASSWORD, *a, **kw)
        
    def run(self, user_name, password):                    
        user_name = chkuser(user_name)
        user = None
        if user_name:
            user = valid_login(user_name, password)                    
        if not user:
            return self.error()
        return user


class VSanitizedUrl(Validator):
    def run(self, url):
        return utils.sanitize_url(url)

class VUserWebsiteUrl(VSanitizedUrl):
    def run(self, url):
        val = VSanitizedUrl.run(self, url)
        if val is None:
            return ''
        else:
            return val

class VUrl(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_URL, *a, **kw)

    def run(self, url, sr = None):
        if sr is None and not isinstance(c.site, FakeSubreddit):
            sr = c.site
        elif sr:
            try:
                sr = Subreddit._by_name(sr)
            except NotFound:
                c.errors.add(errors.SUBREDDIT_NOEXIST)
                sr = None
        else:
            sr = None
        
        if not url:
            return self.error(errors.NO_URL)
        url = utils.sanitize_url(url)
        if url == 'self':
            return url
        elif url:
            try:
                l = Link._by_url(url, sr)
                self.error(errors.ALREADY_SUB)
                return utils.tup(l)
            except NotFound:
                return url
        return self.error(errors.BAD_URL)

class VExistingUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_USER, *a, **kw)

    def run(self, username):
        if username:
            try:
                name = _force_utf8(username)
                return Account._by_name(name)
            except (TypeError, UnicodeEncodeError, NotFound):
                return self.error(errors.USER_DOESNT_EXIST)
        self.error()

class VUserWithEmail(VExistingUname):
    def run(self, name):
        user = VExistingUname.run(self, name)
        if not user or not hasattr(user, 'email') or not user.email:
            return self.error(errors.NO_EMAIL_FOR_USER)
        return user
            

class VBoolean(Validator):
    def run(self, val):
        return val != "off" and bool(val)

class VLocation(VLength):
    def __init__(self, item, length = 100, **kw):
        VLength.__init__(self, item, length = length, 
                         length_error = errors.LOCATION_TOO_LONG,
                         empty_error = None, **kw)

    def run(self, val):
        val = VLength.run(self, val)
        if val == None:
            return ''
        else:
            return val

class VInt(Validator):
    def __init__(self, param, min=None, max=None, *a, **kw):
        self.min = min
        self.max = max
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            return

        try:
            val = int(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(errors.BAD_NUMBER)

class VFloat(Validator):
    def __init__(self, param, min=None, max=None, error=errors.BAD_NUMBER, *a, **kw):
        self.min = min
        self.max = max
        self.error = error
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            c.errors.add(self.error)
            return

        try:
            val = float(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(self.error)

class VCssName(Validator):
    """
    returns a name iff it consists of alphanumeric characters and
    possibly "-", and is below the length limit.
    """
    r_css_name = re.compile(r"^[a-zA-Z0-9\-]{1,100}$")
    def run(self, name):
        if name and self.r_css_name.match(name):
            return name
    
class VMenu(Validator):

    def __init__(self, param, menu_cls, remember = True, **kw):
        self.nav = menu_cls
        self.remember = remember
        param = (menu_cls.get_param, param)
        Validator.__init__(self, param, **kw)

    def run(self, sort, where):
        if self.remember:
            pref = "%s_%s" % (where, self.nav.get_param)
            user_prefs = copy(c.user.sort_options) if c.user else {}
            user_pref = user_prefs.get(pref)
    
            # check to see if a default param has been set
            if not sort:
                sort = user_pref
            
        # validate the sort
        if sort not in self.nav.options:
            sort = self.nav.default

        # commit the sort if changed
        if self.remember and c.user_is_loggedin and sort != user_pref:
            user_prefs[pref] = sort
            c.user.sort_options = user_prefs
            user = c.user
            utils.worker.do(lambda: user._commit())

        return sort
            

class VRatelimit(Validator):
    def __init__(self, rate_user = False, rate_ip = False,
                 prefix = 'rate_', *a, **kw):
        self.rate_user = rate_user
        self.rate_ip = rate_ip
        self.prefix = prefix
        Validator.__init__(self, *a, **kw)

    def run (self):
        to_check = []
        if self.rate_user and c.user_is_loggedin:
            to_check.append('user' + str(c.user._id36))
        if self.rate_ip:
            to_check.append('ip' + str(request.ip))

        r = cache.get_multi(to_check, self.prefix)
        if r:
            expire_time = max(r.values())
            time = utils.timeuntil(expire_time)
            c.errors.add(errors.RATELIMIT, {'time': time})

    @classmethod
    def ratelimit(self, rate_user = False, rate_ip = False, prefix = "rate_"):
        to_set = {}
        seconds = g.RATELIMIT*60

        if seconds <= 0:
            return

        expire_time = datetime.now(g.tz) + timedelta(seconds = seconds)
        if rate_user and c.user_is_loggedin:
            to_set['user' + str(c.user._id36)] = expire_time
        if rate_ip:
            to_set['ip' + str(request.ip)] = expire_time

        cache.set_multi(to_set, prefix, time = seconds)

class VCommentIDs(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        if not id_str:
            return None
        cids = [int(i, 36) for i in id_str.split(',')]
        comments = Comment._byID(cids, data=True, return_dict = False)
        return comments

class VFullNames(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        tids = id_str.split(',')
        return Thing._by_fullname(tids, data=True, return_dict = False)

class VSubreddits(Validator):
    #the subreddits are just in the post, this is for the my.reddit pref page
    def run(self):
        subreddits = Subreddit._by_fullname(request.post.keys())
        return subreddits.values()

class VCacheKey(Validator):
    def __init__(self, cache_prefix, param, *a, **kw):
        self.cache_prefix = cache_prefix
        Validator.__init__(self, param, *a, **kw)

    def run(self, key, name):
        if key:
            uid = cache.get(str(self.cache_prefix + "_" + key))
            try:
                a = Account._byID(uid, data = True)
            except NotFound:
                return None
            if name and a.name.lower() != name.lower():
                c.errors.add(errors.BAD_USERNAME)
            if a:
                return a
        c.errors.add(errors.EXPIRED)

class VOneOf(Validator):
    def __init__(self, param, options = (), *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.options = options

    def run(self, val):
        if self.options and val not in self.options:
            c.errors.add(errors.INVALID_OPTION)
            return self.default
        else:
            return val

class VReason(Validator):
    def run(self, reason):
        if not reason:
            return

        if reason.startswith('redirect_'):
            dest = reason[9:]
            if (not dest.startswith(c.site.path) and 
                not dest.startswith("http:")):
                dest = (c.site.path + dest).replace('//', '/')
            return ('redirect', dest)
        if reason.startswith('vote_'):
            fullname = reason[5:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('share_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('reply_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('sr_change_'):
            sr_list = reason[10:].split(',')
            fullnames = dict(i.split(':') for i in sr_list)
            srs = Subreddit._by_fullname(fullnames.keys(), data = True,
                                         return_dict = False)
            sr_onoff = dict((sr, fullnames[sr._fullname] == 1) for sr in srs)
            return ('subscribe', sr_onoff)


class ValidEmails(Validator):
    """Validates a list of email addresses passed in as a string and                    
    delineated by whitespace, ',' or ';'.  Also validates quantity of
    provided emails.  Returns a list of valid email addresses on
    success"""
    
    separator = re.compile(r'[^\s,;]+')
    email_re  = re.compile(r'.+@.+\..+')

    def __init__(self, param, num = 20, **kw):
        self.num = num
        Validator.__init__(self, param = param, **kw)
        
    def run(self, emails0):
        emails = set(self.separator.findall(emails0) if emails0 else [])
        failures = set(e for e in emails if not self.email_re.match(e))
        emails = emails - failures

        # make sure the number of addresses does not exceed the max
        if self.num > 0 and len(emails) + len(failures) > self.num:
            # special case for 1: there should be no delineators at all, so
            # send back original string to the user
            if self.num == 1:
                c.errors.add(errors.BAD_EMAILS,
                             {'emails': '"%s"' % emails0})
            # else report the number expected
            else:
                c.errors.add(errors.TOO_MANY_EMAILS,
                             {'num': self.num})
        # correct number, but invalid formatting
        elif failures:
            c.errors.add(errors.BAD_EMAILS,
                         {'emails': ', '.join(failures)})
        # no emails
        elif not emails:
            c.errors.add(errors.NO_EMAILS)
        else:
            # return single email if one is expected, list otherwise
            return list(emails)[0] if self.num == 1 else emails


class VCnameDomain(Validator):
    domain_re  = re.compile(r'^([\w]+\.)+[\w]+$')

    def run(self, domain):
        if (domain
            and (not self.domain_re.match(domain)
                 or domain.endswith('.reddit.com')
                 or len(domain) > 300)):
            c.errors.add(errors.BAD_CNAME)
        elif domain:
            try:
                return str(domain).lower()
            except UnicodeEncodeError:
                c.errors.add(errors.BAD_CNAME)




# NOTE: make sure *never* to have res check these are present
# otherwise, the response could contain reference to these errors...!
class ValidIP(Validator):
    def run(self):
        if is_banned_IP(request.ip):
            c.errors.add(errors.BANNED_IP)
        return request.ip

class ValidDomain(Validator):
    def run(self, url):
        if url and is_banned_domain(url):
            c.errors.add(errors.BANNED_DOMAIN)

# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c
from r2.lib.db.thing     import Thing, Relation, NotFound
from r2.lib.db.operators import lower
from r2.lib.db.userrel   import UserRel
from r2.lib.memoize      import memoize, clear_memo
from r2.lib.utils        import modhash, valid_hash, randstr                     
from r2.lib.strings      import strings, plurals

from pylons import g
from pylons.i18n import _
import time, hashlib
from copy import copy

class AccountExists(Exception): pass
class NotEnoughKarma(Exception): pass

class Account(Thing):
    _data_int_props = Thing._data_int_props + ('link_karma', 'comment_karma',
                                               'report_made', 'report_correct',
                                               'report_ignored', 'spammer',
                                               'reported')
    _int_prop_suffix = '_karma'
    _defaults = dict(pref_numsites = 10,
                     pref_frame = False,
                     pref_newwindow = False,
                     pref_public_votes = False,
                     pref_kibitz = False,
                     pref_hide_ups = False,
                     pref_hide_downs = True,
                     pref_min_link_score = -2,
                     pref_min_comment_score = -2,
                     pref_num_comments = g.num_comments,
                     pref_lang = 'en',
                     pref_content_langs = ('en',),
                     pref_over_18 = False,
                     pref_compress = False,
                     pref_organic = True,
                     pref_show_stylesheets = True,
                     pref_url = '',
                     pref_location = '',
                     reported = 0,
                     report_made = 0,
                     report_correct = 0,
                     report_ignored = 0,
                     spammer = 0,
                     sort_options = {},
                     has_subscribed = False,
                     pref_media = 'subreddit',
                     share = {},
                     )

    def karma(self, kind, sr = None):
        from subreddit import Subreddit
        suffix = '_' + kind + '_karma'
        
        #if no sr, return the sum
        if sr is None:
            total = 0
            for k, v in self._t.iteritems():
                if k.endswith(suffix):
                    if kind == 'link':
                        try:
                            karma_sr_name = k[0:k.rfind(suffix)]
                            karma_sr = Subreddit._by_name(karma_sr_name)
                            multiplier = karma_sr.post_karma_multiplier
                        except NotFound:
                            multiplier = 1
                    else:
                        multiplier = 1
                    total += v * multiplier
            return total
        else:
            try:
                return getattr(self, sr.name + suffix)
            except AttributeError:
                #if positive karma elsewhere, you get min_up_karma
                if self.karma(kind) > 0:
                    return g.MIN_UP_KARMA
                else:
                    return 0

    def incr_karma(self, kind, sr, amt):
        prop = '%s_%s_karma' % (sr.name, kind)
        if hasattr(self, prop):
            return self._incr(prop, amt)
        else:
            default_val = self.karma(kind, sr)
            setattr(self, prop, default_val + amt)
            self._commit()

    @property
    def link_karma(self):
        return self.karma('link')

    @property
    def comment_karma(self):
        return self.karma('comment')

    @property
    def safe_karma(self):
        karma = self.link_karma + self.comment_karma
        return max(karma, 0) if karma > -1000 else karma

    def all_karmas(self):
        """returns a list of tuples in the form (name, link_karma,
        comment_karma)"""
        link_suffix = '_link_karma'
        comment_suffix = '_comment_karma'
        karmas = []
        sr_names = set()
        for k in self._t.keys():
            if k.endswith(link_suffix):
                sr_names.add(k[:-len(link_suffix)])
            elif k.endswith(comment_suffix):
                sr_names.add(k[:-len(comment_suffix)])
        for sr_name in sr_names:
            karmas.append((sr_name,
                           self._t.get(sr_name + link_suffix, 0),
                           self._t.get(sr_name + comment_suffix, 0)))
        karmas.sort(key = lambda x: x[1] + x[2])

        karmas.insert(0, ('total',
                          self.karma('link'),
                          self.karma('comment')))

        karmas.append(('old',
                       self._t.get('link_karma', 0),
                       self._t.get('comment_karma', 0)))

        return karmas

    def vote_cache_key(self, kind):
        """kind is 'link' or 'comment'"""
        return 'account_%d_%s_downvotes' % (self._id, kind)

    def check_downvote(self, vote_kind):
        """Checks whether this account has enough karma to cast a downvote.

        vote_kind is 'link' or 'comment' depending on the type of vote that's
        being cast.

        This makes the assumption that the user can't cast a vote for something
        on the non-current subreddit.
        """
        from r2.models.vote import Vote, Link, Comment

        def get_cached_downvotes(content_cls):
            kind = content_cls.__name__.lower()
            downvotes = g.cache.get(self.vote_cache_key(kind))
            if downvotes is None:
                vote_cls = Vote.rel(Account, content_cls)
                downvotes = len(list(vote_cls._query(Vote.c._thing1_id == self._id,
                                                          Vote.c._name == str(-1))))
                g.cache.set(self.vote_cache_key(kind), downvotes)
            return downvotes

        link_downvote_karma = get_cached_downvotes(Link) * c.current_or_default_sr.post_karma_multiplier
        comment_downvote_karma = get_cached_downvotes(Comment)
        karma_spent = link_downvote_karma + comment_downvote_karma

        karma_balance = self.safe_karma * 4
        vote_cost = c.current_or_default_sr.post_karma_multiplier if vote_kind == 'link' else 1
        if karma_spent + vote_cost > karma_balance:
            points_needed = abs(karma_balance - karma_spent - vote_cost)
            msg = strings.not_enough_downvote_karma % (points_needed, plurals.N_points(points_needed))
            raise NotEnoughKarma(msg)

    def incr_downvote(self, delta, kind):
        """kind is link or comment"""
        try:
            g.cache.incr(self.vote_cache_key(kind), delta)
        except ValueError, e:
            print 'Account.incr_downvote failed with: %s' % e

    def make_cookie(self, timestr = None, admin = False):
        if not self._loaded:
            self._load()
        timestr = timestr or time.strftime('%Y-%m-%dT%H:%M:%S')
        id_time = str(self._id) + ',' + timestr
        to_hash = ','.join((id_time, self.password, g.SECRET))
        if admin:
            to_hash += 'admin'
        return id_time + ',' + hashlib.sha1(to_hash).hexdigest()

    def needs_captcha(self):
        return self.safe_karma < 1

    def modhash(self, rand=None, test=False):                    
        return modhash(self, rand = rand, test = test)                    
    
    def valid_hash(self, hash):
        return valid_hash(self, hash)                    

    @classmethod
    @memoize('account._by_name')
    def _by_name_cache(cls, name, allow_deleted = False):
        #relower name here, just in case
        deleted = (True, False) if allow_deleted else False
        q = cls._query(lower(Account.c.name) == name.lower(),
                       Account.c._spam == (True, False),
                       Account.c._deleted == deleted)

        q._limit = 1
        l = list(q)
        if l:
            return l[0]._id

    @classmethod
    def _by_name(cls, name, allow_deleted = False):
        #lower name here so there is only one cache
        uid = cls._by_name_cache(name.lower(), allow_deleted)
        if uid:
            return cls._byID(uid, True)
        else:
            raise NotFound, 'Account %s' % name

    @property
    def friends(self):
        return self.friend_ids()

    def delete(self):
        self._deleted = True
        self._commit()
        clear_memo('account._by_name', Account, self.name.lower(), False)
        
        #remove from friends lists
        q = Friend._query(Friend.c._thing2_id == self._id,
                          Friend.c._name == 'friend',
                          eager_load = True)
        for f in q:
            f._thing1.remove_friend(f._thing2)

    @property
    def subreddits(self):
        from subreddit import Subreddit
        return Subreddit.user_subreddits(self)

    @property
    def draft_sr_name(self):
      return self.name + "-drafts"

    def recent_share_emails(self):
        return self.share.get('recent', set([]))

    def add_share_emails(self, emails):
        if not emails:
            return
        
        if not isinstance(emails, set):
            emails = set(emails)

        self.share.setdefault('emails', {})
        share = self.share.copy()

        share_emails = share['emails']
        for e in emails:
            share_emails[e] = share_emails.get(e, 0) +1
            
        share['recent'] = emails

        self.share = share
        
            
            


class FakeAccount(Account):
    _nodb = True


def valid_cookie(cookie):
    try:
        uid, timestr, hash = cookie.split(',')
        uid = int(uid)
    except:
        return (False, False)

    try:
        account = Account._byID(uid, True)
        if account._deleted:
            return (False, False)
    except NotFound:
        return (False, False)

    if cookie == account.make_cookie(timestr, admin = False):
        return (account, False)
    elif cookie == account.make_cookie(timestr, admin = True):
        return (account, True)
    return (False, False)

def valid_login(name, password):
    try:
        a = Account._by_name(name)
    except NotFound:
        return False

    if not a._loaded: a._load()
    return valid_password(a, password)

def valid_password(a, password):
    try:
        if a.password == passhash(a.name, password, ''):
            #add a salt
            a.password = passhash(a.name, password, True)
            a._commit()
            return a
        else:
            salt = a.password[:3]
            if a.password == passhash(a.name, password, salt):
                return a
    except AttributeError:
        return False

def passhash(username, password, salt = ''):
    if salt is True:
        salt = randstr(3)
    tohash = '%s%s %s' % (salt, username, password)
    if isinstance(tohash, unicode):
        # Force tohash to be a byte string so it can be hashed
        tohash = tohash.encode('utf8')
    return salt + hashlib.sha1(tohash).hexdigest()

def change_password(user, newpassword):
    user.password = passhash(user.name, newpassword, True)
    user._commit()
    return True

#TODO reset the cache
def register(name, password, email=None):
    try:
        a = Account._by_name(name)
        raise AccountExists
    except NotFound:
        a = Account(name = name,
                    password = passhash(name, password, True))
        if email:
            a.email = email

        a._commit()
            
        # Clear memoization of both with and without deleted
        clear_memo('account._by_name', Account, name.lower(), True)
        clear_memo('account._by_name', Account, name.lower(), False)
        return a

class Friend(Relation(Account, Account)): pass
Account.__bases__ += (UserRel('friend', Friend),)

from reddit_base import RedditController
from r2.lib.pages import BoringPage, ShowMeetup, NewMeetup, EditMeetup, PaneStack, CommentListing, LinkInfoPage, CommentReplyBox, NotEnoughKarmaToPost
from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup                    
from errors import errors
from r2.lib.jsonresponse import Json
from routes.util import url_for
from r2.models import Meetup,Link,Subreddit,CommentBuilder
from r2.models.listing import NestedListing
from r2.lib.menus import CommentSortMenu,NumCommentsMenu
from r2.lib.filters import python_websafe
from mako.template import Template
from pylons.i18n import _
from pylons import c,g,request
import json

def meetup_article_text(meetup):
  t = Template(filename="r2/templates/showmeetup.html", output_encoding='utf-8', encoding_errors='replace')
  res = t.get_def("meetup_info").render_unicode(meetup=meetup)

  url = url_for(controller='meetups',action='show',id=meetup._id36)
  title = python_websafe(meetup.title)
  hdr = u"<h2>Discussion article for the meetup : <a href='%s'>%s</a></h2>"%(url,title)
  return hdr+res+hdr

def meetup_article_title(meetup):
  return "Meetup : %s"%meetup.title

class MeetupsController(RedditController):
  def response_func(self, **kw):
    return self.sendstring(json.dumps(kw))

  @validate(VUser(), 
            VCreateMeetup(),
            title = ValueOrBlank('title'),
            description = ValueOrBlank('description'),
            location = ValueOrBlank('location'),
            latitude = ValueOrBlank('latitude'),
            longitude = ValueOrBlank('longitude'),
            timestamp = ValueOrBlank('timestamp'),
            tzoffset = ValueOrBlank('tzoffset'))
  def GET_new(self, *a, **kw):
    return BoringPage(pagename = 'New Meetup', content = NewMeetup(*a, **kw)).render()

  @Json
  @validate(VUser(),
            VCreateMeetup(),
            ip = ValidIP(),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_create(self, res, title, description, location, latitude, longitude, timestamp, tzoffset, ip):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup = Meetup(
      author_id = c.user._id,

      title = title,
      description = description,

      location = location,
      latitude = latitude,
      longitude = longitude,

      timestamp = timestamp / 1000, # Value from form is in ms UTC
      tzoffset = tzoffset
    )

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    l = Link._submit(meetup_article_title(meetup), meetup_article_text(meetup),
                     c.user, Subreddit._by_name('discussion'),ip, [])

    l.meetup = meetup._id36
    l._commit()
    meetup.assoc_link = l._id
    meetup._commit()

    #update the queries
    if g.write_query_queue:
      queries.new_link(l)

    res._redirect(url_for(action='show', id=meetup._id36))

  @Json
  @validate(VUser(),
            meetup = VEditMeetup('id'),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_update(self, res, meetup, title, description, location, latitude, longitude, timestamp, tzoffset):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup.title = title
    meetup.description = description

    meetup.location = location
    meetup.latitude = latitude
    meetup.longitude = longitude

    meetup.timestamp = timestamp / 1000 # Value from form is in ms UTC
    meetup.tzoffset = tzoffset

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    # Update the linked article
    article = Link._byID(meetup.assoc_link)
    article._load()
    article_old_url = article.url
    article.title = meetup_article_title(meetup)
    article.article = meetup_article_text(meetup)
    article._commit()
    article.update_url_cache(article_old_url)


    res._redirect(url_for(action='show', id=meetup._id36))

  @validate(VUser(),
            meetup = VEditMeetup('id'))
  def GET_edit(self, meetup):
    return BoringPage(pagename = 'Edit Meetup', content = EditMeetup(meetup,
                                                                     title=meetup.title,
                                                                     description=meetup.description,
                                                                     location=meetup.location,
                                                                     latitude=meetup.latitude,
                                                                     longitude=meetup.longitude,
                                                                     timestamp=int(meetup.timestamp * 1000),
                                                                     tzoffset=meetup.tzoffset)).render()

  # Show a meetup.  Most of this code was coped from GET_comments in front.py
  @validate(meetup = VMeetup('id'),
            sort         = VMenu('controller', CommentSortMenu),
            num_comments = VMenu('controller', NumCommentsMenu))
  def GET_show(self, meetup, sort, num_comments):
    article = Link._byID(meetup.assoc_link)

    # figure out number to show based on the menu
    user_num = c.user.pref_num_comments or g.num_comments
    num = g.max_comments if num_comments == 'true' else user_num

    builder = CommentBuilder(article, CommentSortMenu.operator(sort), None, None)
    listing = NestedListing(builder, num=num, parent_name = article._fullname)
    displayPane = PaneStack()
    
    # insert reply box only for logged in user
    if c.user_is_loggedin:
      displayPane.append(CommentReplyBox())
      displayPane.append(CommentReplyBox(link_name = 
                                         article._fullname))

    # finally add the comment listing
    displayPane.append(listing.listing())

    sort_menu = CommentSortMenu(default = sort, type='dropdown2')
    nav_menus = [sort_menu,
                 NumCommentsMenu(article.num_comments,
                                 default=num_comments)]

    content = CommentListing(
      content = displayPane,
      num_comments = article.num_comments,
      nav_menus = nav_menus,
      )


    # Update last viewed time, and return the previous last viewed time.  Actually tracked on the article
    lastViewed = None
    if c.user_is_loggedin:
      clicked = article._getLastClickTime(c.user)
      lastViewed = clicked._date if clicked else None
      article._click(c.user)

    res = ShowMeetup(meetup = meetup, content = content, 
                     fullname=article._fullname,
                     lastViewed = lastViewed)

    return BoringPage(pagename = meetup.title, 
                      content = res,
                      body_class = 'meetup').render()



# coding: utf-8

import os, base64, pickle, logging, struct, socket, re, datetime
import urllib, urlparse
import gettext
from hashlib import md5, sha512, sha1
import settings
import mako
from mako.exceptions import RichTraceback
import tornado

from mako.template import Template
from mako.lookup import TemplateLookup
mako.runtime.UNDEFINED = ''

from mako.exceptions import TemplateLookupException

from tornado.web import RequestHandler

from app.account.models import User
from app.session.models import Session
from app.system.models import LyTrace

from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound

from settings import JOB_ACTION, JOB_TARGET, LY_TARGET


template_dir = os.path.join(
    os.path.dirname(__file__), 'template' )


from ytime import htime, ftime
from ytool.hstring import b2s

class LyRequestHandler(RequestHandler):

    lookup = TemplateLookup([ template_dir ],
                            input_encoding="utf-8")

    def render(self, template_name, **kwargs):
        """ Redefine the render """

        # TODO: if url have ajax arg, use XXX.ajax for template
        ajax = self.get_argument('ajax', False)                    
        if ajax:                    
            x, y = template_name.split('.')                    
            #x += '_ajax'
            template_name = '.'.join([x,'ajax'])                    

        t = self.lookup.get_template(template_name)

        args = dict(
            handler=self,
            request=self.request,
            current_user=self.current_user,
            locale=self.locale,
            _=self.locale.translate,
            static_url=self.static_url,
            xsrf_form_html=self.xsrf_form_html,
            reverse_url=self.application.reverse_url,

            LANGUAGES=self.settings['LANGUAGES'],
            STATIC_URL=self.settings['STATIC_URL'],
            THEME_URL=self.settings['THEME_URL'],
            THEME=self.settings['THEME'],
            theme_url=self.theme_url,

            #method
            htime = htime,
            ftime = ftime,
            has_permission = self.has_permission,
            AJAX = ajax,                    
            show_error = show_error,
            b2s = b2s,
        )

        args.update(kwargs)

        # We can define keyword in views with initialize()
        if hasattr(self, 'view_kwargs'):
            args.update(self.view_kwargs)

        # TODO: more readable bug track
        # http://docs.makotemplates.org/en/latest/usage.html#handling-exceptions
        try:
            html = t.render(**args)
        except:
            traceback = RichTraceback()
            html = u'''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="/static/css/mako.css" />
    <title>LuoYun Mako Template System Trac Info</title>
  </head>
  <body>
    <h1>LuoYun Mako Template System Trac Info</h1>
    <pre>'''
            for (filename, lineno, function, line) in traceback.traceback:
                html += "File %s, line %s, in %s" % (filename, lineno, function)
                html += "%s\n" % line
            html += "%s: %s" % (str(traceback.error.__class__.__name__), traceback.error)
            html += "</pre></body></html>"
        self.finish(html)


    def get_current_user(self):

        try:
            session = self.db2.query(Session).filter_by(
                session_key = self.get_secure_cookie('session_key')).one()
        except MultipleResultsFound:
            logging.error( 'session: MultipleResultsFound, %s' %
                           self.get_secure_cookie('session_key') )
        except NoResultFound:
            return None

        # Does session expired ?
        if session.expire_date < datetime.datetime.now():
            return None

        sk = self.settings["session_secret"]
        encoded_data = base64.decodestring(session.session_data)
        pickled, tamper_check = encoded_data[:-32], encoded_data[-32:]
        if md5(pickled + sk).hexdigest() != tamper_check:
            # TODO
            print "User tampered with session cookie."
            return None
        try:
            session_dict = pickle.loads(pickled)
        except:
            session_dict = {}

        user = self.db2.query(User).get(
            session_dict.get('user_id', 0) )

        if user:
            if user.islocked: return None

            user.last_active = datetime.datetime.now()
            user.last_entry = self.request.uri
            #self.db2.commit()

        return user



    def get_user_locale(self):
        user_locale = self.get_cookie("user_locale")

        if ( not user_locale and
             self.current_user and
             self.current_user.profile ):
            user_locale = self.current_user.profile.locale

        if user_locale:
            # TODO: app and template have different i18n
            gettext.translation(
                'app', settings.I18N_PATH,
                languages=[user_locale]).install(True)
            return tornado.locale.get(user_locale)
        else:
            # Use the Accept-Language header
            return None

    def has_permission(self, perm, user=None):

        if not user:
            user = self.current_user

        if not user:
            return False

        for p in self.current_user.permissions:
            if p.codename == perm or p.codename == 'admin':
                return True

        for g in self.current_user.groups:
            for p in g.permissions:
                if p.codename == perm or p.codename == 'admin':
                    return True

        return False


    @property
    def db(self):
        return self.application.db

    @property
    def db2(self):
        return self.application.db2

    def _job_notify(self, id):
        ''' Notify the new job signal to control server '''

        rqhead = struct.pack('iii', settings.PKT_TYPE_WEB_NEW_JOB_REQUEST, 4, id)

        sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        sk.connect( ( self.application.settings['control_server_ip'],
                      self.application.settings['control_server_port'] ) )

        sk.sendall(rqhead)
        sk.close()


    def get_page_url(self, p, path=None):

        ''' Generate page url from given p (cur_page)

        For Pagination.
        '''

        if not path:
            path = self.request.uri

        the_p = 'p=%s' % p

        if path.count('p='):
            return re.sub('p=[0-9]+', the_p, path)
        elif path.count('?'):
            return path + '&%s' % the_p
        else:
            return path + '?%s' % the_p


    def get_no_permission_url(self):
        self.require_setting("no_permission_url", "@has_permission")
        return self.application.settings["no_permission_url"]

    def get_no_resource_url(self):
        self.require_setting("no_resource_url")
        return self.application.settings["no_resource_url"]

    def theme_url(self, f):
        return self.static_url('themes/%s/%s' % (self.settings['THEME'], f))

    def get_int(self, value, default=0):
        try:
            return int(value)
        except:
            return default

    def get_argument_int(self, key, default=0):
        value = self.get_argument(key, default)
        try:
            return int(value)
        except:
            return default

    def lytrace(self, ttype, tid, do, isok=True, result=None):
        ip = self.request.remote_ip
        agent = self.request.headers.get('User-Agent')
        visit = self.request.uri

        T = LyTrace(self.current_user, ip, agent, visit)

        T.target_type = ttype,
        T.target_id = tid,
        T.do = do
        T.isok = isok
        T.result = result

        self.db2.add(T)
        self.db2.commit()

        return T

    def lytrace_ippool(self, ippool, I, release=False):
        if release:
            do = _('release ip %s from instance %s(%s)') % (
                ippool.ip, I.id, I.name)
        else:
            do = _('get ip %s for instance %s(%s)') % (
                ippool.ip, I.id, I.name)
        T = self.lytrace( ttype = LY_TARGET['IP'], tid = ippool.id,
                          do = do )
        return T


    # params is a dict: { 'key': value }
    def urlupdate(self, params):

        new = []

        if '?' in self.request.uri:
            path, oldparams = self.request.uri.split('?')
            update_keys = params.keys()

            for k, v in urlparse.parse_qsl( oldparams ):
                if k in update_keys:
                    v = params[k]
                    del params[k]
                new.append( (k, v) )
        else:
            path = self.request.uri

        if params:
            for k in params.keys():
                new.append( (k, params[k]) )

        return '?'.join([path, urllib.urlencode( new )])



def show_error( E ):

    ''' return the error msg in list E '''

    return '<ul class="yerror">%s</ul>' % ''.join(['<li>%s</li>' % str(e) for e in E]) if E else ''



import functools, urlparse, urllib
def has_permission(codename):
    """ Needed permission 'codename'. """
    def foo(method):
        @functools.wraps(method)
        def wrapper(self, *args, **kwargs):
            if not self.current_user:
                if self.request.method in ("GET", "HEAD"):
                    url = self.get_login_url()
                    if "?" not in url:
                        if urlparse.urlsplit(url).scheme:
                            # if login url is absolute, make next absolute too
                            next_url = self.request.full_url()
                        else:
                            next_url = self.request.uri
                            url += "?" + urllib.urlencode(dict(next=next_url))
                    self.redirect(url)
                    return
                raise HTTPError(403)

            # User is authenticated
            for p in self.current_user.permissions:
                if p.codename == codename or p.codename == 'admin':
                    return method(self, *args, **kwargs)

            for g in self.current_user.groups:
                for p in g.permissions:
                    if p.codename == codename or p.codename == 'admin':
                        return method(self, *args, **kwargs)

            #raise HTTPError(403, 'Need permission "%s"', codename)
            url = self.get_no_permission_url()
            url += "?codenames=%s" % codename
            return self.redirect( url )

        return wrapper
    return foo



class LyNotFoundHandler(LyRequestHandler):
    def prepare(self):
        try:
            self.set_status(404)
            self.render("/404.html")
        except TemplateLookupException, e:
            self.send_error(500)




# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c, request, g
from pylons.i18n import _
from pylons.controllers.util import abort
from r2.lib import utils, captcha
from r2.lib.filters import unkeep_space, websafe, _force_utf8, _force_ascii
from r2.lib.db.operators import asc, desc
from r2.config import cache
from r2.lib.template_helpers import add_sr
from r2.lib.jsonresponse import json_respond

from r2.models import *

from r2.controllers.errors import errors, UserRequiredException

from copy import copy
from datetime import datetime, timedelta
import re

class Validator(object):
    default_param = None
    def __init__(self, param=None, default=None, post=True, get=True, url=True):
        if param:
            self.param = param
        else:
            self.param = self.default_param

        self.default = default
        self.post, self.get, self.url = post, get, url

    def __call__(self, url):
        a = []
        if self.param:
            for p in utils.tup(self.param):
                if self.post and request.post.get(p):
                    val = request.post[p]
                elif self.get and request.get.get(p):
                    val = request.get[p]
                elif self.url and url.get(p):
                    val = url[p]
                else:
                    val = self.default
                a.append(val)
        return self.run(*a)

def validate(*simple_vals, **param_vals):
    def val(fn):
        def newfn(self, *a, **env):
            try:
                for validator in simple_vals:
                    validator(env)
                
                kw = self.build_arg_list(fn, env)
                for var, validator in param_vals.iteritems():
                    kw[var] = validator(env)
                
                return fn(self, *a, **kw)

            except UserRequiredException:
                if request.method == "POST" and hasattr(self, "ajax_login_redirect"):
                    # ajax failure, so redirect accordingly
                    return  self.ajax_login_redirect("/")
                return self.intermediate_redirect('/login')
        return newfn
    return val


#### validators ####
class nop(Validator):
    def run(self, x):
        return x

class VLang(Validator):
    def run(self, lang):
        if lang:
            lang = str(lang.split('[')[1].strip(']'))
            if lang in g.all_languages:
                return lang
        #else
        return 'en'

class VRequired(Validator):
    def __init__(self, param, error, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self._error = error

    def error(self, e = None):
        if not e: e = self._error
        if e:
            c.errors.add(e)
        
    def run(self, item):
        if not item:
            self.error()
        else:
            return item

class ValueOrBlank(Validator):
    def run(self, value):
        """Returns the value as is if present, else an empty string"""
        return '' if value is None else value

class VLink(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect
    
    def run(self, link_id):
        if link_id:
            try:
                aid = int(link_id, 36)
                return Link._byID(aid, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VMeetup(Validator):
    def __init__(self, param, redirect = True, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.redirect = redirect

    def run(self, meetup_id36):
        if meetup_id36:
            try:
                meetup_id = int(meetup_id36, 36)
                return Meetup._byID(meetup_id, True)
            except (NotFound, ValueError):
                if self.redirect:
                    abort(404, 'page not found')
                else:
                    return None

class VEditMeetup(VMeetup):
    def __init__(self, param, redirect = True, *a, **kw):
        VMeetup.__init__(self, param, redirect = redirect, *a, **kw)

    def run(self, param):
        meetup = VMeetup.run(self, param)
        if meetup and not (c.user_is_loggedin and 
                           meetup.can_edit(c.user, c.user_is_admin)):
            abort(403, "forbidden")
        return meetup

class VTagByName(Validator):
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, name):
        if name:
            cleaned = _force_ascii(name)
            if cleaned == name:
                try:
                    return Tag._by_name(cleaned)
                except:
                    pass                    
            abort(404, 'page not found')

class VTags(Validator):
    comma_sep = re.compile('[,\s]+', re.UNICODE)
    
    def __init__(self, param, *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        
    def run(self, tag_field):
        tags = []
        if tag_field:
            # Tags are comma delimited
            tags = [x for x in self.comma_sep.split(tag_field) if x==_force_ascii(x)]
        return tags

class VMessage(Validator):
    def run(self, message_id):
        if message_id:
            try:
                aid = int(message_id, 36)
                return Message._byID(aid, True)
            except (NotFound, ValueError):
                abort(404, 'page not found')


class VCommentID(Validator):
    def run(self, cid):
        if cid:
            try:
                cid = int(cid, 36)
                return Comment._byID(cid, True)
            except (NotFound, ValueError):
                pass                    

class VCount(Validator):
    def run(self, count):
        if count is None:
            count = 0
        return max(int(count), 0)


class VLimit(Validator):
    def run(self, limit):
        if limit is None:
            return c.user.pref_numsites 
        return min(max(int(limit), 1), 250)

class VCssMeasure(Validator):
    measure = re.compile(r"^\s*[\d\.]+\w{0,3}\s*$")
    def run(self, value):
        return value if value and self.measure.match(value) else ''

subreddit_rx = re.compile(r"^[\w]{3,20}$", re.UNICODE)

def chksrname(x):
    #notice the space before reddit.com
    if x in ('friends', 'all', ' reddit.com'):
        return False

    try:
        return str(x) if x and subreddit_rx.match(x) else None
    except UnicodeEncodeError:
        return None

class VLinkUrls(Validator):
    "A comma-separated list of link urls"
    splitter = re.compile('[ ,]+')
    id_re = re.compile('^/lw/([^/]+)/')
    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        res=[]
        for v in self.splitter.split(val):
            link_id = self.id_re.match(v)
            if link_id:
                l = VLink(None,False).run(link_id.group(1))
                if l:
                    res.append(l)
        return res

class VLinkFullnames(Validator):
    "A space- or comma-separated list of fullnames for Links"
    valid_re = re.compile(r'^(' + Link._type_prefix + str(Link._type_id) +
                          r'_[0-9a-z]+[ ,]?)+$')
    splitter = re.compile('[ ,]+')

    def __init__(self, item, *a, **kw):
        self.item = item
        Validator.__init__(self, item, *a, **kw)
    
    def run(self, val):
        if val and self.valid_re.match(val):
            return self.splitter.split(val)
    
class VLength(Validator):
    def __init__(self, item, length = 10000,
                 empty_error = errors.BAD_COMMENT,
                 length_error = errors.COMMENT_TOO_LONG, **kw):
        Validator.__init__(self, item, **kw)
        self.length = length
        self.len_error = length_error
        self.emp_error = empty_error

    def run(self, title):
        if not title:
            if self.emp_error is not None:
                c.errors.add(self.emp_error)
        elif len(title) > self.length:
            c.errors.add(self.len_error)
        else:
            return title
        
class VTitle(VLength):
    only_whitespace = re.compile(r"^\s*$", re.UNICODE)
    
    def __init__(self, item, length = 200, **kw):
        VLength.__init__(self, item, length = length,
                         empty_error = errors.NO_TITLE,
                         length_error = errors.TITLE_TOO_LONG, **kw)

    def run(self, title):
        title = VLength.run(self, title)
        if title and self.only_whitespace.match(title):
            c.errors.add(errors.NO_TITLE)
        else:
            return title
    
class VComment(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, **kw)

        
class VMessage(VLength):
    def __init__(self, item, length = 10000, **kw):
        VLength.__init__(self, item, length = length, 
                         empty_error = errors.NO_MSG_BODY, **kw)


class VSubredditName(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_SR_NAME, *a, **kw)

    def run(self, name):
        name = chksrname(name)
        if not name:
            return self.error()
        else:
            try:
                a = Subreddit._by_name(name)
                return self.error(errors.SUBREDDIT_EXISTS)
            except NotFound:
                return name

class VSubredditTitle(Validator):
    def run(self, title):
        if not title:
            c.errors.add(errors.NO_TITLE)
        elif len(title) > 100:
            c.errors.add(errors.TITLE_TOO_LONG)
        else:
            return title

class VSubredditDesc(Validator):
    def run(self, description):
        if description and len(description) > 500:
            c.errors.add(errors.DESC_TOO_LONG)
        return unkeep_space(description or '')

class VAccountByName(VRequired):
    def __init__(self, param, error = errors.USER_DOESNT_EXIST, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)
        
    def run(self, name):
        if name:
            try:
                return Account._by_name(name)
            except NotFound: pass                    
        return self.error()

class VByName(VRequired):
    def __init__(self, param, 
                 error = errors.NO_THING_ID, *a, **kw):
        VRequired.__init__(self, param, error, *a, **kw)

    def run(self, fullname):
        if fullname:
            try:
                return Thing._by_fullname(fullname, False, data=True)
            except NotFound:
                pass                    
        return self.error()

class VByNameIfAuthor(VByName):
    def run(self, fullname):
        thing = VByName.run(self, fullname)
        if thing:
            if not thing._loaded: thing._load()
            if c.user_is_loggedin and thing.author_id == c.user._id:
                return thing
        return self.error(errors.NOT_AUTHOR)

class VCaptcha(Validator):
    default_param = ('iden', 'captcha')
    
    def run(self, iden, solution):
        if (not c.user_is_loggedin or c.user.needs_captcha()):
            if not captcha.valid_solution(iden, solution):
                c.errors.add(errors.BAD_CAPTCHA)

class VUser(Validator):
    def run(self, password = None):                    
        if not c.user_is_loggedin:
            raise UserRequiredException

        if (password is not None) and not valid_password(c.user, password):                    
            c.errors.add(errors.WRONG_PASSWORD)
            
class VModhash(Validator):
    default_param = 'uh'
    def run(self, uh):
        pass                    

class VVotehash(Validator):
    def run(self, vh, thing_name):
        return True

class VAdmin(Validator):
    def run(self):
        if not c.user_is_admin:
            abort(404, "page not found")

class VSponsor(Validator):
    def run(self):
        if not c.user_is_sponsor:
            abort(403, 'forbidden')

class VSrModerator(Validator):
    def run(self):
        if not (c.user_is_loggedin and c.site.is_moderator(c.user) 
                or c.user_is_admin):
            abort(403, "forbidden")

class VSrCanBan(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.can_ban(c.user):
                return True
        abort(403,'forbidden')

class VSrSpecial(Validator):
    def run(self, thing_name):
        if c.user_is_admin:
            return True
        elif c.user_is_loggedin:
            item = Thing._by_fullname(thing_name,data=True)
            # will throw a legitimate 500 if this isn't a link or
            # comment, because this should only be used on links and
            # comments
            subreddit = item.subreddit_slow
            if subreddit.is_special(c.user):
                return True
        abort(403,'forbidden')

class VSRSubmitPage(Validator):
    def run(self):
        if not (c.default_sr or c.user_is_loggedin and c.site.can_submit(c.user)):
            return False
        else:
            return True

class VCreateMeetup(Validator):
    def run(self):
        if (c.user_is_loggedin and c.user.safe_karma >= g.discussion_karma_to_post):
            return True
        abort(403, "forbidden")

class VSubmitParent(Validator):
    def run(self, fullname):
        if fullname:
            parent = Thing._by_fullname(fullname, False, data=True)
            if isinstance(parent, Message):
                return parent
            else:
                sr = parent.subreddit_slow
                if c.user_is_loggedin and sr.can_comment(c.user):
                    return parent
        #else
        abort(403, "forbidden")
        
class VSubmitLink(VLink):
    def __init__(self, param, redirect = True, *a, **kw):
        VLink.__init__(self, param, redirect = redirect, *a, **kw)
        
    def run(self, link_name):
        link = VLink.run(self, link_name)
        if link and not (c.user_is_loggedin and link.can_submit(c.user)):
            abort(403, "forbidden")
        return link

class VSubmitSR(Validator):
    def run(self, sr_name):
        try:
            sr = Subreddit._by_name(sr_name)
        except NotFound:
            c.errors.add(errors.SUBREDDIT_NOEXIST)
            sr = None

        if sr and not (c.user_is_loggedin and sr.can_submit(c.user)):
            c.errors.add(errors.SUBREDDIT_FORBIDDEN)
            sr = None

        return sr
        
pass_rx = re.compile(r".{3,20}")                    

def chkpass(x):                    
    return x if x and pass_rx.match(x) else None                    

class VPassword(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_PASSWORD, *a, **kw)
    def run(self, password, verify):                    
        if not chkpass(password):                    
            return self.error()
        elif verify != password:                    
            return self.error(errors.BAD_PASSWORD_MATCH)
        else:
            return password                    

user_rx = re.compile(r"^[\w-]{3,20}$", re.UNICODE)

def chkuser(x):
    try:
        return str(x) if user_rx.match(x) else None
    except TypeError:
        return None
    except UnicodeEncodeError:
        return None

def whyuserbad(x):
    if not x:
        return errors.BAD_USERNAME_CHARS
    if len(x)<3:
        return errors.BAD_USERNAME_SHORT
    if len(x)>20:
        return errors.BAD_USERNAME_LONG
    return errors.BAD_USERNAME_CHARS

class VUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.BAD_USERNAME, *a, **kw)
    def run(self, user_name):
        original_user_name = user_name;
        user_name = chkuser(user_name)
        if not user_name:
            return self.error(whyuserbad(original_user_name))
        else:
            try:
                a = Account._by_name(user_name, True)
                return self.error(errors.USERNAME_TAKEN)
            except NotFound:
                return user_name

class VLogin(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.WRONG_PASSWORD, *a, **kw)
        
    def run(self, user_name, password):                    
        user_name = chkuser(user_name)
        user = None
        if user_name:
            user = valid_login(user_name, password)                    
        if not user:
            return self.error()
        return user


class VSanitizedUrl(Validator):
    def run(self, url):
        return utils.sanitize_url(url)

class VUserWebsiteUrl(VSanitizedUrl):
    def run(self, url):
        val = VSanitizedUrl.run(self, url)
        if val is None:
            return ''
        else:
            return val

class VUrl(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_URL, *a, **kw)

    def run(self, url, sr = None):
        if sr is None and not isinstance(c.site, FakeSubreddit):
            sr = c.site
        elif sr:
            try:
                sr = Subreddit._by_name(sr)
            except NotFound:
                c.errors.add(errors.SUBREDDIT_NOEXIST)
                sr = None
        else:
            sr = None
        
        if not url:
            return self.error(errors.NO_URL)
        url = utils.sanitize_url(url)
        if url == 'self':
            return url
        elif url:
            try:
                l = Link._by_url(url, sr)
                self.error(errors.ALREADY_SUB)
                return utils.tup(l)
            except NotFound:
                return url
        return self.error(errors.BAD_URL)

class VExistingUname(VRequired):
    def __init__(self, item, *a, **kw):
        VRequired.__init__(self, item, errors.NO_USER, *a, **kw)

    def run(self, username):
        if username:
            try:
                name = _force_utf8(username)
                return Account._by_name(name)
            except (TypeError, UnicodeEncodeError, NotFound):
                return self.error(errors.USER_DOESNT_EXIST)
        self.error()

class VUserWithEmail(VExistingUname):
    def run(self, name):
        user = VExistingUname.run(self, name)
        if not user or not hasattr(user, 'email') or not user.email:
            return self.error(errors.NO_EMAIL_FOR_USER)
        return user
            

class VBoolean(Validator):
    def run(self, val):
        return val != "off" and bool(val)

class VLocation(VLength):
    def __init__(self, item, length = 100, **kw):
        VLength.__init__(self, item, length = length, 
                         length_error = errors.LOCATION_TOO_LONG,
                         empty_error = None, **kw)

    def run(self, val):
        val = VLength.run(self, val)
        if val == None:
            return ''
        else:
            return val

class VInt(Validator):
    def __init__(self, param, min=None, max=None, *a, **kw):
        self.min = min
        self.max = max
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            return

        try:
            val = int(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(errors.BAD_NUMBER)

class VFloat(Validator):
    def __init__(self, param, min=None, max=None, error=errors.BAD_NUMBER, *a, **kw):
        self.min = min
        self.max = max
        self.error = error
        Validator.__init__(self, param, *a, **kw)

    def run(self, val):
        if not val:
            c.errors.add(self.error)
            return

        try:
            val = float(val)
            if self.min is not None and val < self.min:
                val = self.min
            elif self.max is not None and val > self.max:
                val = self.max
            return val
        except ValueError:
            c.errors.add(self.error)

class VCssName(Validator):
    """
    returns a name iff it consists of alphanumeric characters and
    possibly "-", and is below the length limit.
    """
    r_css_name = re.compile(r"^[a-zA-Z0-9\-]{1,100}$")
    def run(self, name):
        if name and self.r_css_name.match(name):
            return name
    
class VMenu(Validator):

    def __init__(self, param, menu_cls, remember = True, **kw):
        self.nav = menu_cls
        self.remember = remember
        param = (menu_cls.get_param, param)
        Validator.__init__(self, param, **kw)

    def run(self, sort, where):
        if self.remember:
            pref = "%s_%s" % (where, self.nav.get_param)
            user_prefs = copy(c.user.sort_options) if c.user else {}
            user_pref = user_prefs.get(pref)
    
            # check to see if a default param has been set
            if not sort:
                sort = user_pref
            
        # validate the sort
        if sort not in self.nav.options:
            sort = self.nav.default

        # commit the sort if changed
        if self.remember and c.user_is_loggedin and sort != user_pref:
            user_prefs[pref] = sort
            c.user.sort_options = user_prefs
            user = c.user
            utils.worker.do(lambda: user._commit())

        return sort
            

class VRatelimit(Validator):
    def __init__(self, rate_user = False, rate_ip = False,
                 prefix = 'rate_', *a, **kw):
        self.rate_user = rate_user
        self.rate_ip = rate_ip
        self.prefix = prefix
        Validator.__init__(self, *a, **kw)

    def run (self):
        to_check = []
        if self.rate_user and c.user_is_loggedin:
            to_check.append('user' + str(c.user._id36))
        if self.rate_ip:
            to_check.append('ip' + str(request.ip))

        r = cache.get_multi(to_check, self.prefix)
        if r:
            expire_time = max(r.values())
            time = utils.timeuntil(expire_time)
            c.errors.add(errors.RATELIMIT, {'time': time})

    @classmethod
    def ratelimit(self, rate_user = False, rate_ip = False, prefix = "rate_"):
        to_set = {}
        seconds = g.RATELIMIT*60

        if seconds <= 0:
            return

        expire_time = datetime.now(g.tz) + timedelta(seconds = seconds)
        if rate_user and c.user_is_loggedin:
            to_set['user' + str(c.user._id36)] = expire_time
        if rate_ip:
            to_set['ip' + str(request.ip)] = expire_time

        cache.set_multi(to_set, prefix, time = seconds)

class VCommentIDs(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        if not id_str:
            return None
        cids = [int(i, 36) for i in id_str.split(',')]
        comments = Comment._byID(cids, data=True, return_dict = False)
        return comments

class VFullNames(Validator):
    #id_str is a comma separated list of id36's
    def run(self, id_str):
        tids = id_str.split(',')
        return Thing._by_fullname(tids, data=True, return_dict = False)

class VSubreddits(Validator):
    #the subreddits are just in the post, this is for the my.reddit pref page
    def run(self):
        subreddits = Subreddit._by_fullname(request.post.keys())
        return subreddits.values()

class VCacheKey(Validator):
    def __init__(self, cache_prefix, param, *a, **kw):
        self.cache_prefix = cache_prefix
        Validator.__init__(self, param, *a, **kw)

    def run(self, key, name):
        if key:
            uid = cache.get(str(self.cache_prefix + "_" + key))
            try:
                a = Account._byID(uid, data = True)
            except NotFound:
                return None
            if name and a.name.lower() != name.lower():
                c.errors.add(errors.BAD_USERNAME)
            if a:
                return a
        c.errors.add(errors.EXPIRED)

class VOneOf(Validator):
    def __init__(self, param, options = (), *a, **kw):
        Validator.__init__(self, param, *a, **kw)
        self.options = options

    def run(self, val):
        if self.options and val not in self.options:
            c.errors.add(errors.INVALID_OPTION)
            return self.default
        else:
            return val

class VReason(Validator):
    def run(self, reason):
        if not reason:
            return

        if reason.startswith('redirect_'):
            dest = reason[9:]
            if (not dest.startswith(c.site.path) and 
                not dest.startswith("http:")):
                dest = (c.site.path + dest).replace('//', '/')
            return ('redirect', dest)
        if reason.startswith('vote_'):
            fullname = reason[5:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('share_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('reply_'):
            fullname = reason[6:]
            t = Thing._by_fullname(fullname, data=True)
            return ('redirect', t.make_permalink_slow())
        elif reason.startswith('sr_change_'):
            sr_list = reason[10:].split(',')
            fullnames = dict(i.split(':') for i in sr_list)
            srs = Subreddit._by_fullname(fullnames.keys(), data = True,
                                         return_dict = False)
            sr_onoff = dict((sr, fullnames[sr._fullname] == 1) for sr in srs)
            return ('subscribe', sr_onoff)


class ValidEmails(Validator):
    """Validates a list of email addresses passed in as a string and                    
    delineated by whitespace, ',' or ';'.  Also validates quantity of
    provided emails.  Returns a list of valid email addresses on
    success"""
    
    separator = re.compile(r'[^\s,;]+')
    email_re  = re.compile(r'.+@.+\..+')

    def __init__(self, param, num = 20, **kw):
        self.num = num
        Validator.__init__(self, param = param, **kw)
        
    def run(self, emails0):
        emails = set(self.separator.findall(emails0) if emails0 else [])
        failures = set(e for e in emails if not self.email_re.match(e))
        emails = emails - failures

        # make sure the number of addresses does not exceed the max
        if self.num > 0 and len(emails) + len(failures) > self.num:
            # special case for 1: there should be no delineators at all, so
            # send back original string to the user
            if self.num == 1:
                c.errors.add(errors.BAD_EMAILS,
                             {'emails': '"%s"' % emails0})
            # else report the number expected
            else:
                c.errors.add(errors.TOO_MANY_EMAILS,
                             {'num': self.num})
        # correct number, but invalid formatting
        elif failures:
            c.errors.add(errors.BAD_EMAILS,
                         {'emails': ', '.join(failures)})
        # no emails
        elif not emails:
            c.errors.add(errors.NO_EMAILS)
        else:
            # return single email if one is expected, list otherwise
            return list(emails)[0] if self.num == 1 else emails


class VCnameDomain(Validator):
    domain_re  = re.compile(r'^([\w]+\.)+[\w]+$')

    def run(self, domain):
        if (domain
            and (not self.domain_re.match(domain)
                 or domain.endswith('.reddit.com')
                 or len(domain) > 300)):
            c.errors.add(errors.BAD_CNAME)
        elif domain:
            try:
                return str(domain).lower()
            except UnicodeEncodeError:
                c.errors.add(errors.BAD_CNAME)




# NOTE: make sure *never* to have res check these are present
# otherwise, the response could contain reference to these errors...!
class ValidIP(Validator):
    def run(self):
        if is_banned_IP(request.ip):
            c.errors.add(errors.BANNED_IP)
        return request.ip

class ValidDomain(Validator):
    def run(self, url):
        if url and is_banned_domain(url):
            c.errors.add(errors.BANNED_DOMAIN)

# The contents of this file are subject to the Common Public Attribution
# License Version 1.0. (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://code.reddit.com/LICENSE. The License is based on the Mozilla Public
# License Version 1.1, but Sections 14 and 15 have been added to cover use of
# software over a computer network and provide for limited attribution for the
# Original Developer. In addition, Exhibit A has been modified to be consistent
# with Exhibit B.
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Code is Reddit.
# 
# The Original Developer is the Initial Developer.  The Initial Developer of the
# Original Code is CondeNet, Inc.
# 
# All portions of the code written by CondeNet are Copyright (c) 2006-2008
# CondeNet, Inc. All Rights Reserved.
################################################################################
from pylons import c
from r2.lib.db.thing     import Thing, Relation, NotFound
from r2.lib.db.operators import lower
from r2.lib.db.userrel   import UserRel
from r2.lib.memoize      import memoize, clear_memo
from r2.lib.utils        import modhash, valid_hash, randstr                     
from r2.lib.strings      import strings, plurals

from pylons import g
from pylons.i18n import _
import time, hashlib
from copy import copy

class AccountExists(Exception): pass
class NotEnoughKarma(Exception): pass

class Account(Thing):
    _data_int_props = Thing._data_int_props + ('link_karma', 'comment_karma',
                                               'report_made', 'report_correct',
                                               'report_ignored', 'spammer',
                                               'reported')
    _int_prop_suffix = '_karma'
    _defaults = dict(pref_numsites = 10,
                     pref_frame = False,
                     pref_newwindow = False,
                     pref_public_votes = False,
                     pref_kibitz = False,
                     pref_hide_ups = False,
                     pref_hide_downs = True,
                     pref_min_link_score = -2,
                     pref_min_comment_score = -2,
                     pref_num_comments = g.num_comments,
                     pref_lang = 'en',
                     pref_content_langs = ('en',),
                     pref_over_18 = False,
                     pref_compress = False,
                     pref_organic = True,
                     pref_show_stylesheets = True,
                     pref_url = '',
                     pref_location = '',
                     reported = 0,
                     report_made = 0,
                     report_correct = 0,
                     report_ignored = 0,
                     spammer = 0,
                     sort_options = {},
                     has_subscribed = False,
                     pref_media = 'subreddit',
                     share = {},
                     )

    def karma(self, kind, sr = None):
        from subreddit import Subreddit
        suffix = '_' + kind + '_karma'
        
        #if no sr, return the sum
        if sr is None:
            total = 0
            for k, v in self._t.iteritems():
                if k.endswith(suffix):
                    if kind == 'link':
                        try:
                            karma_sr_name = k[0:k.rfind(suffix)]
                            karma_sr = Subreddit._by_name(karma_sr_name)
                            multiplier = karma_sr.post_karma_multiplier
                        except NotFound:
                            multiplier = 1
                    else:
                        multiplier = 1
                    total += v * multiplier
            return total
        else:
            try:
                return getattr(self, sr.name + suffix)
            except AttributeError:
                #if positive karma elsewhere, you get min_up_karma
                if self.karma(kind) > 0:
                    return g.MIN_UP_KARMA
                else:
                    return 0

    def incr_karma(self, kind, sr, amt):
        prop = '%s_%s_karma' % (sr.name, kind)
        if hasattr(self, prop):
            return self._incr(prop, amt)
        else:
            default_val = self.karma(kind, sr)
            setattr(self, prop, default_val + amt)
            self._commit()

    @property
    def link_karma(self):
        return self.karma('link')

    @property
    def comment_karma(self):
        return self.karma('comment')

    @property
    def safe_karma(self):
        karma = self.link_karma + self.comment_karma
        return max(karma, 0) if karma > -1000 else karma

    def all_karmas(self):
        """returns a list of tuples in the form (name, link_karma,
        comment_karma)"""
        link_suffix = '_link_karma'
        comment_suffix = '_comment_karma'
        karmas = []
        sr_names = set()
        for k in self._t.keys():
            if k.endswith(link_suffix):
                sr_names.add(k[:-len(link_suffix)])
            elif k.endswith(comment_suffix):
                sr_names.add(k[:-len(comment_suffix)])
        for sr_name in sr_names:
            karmas.append((sr_name,
                           self._t.get(sr_name + link_suffix, 0),
                           self._t.get(sr_name + comment_suffix, 0)))
        karmas.sort(key = lambda x: x[1] + x[2])

        karmas.insert(0, ('total',
                          self.karma('link'),
                          self.karma('comment')))

        karmas.append(('old',
                       self._t.get('link_karma', 0),
                       self._t.get('comment_karma', 0)))

        return karmas

    def vote_cache_key(self, kind):
        """kind is 'link' or 'comment'"""
        return 'account_%d_%s_downvotes' % (self._id, kind)

    def check_downvote(self, vote_kind):
        """Checks whether this account has enough karma to cast a downvote.

        vote_kind is 'link' or 'comment' depending on the type of vote that's
        being cast.

        This makes the assumption that the user can't cast a vote for something
        on the non-current subreddit.
        """
        from r2.models.vote import Vote, Link, Comment

        def get_cached_downvotes(content_cls):
            kind = content_cls.__name__.lower()
            downvotes = g.cache.get(self.vote_cache_key(kind))
            if downvotes is None:
                vote_cls = Vote.rel(Account, content_cls)
                downvotes = len(list(vote_cls._query(Vote.c._thing1_id == self._id,
                                                          Vote.c._name == str(-1))))
                g.cache.set(self.vote_cache_key(kind), downvotes)
            return downvotes

        link_downvote_karma = get_cached_downvotes(Link) * c.current_or_default_sr.post_karma_multiplier
        comment_downvote_karma = get_cached_downvotes(Comment)
        karma_spent = link_downvote_karma + comment_downvote_karma

        karma_balance = self.safe_karma * 4
        vote_cost = c.current_or_default_sr.post_karma_multiplier if vote_kind == 'link' else 1
        if karma_spent + vote_cost > karma_balance:
            points_needed = abs(karma_balance - karma_spent - vote_cost)
            msg = strings.not_enough_downvote_karma % (points_needed, plurals.N_points(points_needed))
            raise NotEnoughKarma(msg)

    def incr_downvote(self, delta, kind):
        """kind is link or comment"""
        try:
            g.cache.incr(self.vote_cache_key(kind), delta)
        except ValueError, e:
            print 'Account.incr_downvote failed with: %s' % e

    def make_cookie(self, timestr = None, admin = False):
        if not self._loaded:
            self._load()
        timestr = timestr or time.strftime('%Y-%m-%dT%H:%M:%S')
        id_time = str(self._id) + ',' + timestr
        to_hash = ','.join((id_time, self.password, g.SECRET))
        if admin:
            to_hash += 'admin'
        return id_time + ',' + hashlib.sha1(to_hash).hexdigest()

    def needs_captcha(self):
        return self.safe_karma < 1

    def modhash(self, rand=None, test=False):                    
        return modhash(self, rand = rand, test = test)                    
    
    def valid_hash(self, hash):
        return valid_hash(self, hash)                    

    @classmethod
    @memoize('account._by_name')
    def _by_name_cache(cls, name, allow_deleted = False):
        #relower name here, just in case
        deleted = (True, False) if allow_deleted else False
        q = cls._query(lower(Account.c.name) == name.lower(),
                       Account.c._spam == (True, False),
                       Account.c._deleted == deleted)

        q._limit = 1
        l = list(q)
        if l:
            return l[0]._id

    @classmethod
    def _by_name(cls, name, allow_deleted = False):
        #lower name here so there is only one cache
        uid = cls._by_name_cache(name.lower(), allow_deleted)
        if uid:
            return cls._byID(uid, True)
        else:
            raise NotFound, 'Account %s' % name

    @property
    def friends(self):
        return self.friend_ids()

    def delete(self):
        self._deleted = True
        self._commit()
        clear_memo('account._by_name', Account, self.name.lower(), False)
        
        #remove from friends lists
        q = Friend._query(Friend.c._thing2_id == self._id,
                          Friend.c._name == 'friend',
                          eager_load = True)
        for f in q:
            f._thing1.remove_friend(f._thing2)

    @property
    def subreddits(self):
        from subreddit import Subreddit
        return Subreddit.user_subreddits(self)

    @property
    def draft_sr_name(self):
      return self.name + "-drafts"

    def recent_share_emails(self):
        return self.share.get('recent', set([]))

    def add_share_emails(self, emails):
        if not emails:
            return
        
        if not isinstance(emails, set):
            emails = set(emails)

        self.share.setdefault('emails', {})
        share = self.share.copy()

        share_emails = share['emails']
        for e in emails:
            share_emails[e] = share_emails.get(e, 0) +1
            
        share['recent'] = emails

        self.share = share
        
            
            


class FakeAccount(Account):
    _nodb = True


def valid_cookie(cookie):
    try:
        uid, timestr, hash = cookie.split(',')
        uid = int(uid)
    except:
        return (False, False)

    try:
        account = Account._byID(uid, True)
        if account._deleted:
            return (False, False)
    except NotFound:
        return (False, False)

    if cookie == account.make_cookie(timestr, admin = False):
        return (account, False)
    elif cookie == account.make_cookie(timestr, admin = True):
        return (account, True)
    return (False, False)

def valid_login(name, password):
    try:
        a = Account._by_name(name)
    except NotFound:
        return False

    if not a._loaded: a._load()
    return valid_password(a, password)

def valid_password(a, password):
    try:
        if a.password == passhash(a.name, password, ''):
            #add a salt
            a.password = passhash(a.name, password, True)
            a._commit()
            return a
        else:
            salt = a.password[:3]
            if a.password == passhash(a.name, password, salt):
                return a
    except AttributeError:
        return False

def passhash(username, password, salt = ''):
    if salt is True:
        salt = randstr(3)
    tohash = '%s%s %s' % (salt, username, password)
    if isinstance(tohash, unicode):
        # Force tohash to be a byte string so it can be hashed
        tohash = tohash.encode('utf8')
    return salt + hashlib.sha1(tohash).hexdigest()

def change_password(user, newpassword):
    user.password = passhash(user.name, newpassword, True)
    user._commit()
    return True

#TODO reset the cache
def register(name, password, email=None):
    try:
        a = Account._by_name(name)
        raise AccountExists
    except NotFound:
        a = Account(name = name,
                    password = passhash(name, password, True))
        if email:
            a.email = email

        a._commit()
            
        # Clear memoization of both with and without deleted
        clear_memo('account._by_name', Account, name.lower(), True)
        clear_memo('account._by_name', Account, name.lower(), False)
        return a

class Friend(Relation(Account, Account)): pass
Account.__bases__ += (UserRel('friend', Friend),)

from reddit_base import RedditController
from r2.lib.pages import BoringPage, ShowMeetup, NewMeetup, EditMeetup, PaneStack, CommentListing, LinkInfoPage, CommentReplyBox, NotEnoughKarmaToPost
from validator import validate, VUser, VRequired, VMeetup, VEditMeetup, VFloat, ValueOrBlank, ValidIP, VMenu, VCreateMeetup                    
from errors import errors
from r2.lib.jsonresponse import Json
from routes.util import url_for
from r2.models import Meetup,Link,Subreddit,CommentBuilder
from r2.models.listing import NestedListing
from r2.lib.menus import CommentSortMenu,NumCommentsMenu
from r2.lib.filters import python_websafe
from mako.template import Template
from pylons.i18n import _
from pylons import c,g,request
import json

def meetup_article_text(meetup):
  t = Template(filename="r2/templates/showmeetup.html", output_encoding='utf-8', encoding_errors='replace')
  res = t.get_def("meetup_info").render_unicode(meetup=meetup)

  url = url_for(controller='meetups',action='show',id=meetup._id36)
  title = python_websafe(meetup.title)
  hdr = u"<h2>Discussion article for the meetup : <a href='%s'>%s</a></h2>"%(url,title)
  return hdr+res+hdr

def meetup_article_title(meetup):
  return "Meetup : %s"%meetup.title

class MeetupsController(RedditController):
  def response_func(self, **kw):
    return self.sendstring(json.dumps(kw))

  @validate(VUser(), 
            VCreateMeetup(),
            title = ValueOrBlank('title'),
            description = ValueOrBlank('description'),
            location = ValueOrBlank('location'),
            latitude = ValueOrBlank('latitude'),
            longitude = ValueOrBlank('longitude'),
            timestamp = ValueOrBlank('timestamp'),
            tzoffset = ValueOrBlank('tzoffset'))
  def GET_new(self, *a, **kw):
    return BoringPage(pagename = 'New Meetup', content = NewMeetup(*a, **kw)).render()

  @Json
  @validate(VUser(),
            VCreateMeetup(),
            ip = ValidIP(),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_create(self, res, title, description, location, latitude, longitude, timestamp, tzoffset, ip):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup = Meetup(
      author_id = c.user._id,

      title = title,
      description = description,

      location = location,
      latitude = latitude,
      longitude = longitude,

      timestamp = timestamp / 1000, # Value from form is in ms UTC
      tzoffset = tzoffset
    )

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    l = Link._submit(meetup_article_title(meetup), meetup_article_text(meetup),
                     c.user, Subreddit._by_name('discussion'),ip, [])

    l.meetup = meetup._id36
    l._commit()
    meetup.assoc_link = l._id
    meetup._commit()

    #update the queries
    if g.write_query_queue:
      queries.new_link(l)

    res._redirect(url_for(action='show', id=meetup._id36))

  @Json
  @validate(VUser(),
            meetup = VEditMeetup('id'),
            title = VRequired('title', errors.NO_TITLE),
            description = VRequired('description', errors.NO_DESCRIPTION),
            location = VRequired('location', errors.NO_LOCATION),
            latitude = VFloat('latitude', error=errors.NO_LOCATION),
            longitude = VFloat('longitude', error=errors.NO_LOCATION),
            timestamp = VFloat('timestamp', error=errors.INVALID_DATE),
            tzoffset = VFloat('tzoffset', error=errors.INVALID_DATE))
  def POST_update(self, res, meetup, title, description, location, latitude, longitude, timestamp, tzoffset):
    if res._chk_error(errors.NO_TITLE):
      res._chk_error(errors.TITLE_TOO_LONG)
      res._focus('title')

    res._chk_errors((errors.NO_LOCATION,
                     errors.NO_DESCRIPTION,
                     errors.INVALID_DATE,
                     errors.NO_DATE))

    if res.error: return

    meetup.title = title
    meetup.description = description

    meetup.location = location
    meetup.latitude = latitude
    meetup.longitude = longitude

    meetup.timestamp = timestamp / 1000 # Value from form is in ms UTC
    meetup.tzoffset = tzoffset

    # Expire all meetups in the render cache
    g.rendercache.invalidate_key_group(Meetup.group_cache_key())

    meetup._commit()

    # Update the linked article
    article = Link._byID(meetup.assoc_link)
    article._load()
    article_old_url = article.url
    article.title = meetup_article_title(meetup)
    article.article = meetup_article_text(meetup)
    article._commit()
    article.update_url_cache(article_old_url)


    res._redirect(url_for(action='show', id=meetup._id36))

  @validate(VUser(),
            meetup = VEditMeetup('id'))
  def GET_edit(self, meetup):
    return BoringPage(pagename = 'Edit Meetup', content = EditMeetup(meetup,
                                                                     title=meetup.title,
                                                                     description=meetup.description,
                                                                     location=meetup.location,
                                                                     latitude=meetup.latitude,
                                                                     longitude=meetup.longitude,
                                                                     timestamp=int(meetup.timestamp * 1000),
                                                                     tzoffset=meetup.tzoffset)).render()

  # Show a meetup.  Most of this code was coped from GET_comments in front.py
  @validate(meetup = VMeetup('id'),
            sort         = VMenu('controller', CommentSortMenu),
            num_comments = VMenu('controller', NumCommentsMenu))
  def GET_show(self, meetup, sort, num_comments):
    article = Link._byID(meetup.assoc_link)

    # figure out number to show based on the menu
    user_num = c.user.pref_num_comments or g.num_comments
    num = g.max_comments if num_comments == 'true' else user_num

    builder = CommentBuilder(article, CommentSortMenu.operator(sort), None, None)
    listing = NestedListing(builder, num=num, parent_name = article._fullname)
    displayPane = PaneStack()
    
    # insert reply box only for logged in user
    if c.user_is_loggedin:
      displayPane.append(CommentReplyBox())
      displayPane.append(CommentReplyBox(link_name = 
                                         article._fullname))

    # finally add the comment listing
    displayPane.append(listing.listing())

    sort_menu = CommentSortMenu(default = sort, type='dropdown2')
    nav_menus = [sort_menu,
                 NumCommentsMenu(article.num_comments,
                                 default=num_comments)]

    content = CommentListing(
      content = displayPane,
      num_comments = article.num_comments,
      nav_menus = nav_menus,
      )


    # Update last viewed time, and return the previous last viewed time.  Actually tracked on the article
    lastViewed = None
    if c.user_is_loggedin:
      clicked = article._getLastClickTime(c.user)
      lastViewed = clicked._date if clicked else None
      article._click(c.user)

    res = ShowMeetup(meetup = meetup, content = content, 
                     fullname=article._fullname,
                     lastViewed = lastViewed)

    return BoringPage(pagename = meetup.title, 
                      content = res,
                      body_class = 'meetup').render()



#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import webapp2
import jinja2
import os
import logging

import hashlib

import cgi

from google.appengine.api import users
from google.appengine.ext import webapp
from google.appengine.ext.webapp.util import run_wsgi_app
from google.appengine.ext import db
from google.appengine.api import images

jinja_environment = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.dirname(__file__)))

def render_template(handler_object, file_name, template_values):
  user = users.get_current_user()
  if user:
    current_li = db.GqlQuery("SELECT * FROM LoginInformation WHERE user_id = :1", user.user_id()).get()
  else:
    current_li = None
  template_values['current_li'] = current_li
  template_values['user'] = user
  template_values['logout_url'] = users.create_logout_url('/')
  template_values['login_url'] = users.create_login_url('/users/verify_user/')
  template_values['is_admin'] = users.is_current_user_admin()
  if user:
    li = db.GqlQuery("SELECT * FROM LoginInformation WHERE user_id = :1", user.user_id()).get()
    template_values['unread_messages'] = db.GqlQuery("SELECT * FROM Message WHERE recipient_id = :1 AND read = :2", user.user_id(), False).count()
    if li and not(li.is_active):
      file_name = '/users/inactive_notification.html'
  template = jinja_environment.get_template(file_name)
  handler_object.response.out.write(template.render(template_values))
  
def get_current_li():
  return db.GqlQuery("SELECT * FROM LoginInformation WHERE user_id = :1", users.get_current_user.user_id()).get()                    
  
class LoginInformation(db.Model):
  first_name = db.StringProperty()
  last_name = db.StringProperty()
  #belongs_to User
  user_id = db.StringProperty()
  is_active = db.BooleanProperty()
  is_admin = db.BooleanProperty()
  avatar = db.BlobProperty()
  nickname = db.StringProperty()
  private = db.BooleanProperty()
  
  def get_private_display_name(this):
    return this.first_name + " " + this.last_name
  
class Thread(db.Model):
  title = db.StringProperty()
  created_at = db.DateTimeProperty(auto_now_add=True)
  recipient_id = db.StringProperty()
  #has_many messages
  #belongs_to User
  created_by_id = db.StringProperty()
  
class Message(db.Model):
  body = db.TextProperty()
  created_at = db.DateTimeProperty(auto_now_add=True)
  created_by_id = db.StringProperty()
  recipient_id = db.StringProperty()
  read = db.BooleanProperty()
  #belongs_to Thread
  def get_sender(this):
    return db.GqlQuery("SELECT * FROM LoginInformation WHERE user_id = :1", this.created_by_id).get()
  
def save_message(message, thread, user):
  message.parent = thread
  message.put()

class Item(db.Model):
  title = db.StringProperty()
  description = db.TextProperty()
  price = db.StringProperty()
  created_at = db.DateTimeProperty(auto_now_add=True)
  expiration_date = db.DateProperty()
  #belongs_to User
  created_by_id = db.StringProperty()

#!/usr/bin/env python

import database
from database import cgi
from database import db

class MainHandler(database.webapp2.RequestHandler):
  def get(self):
    items = db.GqlQuery("SELECT * FROM Item ORDER BY created_at DESC")
    is_admin = database.users.is_current_user_admin()
    database.render_template(self, 'items/index.html', {'items': items})

class NewHandler(database.webapp2.RequestHandler):
  def get(self):
    if database.users.get_current_user():
      database.render_template(self, 'items/new_item.html', {})
    else:
      self.redirect('/')
    
class ViewHandler(database.webapp2.RequestHandler):
  def get(self):
    item = db.get(db.Key.from_path('Item', int(self.request.get('item_id'))))
    li = db.GqlQuery("SELECT * FROM LoginInformation WHERE user_id = :1", item.created_by_id).get()
    database.render_template(self, 'items/view_item.html', {'item': item, 'li': li})
    
class SaveHandler(database.webapp2.RequestHandler):
  def post(self):
    user = database.users.get_current_user()
    if user:                    
      item = database.Item()
      item.title = cgi.escape(self.request.get('title'))
      item.description = cgi.escape(self.request.get('description'))
      item.price = '%.2f' % float(cgi.escape(self.request.get('price')))
      item.created_by_id = user.user_id()
      item.put()
      database.logging.info("Created a new item.\nTitle: %s\nDescription: %s\nPrice: %s\nCreatedBy: %s", item.title, item.description, item.price, item.created_by_id)
      self.redirect('/items/')
    else:
      self.redirect('/')
    
class DeleteHandler(database.webapp2.RequestHandler):
  def get(self):
    user = database.users.get_current_user()
    if user:                    
      item = db.get(db.Key.from_path('Item', int(self.request.get('item_id'))))
      #make sure the person owns this item or they're an admin
      if (item.created_by_id == user.user_id()) or (database.users.is_current_user_admin()):
        database.logging.info("Deleting item with id %s", item.key().id())
        database.db.delete(item)
    self.redirect(self.request.referer)
    
class EditHandler(database.webapp2.RequestHandler):
  def get(self):
    user = database.users.get_current_user()
    if user:                    
      item = db.get(db.Key.from_path('Item', int(self.request.get('item_id'))))
      database.render_template(self, 'items/edit_item.html', {'item': item})
    else:
      self.redirect('/')
      
class UpdateHandler(database.webapp2.RequestHandler):
  def post(self):
    user = database.users.get_current_user()
    if user:                    
      item = db.get(db.Key.from_path('Item', int(cgi.escape(self.request.get('item_id')))))
      item.title = cgi.escape(self.request.get('title'))
      item.description = cgi.escape(self.request.get('description'))
      item.price = cgi.escape(self.request.get('price'))
      database.logging.info("Item #%s changed to:\nTitle: %s\nDescription: %s\nPrice: %s", item.key().id(), item.title, item.description, item.price)
      item.put()
      self.redirect('/items/my_items')
    else:
      self.redirect('/')
    
class ShopHandler(database.webapp2.RequestHandler):
  def get(self):
    user = database.users.get_current_user()
    if user:                    
      items = db.GqlQuery("SELECT * FROM Item WHERE created_by_id = :1 ORDER BY created_at DESC", user.user_id())
      database.render_template(self, 'items/my_items.html', {'items': items})
    else:
      self.redirect('/')
    
class SearchHandler(database.webapp2.RequestHandler):
  def post(self):
    query = cgi.escape(self.request.get('query'))
    items = db.GqlQuery("SELECT * FROM Item WHERE title = :1 ORDER BY created_at DESC", query)
    database.render_template(self, 'items/search.html', { 'items': items, 'query': query})
    

app = database.webapp2.WSGIApplication([('/items/', MainHandler), ('/items/new_item', NewHandler), 
('/items/save_item', SaveHandler), ('/items/view_item', ViewHandler), ('/items/search', SearchHandler),
('/items/my_items', ShopHandler), ('/items/delete_item', DeleteHandler), ('/items/edit_item', EditHandler),
('/items/update_item', UpdateHandler)], debug=True)


# Copyright 2011 Mike Wakerly <opensource@hoho.com>
#
# This file is part of the Pykeg package of the Kegbot project.
# For more information on Pykeg or Kegbot, see http://kegbot.org/
#
# Pykeg is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Pykeg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pykeg.  If not, see <http://www.gnu.org/licenses/>.

from pykeg.core import models

from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404

class KegbotSiteMiddleware:
  def process_view(self, request, view_func, view_args, view_kwargs):
    """Removes kbsite_name from kwargs if present, and attaches the
    corresponding KegbotSite instance to the request as the "kbsite" attribute.

    If kbsite_name is None, the default site is selected.
    """
    kbsite_name = view_kwargs.pop('kbsite_name', None)
    if not kbsite_name:
      kbsite_name = 'default'
    try:
      request.kbsite = models.KegbotSite.objects.get(name=kbsite_name)
    except models.KegbotSite.DoesNotExist:
      pass
    return None

class SiteActiveMiddleware:
  """Middleware which throws 503s when KegbotSite.is_active is false."""
  ALLOWED_PATHS = (                    
      '/accounts/login/',                    
      '/admin/',                    
      '/site_media/',                    
  )
  def _path_allowed(self, path):                    
    for p in self.ALLOWED_PATHS:                    
      if path.startswith(p):                    
        return True                    
    return False                    

  def process_view(self, request, view_func, view_args, view_kwargs):
    if not hasattr(request, 'kbsite'):
      return None
    kbsite = request.kbsite

    # We have a KegbotSite, and that site is active: nothing to do.
    if kbsite.is_active:
      return None

    # If the request is for a whitelisted path, allow it.
    if self._path_allowed(request.path):                    
      return None

    # Allow staff/superusers access if inactive.
    if request.user.is_staff or request.user.is_superuser:
      return None

    return HttpResponse('Site temporarily unavailable', status=503)


# Copyright 2011 Mike Wakerly <opensource@hoho.com>
#
# This file is part of the Pykeg package of the Kegbot project.
# For more information on Pykeg or Kegbot, see http://kegbot.org/
#
# Pykeg is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Pykeg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Pykeg.  If not, see <http://www.gnu.org/licenses/>.

from pykeg.core import models

from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404

class KegbotSiteMiddleware:
  def process_view(self, request, view_func, view_args, view_kwargs):
    """Removes kbsite_name from kwargs if present, and attaches the
    corresponding KegbotSite instance to the request as the "kbsite" attribute.

    If kbsite_name is None, the default site is selected.
    """
    kbsite_name = view_kwargs.pop('kbsite_name', None)
    if not kbsite_name:
      kbsite_name = 'default'
    try:
      request.kbsite = models.KegbotSite.objects.get(name=kbsite_name)
    except models.KegbotSite.DoesNotExist:
      pass
    return None

class SiteActiveMiddleware:
  """Middleware which throws 503s when KegbotSite.is_active is false."""
  ALLOWED_PATHS = (                    
      '/accounts/login/',                    
      '/admin/',                    
      '/site_media/',                    
  )
  def _path_allowed(self, path):                    
    for p in self.ALLOWED_PATHS:                    
      if path.startswith(p):                    
        return True                    
    return False                    

  def process_view(self, request, view_func, view_args, view_kwargs):
    if not hasattr(request, 'kbsite'):
      return None
    kbsite = request.kbsite

    # We have a KegbotSite, and that site is active: nothing to do.
    if kbsite.is_active:
      return None

    # If the request is for a whitelisted path, allow it.
    if self._path_allowed(request.path):                    
      return None

    # Allow staff/superusers access if inactive.
    if request.user.is_staff or request.user.is_superuser:
      return None

    return HttpResponse('Site temporarily unavailable', status=503)

import fnmatch
import logging

from flask import abort, request, g                    
from flask import url_for
from functools import wraps

from confidant import keymanager
from confidant.app import app
from confidant.utils import stats

from confidant.authnz.errors import (UserUnknownError, TokenVersionError,
                                     AuthenticationError, NotAuthorized)
from confidant.authnz import userauth

PRIVILEGES = {
    'user': ['*'],
    'service': ['get_service']
}

user_mod = userauth.init_user_auth_class()


def get_logged_in_user():
    '''
    Retrieve logged-in user's email that is stored in cache
    '''
    if hasattr(g, 'username'):
        return g.username
    if user_mod.is_authenticated():
        return user_mod.current_email()
    raise UserUnknownError()


def user_is_user_type(user_type):
    if not app.config.get('USE_AUTH'):
        return True
    if user_type == g.user_type:
        return True
    return False


def user_is_service(service):
    if not app.config.get('USE_AUTH'):
        return True
    if g.username == service:
        return True
    return False


def service_in_account(account):
    # We only scope to account, if an account is specified.
    if not account:
        return True
    if g.account == account:
        return True
    return False


def account_for_key_alias(key_alias):
    return app.config['SCOPED_AUTH_KEYS'].get(key_alias)


def user_type_has_privilege(user_type, privilege):
    for _privilege in PRIVILEGES[user_type]:
        if fnmatch.fnmatch(privilege, _privilege):
            return True
    return False


def require_csrf_token(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # If we're not using auth, there's no point in checking csrf tokens.
        if not app.config.get('USE_AUTH'):
            return f(*args, **kwargs)                    
        # KMS is username/password or header auth, so we don't need to check
        # for csrf tokens.
        if g.auth_type == 'kms':
            return f(*args, **kwargs)                    
        if user_mod.check_csrf_token():
            return f(*args, **kwargs)                    
        return abort(401)
    return decorated


def _parse_username(username):
    username_arr = username.split('/')
    if len(username_arr) == 3:
        # V2 token format: version/service/myservice or version/user/myuser
        version = int(username_arr[0])
        user_type = username_arr[1]
        username = username_arr[2]
    elif len(username_arr) == 1:
        # Old format, specific to services: myservice
        version = 1
        username = username_arr[0]
        user_type = 'service'
    else:
        raise TokenVersionError('Unsupported username format.')
    return version, user_type, username


def _get_kms_auth_data():
    data = {}
    auth = request.authorization
    headers = request.headers
    if auth and auth.get('username'):
        if not auth.get('password'):
            raise AuthenticationError('No password provided via basic auth.')
        (data['version'],
         data['user_type'],
         data['from']) = _parse_username(auth['username'])
        data['token'] = auth['password']
    elif 'X-Auth-Token' in headers and 'X-Auth-From' in headers:
        if not headers.get('X-Auth-Token'):
            raise AuthenticationError(
                'No X-Auth-Token provided via auth headers.'
            )
        (data['version'],
         data['user_type'],
         data['from']) = _parse_username(headers['X-Auth-From'])
        data['token'] = headers['X-Auth-Token']
    return data


def log_in():
    return user_mod.log_in()


def redirect_to_logout_if_no_auth(f):
    """
    Decorator for redirecting users to the logout page when they are
    not authenticated.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        if user_mod.is_expired():
            return user_mod.redirect_to_goodbye()

        if user_mod.is_authenticated():
            return f(*args, **kwargs)                    
        else:
            return user_mod.redirect_to_goodbye()
    return decorated


def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not app.config.get('USE_AUTH'):
            return f(*args, **kwargs)                    

        # User suppplied basic auth info
        try:
            kms_auth_data = _get_kms_auth_data()
        except TokenVersionError:
            logging.warning('Invalid token version used.')
            return abort(403)
        except AuthenticationError:
            logging.exception('Failed to authenticate request.')
            return abort(403)
        if kms_auth_data:
            try:
                if (kms_auth_data['user_type']
                        not in app.config['KMS_AUTH_USER_TYPES']):
                    msg = '{0} is not an allowed user type for KMS auth.'
                    msg = msg.format(kms_auth_data['user_type'])
                    logging.warning(msg)
                    return abort(403)
                with stats.timer('decrypt_token'):
                    token_data = keymanager.decrypt_token(
                        kms_auth_data['version'],
                        kms_auth_data['user_type'],
                        kms_auth_data['from'],
                        kms_auth_data['token']
                    )
                logging.debug('Auth request had the following token_data:'
                              ' {0}'.format(token_data))
                msg = 'Authenticated {0} with user_type {1} via kms auth'
                msg = msg.format(
                    kms_auth_data['from'],
                    kms_auth_data['user_type']
                )
                logging.debug(msg)
                if user_type_has_privilege(
                        kms_auth_data['user_type'],
                        f.func_name):
                    g.user_type = kms_auth_data['user_type']
                    g.auth_type = 'kms'
                    g.account = account_for_key_alias(token_data['key_alias'])
                    g.username = kms_auth_data['from']
                    return f(*args, **kwargs)                    
                else:
                    msg = '{0} is not authorized to access {1}.'
                    msg = msg.format(kms_auth_data['from'], f.func_name)
                    logging.warning(msg)
                    return abort(403)
            except keymanager.TokenDecryptionError:
                logging.exception('Failed to decrypt authentication token.')
                msg = 'Access denied for {0}. Authentication Failed.'
                msg = msg.format(kms_auth_data['from'])
                logging.warning(msg)
                return abort(403)

        # If not using kms auth, require auth using the user_mod authn module.
        else:
            user_type = 'user'
            if not user_type_has_privilege(user_type, f.func_name):
                return abort(403)

            if user_mod.is_expired():
                return abort(401)

            if user_mod.is_authenticated():
                try:
                    user_mod.check_authorization()
                except NotAuthorized as e:
                    logging.warning('Not authorized -- ' + e.message)
                    return abort(403)
                else:
                    # User took an action, extend the expiration time.
                    user_mod.set_expiration()
                    # auth-N and auth-Z are good, call the decorated function
                    g.user_type = user_type
                    g.auth_type = user_mod.auth_type
                    return f(*args, **kwargs)                    

            # Not authenticated
            return abort(401)

        logging.error('Ran out of authentication methods')
        return abort(403)

    return decorated


def require_logout_for_goodbye(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not app.config.get('USE_AUTH'):
            return f(*args, **kwargs)                    

        # ideally we would call check_csrf_token, but I don't think logout CSRF
        # is a serious concern for this application

        try:
            get_logged_in_user()
        except UserUnknownError:
            # ok, not logged in
            return f(*args, **kwargs)                    

        logging.warning('require_logout(): calling log_out()')
        resp = user_mod.log_out()

        if resp.headers.get('Location') == url_for('goodbye'):
            # avoid redirect loop and just render the page
            return f(*args, **kwargs)                    
        else:
            return resp

    return decorated

import abc
import logging
import urlparse
import datetime
import random

import yaml

import flask
from flask import request, session
from flask import abort, jsonify, redirect
from werkzeug.security import safe_str_cmp

# google auth imports
from authomatic import Authomatic
from authomatic.providers import oauth2
from authomatic.adapters import WerkzeugAdapter

# saml auth imports
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from confidant.lib import cryptolib
from confidant.utils.misc import dict_deep_update

from confidant.app import app

from confidant.authnz import errors


def init_user_auth_class(*args, **kwargs):
    if not app.config['USE_AUTH']:
        module = NullUserAuthenticator

    else:
        module_name = app.config['USER_AUTH_MODULE'].lower()
        if module_name == 'google':
            module = GoogleOauthAuthenticator
        elif module_name == 'saml':
            module = SamlAuthenticator
        elif module_name == 'null':
            module = NullUserAuthenticator
        else:
            raise ValueError(
                'Unknown USER_AUTH_MODULE: {!r}'.format(module_name))

    logging.info('Initializing {} user authenticator'.format(module.auth_type))                    
    return module(*args, **kwargs)                    


class AbstractUserAuthenticator(object):
    __metaclass__ = abc.ABCMeta

    @abc.abstractproperty
    def auth_type(self):
        """A string describing the type of authentication used"""
        pass

    def is_authenticated(self):
        return 'user' in session

    def is_expired(self):
        if 'expiration' in session:
            # Paranoia case
            if session.get('max_expiration') is None:
                logging.warning(
                    'max_expiration unset on session, when expiration is set.'
                )
                return True
            now = datetime.datetime.utcnow()
            if now > session['expiration']:
                return True
            elif now > session['max_expiration']:
                return True
        else:
            return False

    def current_user(self):
        return session['user']

    def get_csrf_token(self):
        return session.get('XSRF-TOKEN')

    def set_csrf_token(self, resp):
        session['XSRF-TOKEN'] = '{0:x}'.format(                    
            random.SystemRandom().getrandbits(160)                    
        )
        resp.set_cookie('XSRF-TOKEN', session['XSRF-TOKEN'])

    def check_csrf_token(self):
        token = request.headers.get('X-XSRF-TOKEN', '')
        if not token:
            return False
        return safe_str_cmp(token, session.get('XSRF-TOKEN', ''))

    def set_expiration(self):
        if app.config['PERMANENT_SESSION_LIFETIME']:
            session.permanent = True
            now = datetime.datetime.utcnow()
            lifetime = app.config['PERMANENT_SESSION_LIFETIME']
            expiration = now + datetime.timedelta(seconds=lifetime)
            session['expiration'] = expiration
            # We want the max_expiration initially set, but we don't want it to
            # be extended.
            if not session.get('max_expiration'):
                max_lifetime = app.config['MAX_PERMANENT_SESSION_LIFETIME']
                if not max_lifetime:
                    max_lifetime = lifetime
                max_expiration = now + datetime.timedelta(seconds=max_lifetime)
                session['max_expiration'] = max_expiration

    def set_current_user(self, email, first_name=None, last_name=None):
        session['user'] = {
            'email': email,
            'first_name': first_name,
            'last_name': last_name,
        }

    def current_email(self):
        return self.current_user()['email'].lower()

    def current_first_name(self):
        return self.current_user()['first_name']

    def current_last_name(self):
        return self.current_user()['last_name']

    def redirect_to_index(self):
        return redirect(flask.url_for('index'))

    def redirect_to_goodbye(self):
        return redirect(flask.url_for('goodbye'))

    @abc.abstractmethod
    def log_in(self):
        """
        Perform steps needed to start the SSO login process.

        This method must return a Flask response.

        Initially this method will probably return a redirect to an external
        login page for SSO.

        This handler MAY also be used to handle login callbacks from the SSO
        provider, or you can define a separate route for this. Regardless, the
        code that implements the callback should call set_current_user() to set
        user data on the session, then redirect to the desired post-login page
        (e.g. with redirect_to_index()).

        On failure, this method should likely return abort(403).
        """
        pass

    def log_out(self):
        """
        Perform steps needed to start the SLO (SingleLogOut) process.

        This method must return a Flask response.

        This handler MAY also be used to handle logout callbacks from the
        SSO/SLO provider, or you can define a separate route for this.
        Regardless, the code that implements the callback should call
        clear_session(), then redirect to the desired post-logout page
        (e.g. with redirect_to_goodbye()).
        """
        logging.info('Using default log_out() method')
        self.clear_session()

        return self.redirect_to_goodbye()

    def clear_session(self):
        logging.info('Clearing flask session')
        session['user'] = {}
        session.clear()

    @property
    def allowed_email_whitelist(self):
        """
        A whitelist of authorized email addresses or None.
        Loaded from config['USERS_FILE'] as YAML.
        """
        if not hasattr(self, '_email_whitelist'):
            self._email_whitelist = None
            if app.config['USERS_FILE']:
                with open(app.config['USERS_FILE'], 'r') as f:
                    self._email_whitelist = yaml.safe_load(f.read())

        return self._email_whitelist

    @property
    def allowed_email_suffix(self):
        """
        A whitelisted suffix for email addresses.
        Loaded from config['USER_EMAIL_SUFFIX'].

        Returns either a string or None.
        """

        return app.config['USER_EMAIL_SUFFIX']

    def check_authorization(self):
        email = self.current_email()

        if not self.passes_email_suffix(email):
            msg = 'User {!r} does not have email suffix {!r}'.format(
                email, self.allowed_email_suffix)
            raise errors.NotAuthorized(msg)

        if not self.passes_email_whitelist(email):
            msg = 'User not in whitelist: {!r}'.format(
                email, self.allowed_email_whitelist)
            raise errors.NotAuthorized(msg)

        return True

    def passes_email_suffix(self, email):
        if self.allowed_email_suffix:
            return email.endswith(self.allowed_email_suffix)
        else:
            return True

    def passes_email_whitelist(self, email):
        if self.allowed_email_whitelist is not None:
            return email in self.allowed_email_whitelist
        else:
            return True


class NullUserAuthenticator(object):
    """
    Fake user authenticator class that performs no authentication.
    """

    def __init__(self):
        # guard against using this when you think auth is in use
        assert not app.config['USE_AUTH']

    @property
    def auth_type(self):
        return 'null'

    def current_user(self):
        return {
            'email': 'unauthenticated user',
            'first_name': 'unauthenticated',
            'last_name': 'user',
        }

    def current_email(self):
        return self.current_user()['email'].lower()

    def current_first_name(self):
        return self.current_user()['first_name']

    def current_last_name(self):
        return self.current_user()['last_name']

    def is_authenticated(self):
        """Null users are always authenticated"""
        return True

    def is_expired(self):
        """Null users are never expired"""
        return False

    def check_authorization(self):
        """Null users are always authorized"""
        return True

    def log_in(self):
        # should never be called
        raise NotImplementedError


class GoogleOauthAuthenticator(AbstractUserAuthenticator):
    """
    User authenticator class implementing Google OAuth.
    """

    def __init__(self):
        self.authomatic_config = {
            'google': {
                'class_': oauth2.Google,
                'consumer_key': app.config['GOOGLE_OAUTH_CLIENT_ID'],
                'consumer_secret': app.config['GOOGLE_OAUTH_CONSUMER_SECRET'],
                'scope': [
                    'profile',
                    'email'
                ]
            }
        }

        self.authomatic = Authomatic(
            self.authomatic_config,
            app.config['AUTHOMATIC_SALT']
        )

    @property
    def auth_type(self):
        return 'google oauth'

    def log_in(self):
        response = flask.make_response()
        result = self.authomatic.login(
            WerkzeugAdapter(request, response),
            'google',
            session=session,
            session_saver=lambda: app.save_session(session, response),
            secure_cookie=(True if request.is_secure else False)
        )
        if result:
            if result.error:
                msg = 'Google auth failed with error: {0}'
                logging.error(msg.format(result.error.message))
                return abort(403)

            # successful login
            if result.user:
                result.user.update()
                user = result.user
                self.set_expiration()
                self.set_current_user(email=user.email,
                                      first_name=user.first_name,
                                      last_name=user.last_name)
                # TODO: find a way to save the angular args?
                # authomatic adds url params google auth has stripped the
                # angular args anyway, so let's just redirect back to the
                # index.
                resp = self.redirect_to_index()
                self.set_csrf_token(resp)
                return resp

        # Authomatic will have put a redirect in our response here.
        return response


class SamlAuthenticator(AbstractUserAuthenticator):
    """
    User authenticator class implementing SAML.
    """

    @property
    def auth_type(self):
        return 'saml'

    def __init__(self):
        self.saml_config = self._render_saml_settings_dict()

    def _load_x509_for_saml(self, path):
        """Load an X.509 certificate from a PEM file."""
        return cryptolib.load_x509_certificate_pem_as_bare_base64(path)

    def _load_rsa_for_saml(self, path, password=None):
        """Load an RSA private key file."""
        return cryptolib.load_private_key_pem_as_bare_base64(path,
                                                             password=password)

    def _render_saml_settings_dict(self):
        """
        Given the configuration present in app.config, render a settings dict
        suitable for passing to OneLogin_Saml2_Auth() in initialization.
        """

        debug = app.config['SAML_DEBUG']
        if debug is None:
            debug = app.debug

        root_url = app.config['SAML_CONFIDANT_URL_ROOT']
        if not root_url:
            raise ValueError("Must provide SAML_CONFIDANT_URL_ROOT")
        root_url = root_url.rstrip('/')

        # TODO: also support unspecified?
        name_id_fmt = 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress'

        # Service Provider section
        sp_data = {
            'entityId': root_url + '/v1/saml/metadata',
            'assertionConsumerService': {
                'url': root_url + '/v1/saml/consume',
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST'
            },
            'singleLogoutService': {
                'url': root_url + '/v1/saml/logout',
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-REDIRECT'
            },
            'NameIDFormat': name_id_fmt,
        }

        sp_has_key = False
        if app.config['SAML_SP_KEY_FILE']:
            sp_has_key = True
            sp_data['privateKey'] = self._load_rsa_for_saml(
                app.config['SAML_SP_KEY_FILE'],
                password=app.config.get('SAML_SP_KEY_FILE_PASSWORD'))
        if app.config['SAML_SP_KEY']:
            sp_has_key = True
            sp_data['privateKey'] = app.config['SAML_SP_KEY']

        if app.config['SAML_SP_CERT_FILE']:
            sp_data['x509cert'] = self._load_x509_for_saml(
                app.config['SAML_SP_CERT_FILE'])
        if app.config['SAML_SP_CERT']:
            sp_data['x509cert'] = app.config['SAML_SP_CERT']

        # security defaults: sign everything if SP key was provided
        security_data = {
            'nameIdEncrypted': False,
            'authnRequestsSigned': sp_has_key,
            'logoutRequestsSigned': sp_has_key,
            'logoutResponsesSigned':
                app.config['SAML_SECURITY_SLO_RESP_SIGNED'],
            'signMetadata': sp_has_key,
            'wantMessagesSigned':
                app.config['SAML_SECURITY_MESSAGES_SIGNED'],
            'wantAssertionsSigned':
                app.config['SAML_SECURITY_ASSERTIONS_SIGNED'],
            'wantNameIdEncrypted': False,
            "signatureAlgorithm": app.config['SAML_SECURITY_SIG_ALGO'],
        }

        # Identity provider section
        idp_data = {
            'entityId': app.config['SAML_IDP_ENTITY_ID'],
            'singleSignOnService': {
                'url': app.config['SAML_IDP_SIGNON_URL'],
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'
            },
        }

        if app.config['SAML_IDP_LOGOUT_URL']:
            idp_data['singleLogoutService'] = {
                'url': app.config['SAML_IDP_LOGOUT_URL'],
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'
            }

        if app.config['SAML_IDP_CERT_FILE']:
            idp_data['x509cert'] = self._load_x509_for_saml(
                app.config['SAML_IDP_CERT_FILE'])
        if app.config['SAML_IDP_CERT']:
            idp_data['x509cert'] = app.config['SAML_IDP_CERT']

        # put it all together into the settings
        data = {
            'strict': True,  # must not be changed for security
            'debug': debug,
            'sp': sp_data,
            'idp': idp_data,
            'security': security_data,
        }

        # if SAML_RAW_JSON_SETTINGS is set, merge the settings in, doing one
        # level of deep merging.
        if app.config['SAML_RAW_JSON_SETTINGS']:
            logging.debug('overriding SAML settings from JSON')
            dict_deep_update(data, app.config['SAML_RAW_JSON_SETTINGS'])

        logging.debug('Rendered SAML settings: {!r}'.format(data))

        return data

    def log_in(self):
        """
        SAML log-in redirect.

        This method initiates the SAML authentication process by directing the
        browser to forward along an AuthNRequest to the IdP.

        A separate method handles the post-authentication callback, which will
        hit /v1/saml/consume, processed by consume_saml_assertion().
        """

        self_page = request.script_root + request.path

        return flask.redirect(self.login_redirect_url(return_to=self_page))

    def consume_saml_assertion(self):
        """
        This method is called in routes implementing a SAML attribute consumer
        service, which receives POST callbacks from the IdP after the user has
        authenticated.
        """

        auth = self._saml_auth()

        logging.debug('Processing SAML response')

        try:
            request_id = session['saml_authn_request_id']
        except KeyError:
            logging.warning('No saml_authn_request_id in session')
            resp = jsonify(errors=['invalid_response'],
                           message='SAML request failed',
                           reason=('No AuthNRequest ID from SP found '
                                   'to match with InResponseTo of response'))
            resp.status_code = 401
            return resp

        auth.process_response(request_id=request_id)

        if auth.get_errors():
            return self._render_saml_errors_json(auth)

        session.pop('saml_authn_request_id', None)

        if not auth.is_authenticated():
            logging.warning('auth.is_authenticated() => False')
            resp = jsonify(error='Not Authenticated')
            resp.status_code = 401
            return resp

        nameid = auth.get_nameid()
        logging.info('SAML user authenticated: {!r}'.format(nameid))

        attributes = auth.get_attributes()
        logging.info('SAML attributes: {!r}'.format(attributes))

        # normalize attributes by flattening single-item arrays
        for key, val in attributes.iteritems():
            if isinstance(val, list) and len(val) == 1:
                attributes[key] = val[0]

        session['saml_data'] = {
            'attrs': attributes,
            'nameid': nameid,
            'session_index': auth.get_session_index()
        }

        kwargs = {}

        # use email from attributes if present, else nameid
        kwargs['email'] = attributes.get('email', nameid)

        # use first_name, last_name if present
        for key, val in attributes.iteritems():
            if not getattr(key, 'lower', None):
                logging.error('Bad list attr {!r}'.format({key: val}))
            if key.lower() in ['firstname', 'first_name']:
                kwargs['first_name'] = val
            if key.lower() in ['lastname', 'last_name']:
                kwargs['last_name'] = val

        self.set_expiration()
        self.set_current_user(**kwargs)

        # success, redirect to RelayState if present or to /
        default_redirect = flask.url_for('index')
        redirect_url = request.form.get('RelayState', default_redirect)

        # avoid redirect loop
        # This is enough of a pain that it's not clear that we should even
        # support RelayState, but it seems good enough for now.
        if (redirect_url.endswith('/saml/consume') or
                redirect_url.endswith('/login')):
            redirect_url = default_redirect

        logging.debug("Redirecting to {0}".format(redirect_url))
        resp = flask.redirect(redirect_url)
        self.set_csrf_token(resp)
        return resp

    def log_out(self):
        """
        Initiate SAML SLO redirect.
        """

        logging.info('Initiating SAML logout request')

        try:
            current_nameid = self._current_user_nameid()
            current_session_id = self._current_saml_session_id()
        except errors.UserUnknownError:
            # must be already logged out
            logging.warning('No SAML data in session. Cannot SLO log out')
            self.clear_session()
            return self.redirect_to_goodbye()

        auth = self._saml_auth()

        # check for SLO support
        if not auth.get_slo_url():
            logging.warning('No SingleLogOut endpoint defined for IdP')
            self.clear_session()
            return self.redirect_to_goodbye()

        # TODO: decide whether to always clear the session here or not. Relying
        # on the IDP to redirect back to us hasn't been super reliable.
        self.clear_session()

        # redirect to SLO endpoint
        return flask.redirect(auth.logout(name_id=current_nameid,
                                          session_index=current_session_id))

    def log_out_callback(self, clear_session_on_errors=True):
        """
        Callback for SAML logout requests.

        Request must have a SAMLResponse GET parameter.

        On failure, renders error JSON. On success, redirects to /goodbye.
        """

        logging.debug('Processing SAML logout response')

        auth = self._saml_auth()
        errors = []

        auth.process_slo()
        errors = auth.get_errors()
        if errors:
            if clear_session_on_errors:
                self.clear_session()

            return self._render_saml_errors_json(auth)

        logging.info('SAML SLO request was successful')
        self.clear_session()

        return self.redirect_to_goodbye()

    def _saml_auth(self, req_dict=None):
        """
        Instantiate a OneLogin_Saml2_Auth object from the current request data
        (or from req_dict, if given).

        :param req_dict: A dict containing request information, optional.
        :type req_dict: dict

        :returns: a SAML Auth object
        :rtype: onelogin.saml2.auth.OneLogin_Saml2_Auth
        """
        if req_dict is None:
            req_dict = self._saml_req_dict_from_request()

        auth = OneLogin_Saml2_Auth(req_dict, self.saml_config)
        return auth

    def _saml_req_dict_from_request(self, flask_request=None):
        """
        Given a Flask Request object, return a dict of request information in
        the format that python-saml expects it for Auth objects.

        :param flask_request: A request object to pull data from.
        :type flask_request: flask.Request

        :returns: python-saml settings data
        :rtype: dict
        """
        if flask_request is None:
            flask_request = flask.request

        url_data = urlparse.urlparse(flask_request.url)

        if flask_request.scheme == 'https':
            https = 'on'
        elif app.debug and app.config['SAML_FAKE_HTTPS']:
            https = 'on'
        else:
            https = 'off'

        return {
            'https': https,
            'http_host': flask_request.host,
            'server_port': url_data.port,
            'script_name': flask_request.path,
            'get_data': flask_request.args.copy(),
            'post_data': flask_request.form.copy(),
        }

    def _current_user_nameid(self):
        """Get the SAML name_id of the currently logged in user."""
        if 'saml_data' in session:
            return session['saml_data']['nameid']
        else:
            raise errors.UserUnknownError('No SAML user data in session')

    def _current_saml_session_id(self):
        if 'saml_data' in session:
            return session['saml_data']['session_index']
        else:
            raise errors.UserUnknownError('No SAML user data in session')

    def generate_metadata(self):
        """
        Generate SAML metadata XML describing the service endpoints.
        """
        auth = self._saml_auth()
        settings = auth.get_settings()
        metadata = settings.get_sp_metadata()
        errors = settings.validate_metadata(metadata)

        if errors:
            resp = flask.make_response(errors.join(', '), 500)
            resp.headers['Content-Type'] = 'text/plain'
        else:
            resp = flask.make_response(metadata, 200)
            resp.headers['Content-Type'] = 'text/xml'

        return resp

    def _render_saml_errors_json(self, auth):
        """
        Log and handle SAML errors, returning as json.
        Return a Response object appropriate to return in a route handler.

        :param auth: The python-saml Auth class.
        :type auth: onelogin.saml2.auth.OneLogin_Saml2_Auth

        :returns: a flask response
        :rtype: flask.Response
        """

        logging.warn('Handling SAML errors')
        data = {
            'message': 'SAML request failed',
            'errors': auth.get_errors(),
            'reason': auth.get_last_error_reason(),
            'request_id': auth.get_last_request_id(),
        }
        logging.warn('Errors: {0}'.format(data))

        resp = jsonify(**data)
        resp.status_code = 500
        return resp

    def login_redirect_url(self, return_to='/', auth=None):
        if auth is None:
            auth = self._saml_auth()

        login_url = auth.login(return_to=return_to)

        # store request ID in session so we can verify
        session['saml_authn_request_id'] = auth.get_last_request_id()

        return login_url

# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """Secret."""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """Wraps text in minimal HTML tags."""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """Returns all the IP addressed comprised in a range."""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']                    
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),                    
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """Returns True if the provided token is valid."""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """Adds ACL to the request handler to ensure only valid users can use
  the handlers."""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message."""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """Verifies if the IP is whitelisted."""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """Verifies if the user is whitelisted."""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """Ensures the token is valid."""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name="whitelist" method="post">'
      'Domain: <input type="text" name="domain" /><br />'
      '<input type="hidden" name="token" value="%s" />'
      '<input type="submit" value="SUBMIT" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """Returns the token."""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """Adds example.com as a valid domain when testing."""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')



# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """Secret."""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """Wraps text in minimal HTML tags."""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """Returns all the IP addressed comprised in a range."""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']                    
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),                    
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """Returns True if the provided token is valid."""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """Adds ACL to the request handler to ensure only valid users can use
  the handlers."""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message."""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """Verifies if the IP is whitelisted."""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """Verifies if the user is whitelisted."""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """Ensures the token is valid."""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name="whitelist" method="post">'
      'Domain: <input type="text" name="domain" /><br />'
      '<input type="hidden" name="token" value="%s" />'
      '<input type="submit" value="SUBMIT" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """Returns the token."""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """Adds example.com as a valid domain when testing."""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')



from flask import Flask, render_template, jsonify, request, make_response, session, abort
from flask.ext.sqlalchemy import SQLAlchemy
from flask_mail import Message, Mail
from flask_login import LoginManager
from re import compile
import random, string
from base64 import *
from beaker.middleware import SessionMiddleware
from models import User, db

from bananas import bananas

app = Flask(__name__)


session_opts = {
    'session.type': 'file',
    'session.cookie_expires': 1800,
    'session.data_dir': '/tmp/cache/data',
    'session.lock_dir': '/tmp/cache/data',
    'session.auto': False,
}

app.wsgi_app = SessionMiddleware(app.wsgi_app, session_opts)

#import gamechange.admin
#from gamechange.decorators import *
import gamechange.error

app.config.from_envvar('FLASK_CONFIG')
db.init_app(app)
mail = Mail(app)

#login_manager = LoginManager()
#login_manager.setup_app(app)

app.register_blueprint(bananas, url_prefix="/bananas", config=app.config)

@app.route('/initDB')
def init_db():
    db.create_all()
    return "This is naughty and MUST not be in production!"

# @login_manager.user_loader
# def load_user(userid):
#     return User.get(userid)

@app.before_request
def csrf_protect():                    
    if request.method == "POST":
        token = session.pop('_csrf_token', None)                    
        if not token or token != request.form.get('_csrf_token'):                    
            abort(403)                    
        else:                     
            session['_csrf_token'] = generate_csrf_token()

def generate_csrf_token():
    if '_csrf_token' not in session:
        session['_csrf_token'] = ''.join(random.choice(string.ascii_uppercase + string.digits) for x in range(16))
    return session['_csrf_token']

app.jinja_env.globals['csrf_token'] = generate_csrf_token 

def hash(n):
  return ((0x0000FFFF & n)<<16) + ((0xFFFF0000 & n)>>16)

def send_email_to_user(user):
    msg = Message("Welcome to Game Change!", recipients=[user.email])
    msg.body = render_template('emails/signup.txt', email_key=urlsafe_b64encode(str(hash(user.id))), first_name=user.first_name, email_address=user.email)
    msg.html = render_template('emails/signup.html', email_key=urlsafe_b64encode(str(hash(user.id))), first_name=user.first_name, email_address=user.email)
    if not app.debug:
        mail.send(msg)
    else:                    
        app.logger.debug("E-mail to %s not sent, debug mode. \n %s", user.email, msg.body)  
    

@app.route("/")
def index():
    return render_template('index.html')

@app.route("/signup", methods=['POST'])
def signupFormSubmit():
    first_name = request.form.get('first_name')
    last_name = request.form.get('last_name')
    email = request.form.get('email')
    user = User(first_name,last_name,email)
    if user.isValid():
        db.session.add(user)
        db.session.commit()
        #email the user!
        send_email_to_user(user)
        return jsonify(status="200", _csrf_token=session.get('_csrf_token'))

    else:                    
        resp = make_response(jsonify(errors=user.error, _csrf_token=session.get('_csrf_token')), 400)
        return resp

@app.route("/email/verify/", defaults={"id_hash": None})
@app.route("/email/verify/<id_hash>")
def email_verify(id_hash):
    try:
        id = hash(int(urlsafe_b64decode(str(id_hash))))
    except (TypeError, ValueError):
        #Error, invalid hash. Tell the user to try again.
        return render_template('signup_unverified.html')

    u = User.query.get(id)
    if u != None:
        u.verified = True
        db.session.commit()
        return render_template('signup_verified.html', first_name=u.first_name, last_name=u.last_name, email=u.email)

    return render_template('signup_unverified.html')


@app.route("/email/resend", methods=['POST'])
def email_resend():
    error = dict()
    email = request.form.get('email')
    u = User.query.filter_by(email=request.form.get('email')).first()
    if '@' not in email:
        error['email'] = "Please check your e-mail address is valid."
        return make_response(jsonify(errors=error, _csrf_token=session.get('_csrf_token')), 400)
    if u:
        send_email_to_user(u)
        return jsonify(status="200", _csrf_token=session.get('_csrf_token'))
    else:                    
        return make_response(jsonify(errors="User not found",_csrf_token=session.get('_csrf_token')), 404)


@app.route("/email/unsubscribe/", defaults={"email": None}, methods=['GET','POST'])
@app.route("/email/unsubscribe/<email>", methods=['GET'])
def email_unsubscribe(email):
    show_form = True
    if not (request.form.get('email') == None):
        email = request.form.get('email')
        
    if email == None:
        #email address empty, so return here
        msg = 'You need to enter your email address to unsubscribe'
        pass
    else:                    
        results = User.query.filter_by(email=email)
        if results.count() != 1:
            #email address not found, so return here
            msg = 'The given email address was not in our system'
            pass
        else:                    
            show_form = False
            results.first().subscribed = False
            db.session.commit()
            msg = 'We\'ll  stop  pestering you at ' + email
    return render_template('unsubscribe.html', msg=msg, show_form = show_form)

from django.http import HttpResponse
from django.template.response import TemplateResponse
from django.shortcuts import render, redirect                    
from pymongo import MongoClient
from django.core.mail import send_mail
import datetime
import random
import string
import json
client = MongoClient()
db = client.freemail_database

ALPHABET = string.ascii_letters + string.digits

import settings

import os
SALT = os.environ.get('DJANGO_SALT')

import hashlib

def index(request):
    # return HttpResponse(settings.TEMPLATE_DIRS)
    return render(request, 'index.html')                    

def addUser(request, gmail, fb):
    emails = db.emails
    new_email = { "gmail" : gmail,
                  "facebook" : fb }
    emails.insert(new_email)
    return HttpResponse("Gmail is: " + gmail + ". Facebook is: " + fb)

def getAllUsers(request):
    all_emails = ["facebook: '" + email[u'facebook'] + "' and gmail: '" + email[u'gmail'] + "'"
        for email in db.emails.find()]
    return HttpResponse('\n\n'.join(all_emails))
    
def sendConf(request):
    confs = db.confs
    new_conf = { "email" : email,
                 "hash"  : hashlib.sha1(email + SALT).hexdigest() }
    confs.insert(new_conf)
    send_mail('[FreeMail] Email Confirmation',
              'Confirm your account by clicking on the following link: ' + '<a href="localhost:5000/confirm/' + email + '/' + new_conf["hash"] + '">Here</a>',
              'contact@freemail.com',
              [email],
              fail_silently=False)
    return HttpResponse('Confirmation page created')

def generate_hash(input_str):
    return hashlib.sha1(input_str).hexdigest()

def generate_salt():
    chars = [random.choice(ALPHABET) for _ in xrange(16)]
    return "".join(chars)


def confirmation(request):
    if request.method == 'POST':
        email = request.POST["email"]
        password = request.POST["password"]
        confs = db.confs
        new_conf = { "email" : email,
                     "date" : datetime.datetime.utcnow(),
                     "hash"  : generate_hash(password + generate_salt())}
        confs.insert(new_conf)
    return HttpResponse(json.dumps(new_conf), content_type="application/json")
        

def recieveEmailINTHEASS(request):
    request["from"] = US
    sendgrid[send-email](request)
    return HttpResponse("All Good")

def testPath(request, path):
    return HttpResponse(path)

def confirm(request, email, hashed):
    return redirect('/index.html?email=' + email + '&hash=' + hashed)
    # confs = db.confs
    # conf = confs.find_one({"email": email, "hash": hashed})

# Copyright 2009-2010, Ka-Ping Yee
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from google.appengine.ext import db
import logging

ROLES = ['user', 'editor', 'superuser']

class Authorization(db.Model):
    timestamp = db.DateTimeProperty(auto_now_add=True)
    description = db.StringProperty(required=True)
    email = db.StringProperty()
    user_id = db.StringProperty()
    token = db.StringProperty()
    # user roles are in the format: country_code:role
    # where role is one of ROLES
    # an empty country_code means the user has the role for
    # all countries
    user_roles = db.StringListProperty()
    requested_roles = db.StringListProperty()

def check_token(token):
    return Authorization.all().filter('token =', token).get()

def check_email(email):
    return Authorization.all().filter('email =', email).get()

def check_user_id(user_id):
    return Authorization.all().filter('user_id =', user_id).get()

def check_request(request, user):
    if request.get('token'):                    
        return check_token(request.get('token'))                    
    if user:
        return check_email(user.email()) or check_user_id(user.user_id())

def check_user_role(auth, role, cc):
    """Return True if the auth user has the given role for the given country"""
    return auth and ("%s:%s" % (cc or '',role) in auth.user_roles or
                     ":%s" % role in auth.user_roles)

def check_and_log(request, user):
    auth = check_request(request, user)
    logging.info(
        'access.py: ' +
        (auth and 'authorized %s' % auth.description or 'not authorized') +
        ' (token=%r, user=%r)' % (request.get('token'), user and user.email()))                    
    if not auth and user:
        # we create an auth for a login user with no roles and don't save it
        auth = Authorization(description=user.nickname(),
                             email=user.email())
    return auth

# Copyright 2009-2010 by Ka-Ping Yee
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import model
import utils
from utils import DateTime, ErrorMessage, Redirect
from utils import db, get_message, html_escape, users
from access import check_user_role                    

# ==== Form-field generators and parsers for each attribute type =============

class AttributeType:
    input_size = 10

    def text_input(self, name, value):
        """Generates a text input field."""
        if isinstance(value, unicode):
            pass
        elif isinstance(value, str):
            value = value.decode('utf-8')
        elif value is not None:
            value = str(value)
        else:
            value = ''
        return u'<input name="%s" value="%s" size=%d>' % (
            html_escape(name), html_escape(value), self.input_size)

    def make_input(self, version, name, value, attribute=None):
        """Generates the HTML for an input field for the given attribute."""
        return self.text_input(name, value)

    def parse_input(self, report, name, value, request, attribute):
        """Adds an attribute to the given Report based on a query parameter."""
        setattr(report, name, value)

class StrAttributeType(AttributeType):
    input_size = 40

class TextAttributeType(AttributeType):
    def make_input(self, version, name, value, attribute):
        return '<textarea name="%s" rows=5 cols=40>%s</textarea>' % (
            html_escape(name), html_escape(value or ''))

    def parse_input(self, report, name, value, request, attribute):
        setattr(report, name, db.Text(value))

class ContactAttributeType(AttributeType):
    input_size = 30

    def make_input(self, version, name, value, attribute):
        contact_name, contact_phone, contact_email = (
            (value or '').split('|') + ['', '', ''])[:3]
        return '''<table>
                    <tr><td class="label">%s</td><td>%s</td></tr>
                    <tr><td class="label">%s</td><td>%s</td></tr>
                    <tr><td class="label">%s</td><td>%s</td></tr>
                  </table>''' % (
            _('Name'), self.text_input(name + '.name', contact_name),
            _('Phone'), self.text_input(name + '.phone', contact_phone),
            _('E-mail'), self.text_input(name + '.email', contact_email),
        )

    def parse_input(self, report, name, value, request, attribute):
        contact = (request.get(name + '.name', '') + '|' +
                   request.get(name + '.phone', '') + '|' +
                   request.get(name + '.email', ''))
        # make sure we put empty string of all three are empty
        contact = contact != '||' and contact or ''
        setattr(report, name, contact)

class DateAttributeType(AttributeType):
    input_size = 10

    def parse_input(self, report, name, value, request, attribute):
        if value.strip():
            try:
                year, month, day = map(int, value.split('-'))
                setattr(report, name, DateTime(year, month, day))
            except (TypeError, ValueError):
                raise ErrorMessage(
                    400, _('Invalid date: %r (need YYYY-MM-DD format)') % value)
        else:
            setattr(report, name, None)

class IntAttributeType(AttributeType):
    input_size = 10

    def parse_input(self, report, name, value, request, attribute):
        if value:
            value = int(float(value))
        else:
            value = None
        setattr(report, name, value)

class FloatAttributeType(IntAttributeType):
    def make_input(self, version, name, value, attribute):
        Attribute.make_input(self, version, name, '%g' % value, attribute)

    def parse_input(self, report, name, value, request, attribute):
        if value:
            value = float(value)
        else:
            value = None
        setattr(report, name, value)

class BoolAttributeType(AttributeType):
    def make_input(self, version, name, value, attribute):
        options = []
        if value == True:
            value = 'TRUE'
        elif value == False:
            value = 'FALSE'
        else:
            value = ''
        for choice, title in [
            ('', _('(unspecified)')), ('TRUE', _('yes')), ('FALSE', _('no'))]:
            selected = (value == choice) and 'selected' or ''
            options.append('<option value="%s" %s>%s</option>' %
                           (choice, selected, title))
        return '<select name="%s">%s</select>' % (
            html_escape(name), ''.join(options))

    def parse_input(self, report, name, value, request, attribute):
        if value:
            value = (value == 'TRUE')
        else:
            value = None
        setattr(report, name, value)

class ChoiceAttributeType(AttributeType):
    def make_input(self, version, name, value, attribute):
        options = []
        if value is None:
            value = ''
        for choice in [''] + attribute.values:
            message = get_message(version, 'attribute_value', choice)
            title = html_escape(message or _('(unspecified)'))
            selected = (value == choice) and 'selected' or ''
            options.append('<option value="%s" %s>%s</option>' %
                           (choice, selected, title))
        return '<select name="%s">%s</select>' % (
            html_escape(name), ''.join(options))

class MultiAttributeType(AttributeType):
    def make_input(self, version, name, value, attribute):
        if value is None:
            value = []
        checkboxes = []
        for choice in attribute.values:
            message = get_message(version, 'attribute_value', choice)
            title = html_escape(message or _('(unspecified)'))
            checked = (choice in value) and 'checked' or ''
            id = name + '.' + choice
            checkboxes.append(
                ('<input type=checkbox name="%s" id="%s" %s>' +
                 '<label for="%s">%s</label>') % (id, id, checked, id, title))
        return '<br>\n'.join(checkboxes)

    def parse_input(self, report, name, value, request, attribute):
        value = []
        for choice in attribute.values:
            if request.get(name + '.' + choice):
                value.append(choice)
        setattr(report, name, value or None)

ATTRIBUTE_TYPES = {
    'str': StrAttributeType(),
    'text': TextAttributeType(),
    'contact': ContactAttributeType(),
    'date': DateAttributeType(),
    'int': IntAttributeType(),
    'float': FloatAttributeType(),
    'bool': BoolAttributeType(),
    'choice': ChoiceAttributeType(),
    'multi': MultiAttributeType(),
}

def make_input(version, report, attribute):
    """Generates the HTML for an input field for the given attribute."""
    name = attribute.key().name()
    return ATTRIBUTE_TYPES[attribute.type].make_input(
        version, name, getattr(report, name, None), attribute)

def parse_input(report, request, attribute):
    """Adds an attribute to the given Report based on a query parameter."""
    name = attribute.key().name()
    return ATTRIBUTE_TYPES[attribute.type].parse_input(
        report, name, request.get(name, None), request, attribute)


# ==== Handler for the edit page =============================================

class Edit(utils.Handler):
    def init(self):
        """Checks for authentication and sets up self.version, self.facility,
        self.facility_type, and self.attributes based on the query params."""

        self.require_user_role('user', self.params.cc)

        try:
            self.version = utils.get_latest_version(self.params.cc)
        except:
            raise ErrorMessage(404, _('Invalid or missing country code.'))
        self.facility = model.Facility.get_by_key_name(
            self.params.facility_name, self.version)
        if not self.facility:
            raise ErrorMessage(404, _('Invalid or missing facility name.'))
        self.facility_type = model.FacilityType.get_by_key_name(
            self.facility.type, self.version)
        self.attributes = dict(
            (a.key().name(), a)
            for a in model.Attribute.all().ancestor(self.version))
        self.readonly_attribute_names = ['healthc_id',]

    def get(self):
        self.init()
        fields = []
        readonly_fields = [{
            'name': 'ID',
            'value': self.params.facility_name
        }]

        report = (model.Report.all()
            .ancestor(self.version)
            .filter('facility_name =', self.params.facility_name)
            .order('-timestamp')).get()
        for name in self.facility_type.attribute_names:
            attribute = self.attributes[name]
            if name in self.readonly_attribute_names:
                readonly_fields.append({
                    'name': get_message(self.version, 'attribute_name', name),
                    'value': getattr(report, name, None)
                })
            else:
                fields.append({
                    'name': get_message(self.version, 'attribute_name', name),
                    'type': attribute.type,
                    'input': make_input(self.version, report, attribute)
                })

        self.render('templates/edit.html',
            facility=self.facility, fields=fields,                    
            readonly_fields=readonly_fields, params=self.params,
            authorization=self.auth and self.auth.description or 'anonymous',
            logout_url=users.create_logout_url('/'))

    def post(self):
        self.init()
        logging.info("record by user: %s"%users.get_current_user())                    
        last_report = (model.Report.all()
            .ancestor(self.version)
            .filter('facility_name =', self.params.facility_name)
            .order('-timestamp')).get()
        report = model.Report(
            self.version,
            facility_name=self.facility.key().name(),
            date=utils.Date.today(),
            user=users.get_current_user(),
        )
        for name in self.facility_type.attribute_names:
            if name in self.readonly_attribute_names:
                setattr(report, name, getattr(last_report, name, None))
            else:
                attribute = self.attributes[name]
                parse_input(report, self.request, attribute)
        report.put()
        if self.params.embed:
            self.write(_('Record updated.'))
        else:
            raise Redirect('/')

if __name__ == '__main__':
    utils.run([('/edit', Edit)], debug=True)

'''
Author; Garrett Breeden
Version: 1.0
    1. Integrated SeleniumDriver into GUI 
        - Data should now pass from GUI -> Selenium
    2. Updated input field classes
    3. Small GUI Tweaks

Version: 1.2
    1. Corrected issue with data being passed to Selenium from GUI


TO ONLY BE USED BY L2 AND L3 @ PARTECH
'''
from Tkinter import *                    
from SeleniumDriver import *
import pyperclip
# import ttk               ONLY GOOD FOR STYLE


class JiraGeneratorWindow():
    username = None
    password = None

    summary = None
    clarify = None
    details = None

    def __init__(self, master, selenium):
        self.master = master
        master.title("Jira Automation")
        self.firefox = selenium
        #        #
        # CONFIG #
        #        #
        self.colorWhiteText = '#FFF'
        self.colorGreyBackground = '#708090'
        #           #
        # </CONFIG> #
        #           #
        empty_spacer_1 = Label(master, text=" ")
        empty_spacer_1.grid(column=0, row=0)

        self.login_button = Button(
            master, text="JIRA Login", command=self.setCredentials)
        self.login_button.grid(sticky="E", column=3, row=0)

        self.summary_static_text = Label(
            master, text="Input Sync Summary:")
        self.summary_static_text.grid(columnspan=4, sticky='W', row=1)

        self.summary_field = Entry(root, width=61,)
        self.summary_field.configure(
            background=self.colorGreyBackground, foreground=self.colorWhiteText)
        self.summary_field.grid(columnspan=4, column=0, row=2, sticky="W")

        empty_spacer_2 = Label(master, text=" ")
        empty_spacer_2.grid(column=0, row=3)

        self.clarify_static_text = Label(
            master, text="Input Case Number:")
        self.clarify_static_text.grid(columnspan=4, sticky='W', row=4)

        self.clarify_field = Entry(root, width=61)
        self.clarify_field.configure(
            background=self.colorGreyBackground, foreground=self.colorWhiteText)
        self.clarify_field.grid(column=0, row=5, columnspan=4, sticky="W")

        empty_spacer_3 = Label(master, text=" ")
        empty_spacer_3.grid(column=0, row=6)

        self.detailed_static_text = Label(
            master, text="Input Detailed Information")
        self.detailed_static_text.grid(columnspan=4, sticky="W", row=7)

        self.detailed_field = Text(root, height=35, width=79)
        self.detailed_field.configure(
            background=self.colorGreyBackground, foreground=self.colorWhiteText)
        self.detailed_field.grid(columnspan=4, row=8, column=0, sticky="W")

        self.run_split_button = Button(
            master, text="Create JIRA", command=self.createCase)
        self.run_split_button.grid(row=10, column=1, sticky="W")

        self.close_button = Button(master, text="Close", command=master.quit)
        self.close_button.grid(row=10, column=2, sticky="E")

    # Create TopLevel Pane to Input Credentials
    def setCredentials(self):
        self.win = Toplevel()
        self.win.title = "Input JIRA Login"

        self.username_static_text = Label(self.win, text="Username:")
        self.username_static_text.grid(column=0, row=0, sticky="E")

        self.username_field = Entry(self.win)
        self.username_field.configure(
            background=self.colorGreyBackground, foreground=self.colorWhiteText)
        self.username_field.grid(column=1, row=0, sticky="W")

        self.password_static_text = Label(self.win, text="Password:")
        self.password_static_text.grid(column=0, row=1, sticky="E")

        self.password_field = Entry(self.win, show="*")
        self.password_field.configure(
            background=self.colorGreyBackground, foreground=self.colorWhiteText)
        self.password_field.grid(column=1, row=1, sticky="W")

        self.submit_button = Button(self.win, text="Save Credentials", command=self.setLoginInfo)
        self.submit_button.grid(column=1, row=2, columnspan=2)

    # Set the login information to the class member
    def setLoginInfo(self):
        self.password = self.password_field.get()
        self.username = self.username_field.get()
        self.destroy_window(self.win)

    # Error popup notification function
    def errorNotification(self, error_message):
        self.error_window = Toplevel()
        self.error_window.title = "ERROR - PLEASE READ"
        error_message_text = Message(
            self.error_window, text=error_message, width=500)                    
        error_message_text.grid(row=0, column=0, columnspan=3)

        close_button_error = Button(
            self.error_window, text="Ok", command=lambda: self.error_window.destroy())
        close_button_error.grid(row=1, column=1)

    # closes passed window
    def destroy_window(self, window):
        window.destroy()

    def createCase(self):
        # Ensures JIRA button has been at least clicked before allowing script to execute.
        if(self.password == None or self.username == None or self.password == ' ' or self.username == ' '):
            self.errorNotification(
                "Please login to JIRA first")
        else:
            self.firefox.loadPage("https://devops.partech.com/jira/login.jsp", "JIRA")
            self.firefox.login(self.username, self.password)
            self.firefox.createNewTicket()
            self.firefox.inputDataToCase(self.summary_field.get(), self.detailed_field.get("1.0", END))
            #TODO: Link GUI Input to Selenium.    


if(__name__ == "__main__"):
    root = Tk()
    _selenium = SeleniumDriver()
    main_GUI = JiraGeneratorWindow(root, _selenium)
    root.mainloop()

    # <div class="aui-message aui-message-success"
    # <a class="issue-created-key issue-link" data-issue


#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import ast
import io
import os
import sys
import threading
import random
import time

from cms import config, ServiceCoord, get_service_address                    
from cms.db import Contest, SessionGen

import cmstestsuite.web
from cmstestsuite.web import Browser
from cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \                    
    TaskRequest, TaskStatementRequest, SubmitRandomRequest


cmstestsuite.web.debug = True


class RequestLog(object):

    def __init__(self, log_dir=None):
        self.total = 0
        self.success = 0
        self.failure = 0
        self.error = 0
        self.undecided = 0
        self.total_time = 0.0
        self.max_time = 0.0

        self.log_dir = log_dir
        if self.log_dir is not None:
            try:
                os.makedirs(self.log_dir)
            except OSError:
                pass

    def print_stats(self):
        print("TOTAL:          %5d" % (self.total), file=sys.stderr)
        print("SUCCESS:        %5d" % (self.success), file=sys.stderr)
        print("FAIL:           %5d" % (self.failure), file=sys.stderr)
        print("ERROR:          %5d" % (self.error), file=sys.stderr)
        print("UNDECIDED:      %5d" % (self.undecided), file=sys.stderr)
        print("Total time:   %7.3f" % (self.total_time), file=sys.stderr)
        print("Average time: %7.3f" % (self.total_time / self.total),
              file=sys.stderr)
        print("Max time:     %7.3f" % (self.max_time), file=sys.stderr)

    def merge(self, log2):
        self.total += log2.total
        self.success += log2.success
        self.failure += log2.failure
        self.error += log2.error
        self.undecided += log2.undecided
        self.total_time += log2.total_time
        self.max_time = max(self.max_time, log2.max_time)

    def store_to_file(self, request):
        if self.log_dir is None:
            return

        filename = "%s_%s.log" % (request.start_time,
                                  request.__class__.__name__)
        filepath = os.path.join(self.log_dir, filename)
        linkpath = os.path.join(self.log_dir, request.__class__.__name__)
        with io.open(filepath, 'wt', encoding='utf-8') as fd:
            request.store_to_file(fd)
        try:
            os.remove(linkpath)
        except OSError:
            pass
        os.symlink(filename, linkpath)


class ActorDying(Exception):
    """Exception to be raised when an Actor is going to die soon. See
    Actor class.

    """
    pass


class Actor(threading.Thread):
    """Class that simulates the behaviour of a user of the system. It
    performs some requests at randomized times (checking CMS pages,
    doing submissions, ...), checking for their success or failure.

    The probability that the users doing actions depends on the value
    specified in an object called "metrics".

    """

    def __init__(self, username, password, metrics, tasks,
                 log=None, base_url=None, submissions_path=None):
        threading.Thread.__init__(self)

        self.username = username
        self.password = password
        self.metrics = metrics
        self.tasks = tasks
        self.log = log
        self.base_url = base_url
        self.submissions_path = submissions_path

        self.name = "Actor thread for user %s" % (self.username)

        self.browser = Browser()
        self.die = False

    def run(self):
        try:
            print("Starting actor for user %s" % (self.username),
                  file=sys.stderr)
            self.act()

        except ActorDying:
            print("Actor dying for user %s" % (self.username), file=sys.stderr)

    def act(self):
        """Define the behaviour of the actor. Subclasses are expected
        to overwrite this stub method properly.

        """
        raise Exception("Not implemented. Please subclass Action"
                        "and overwrite act().")

    def do_step(self, request):
        self.wait_next()
        self.log.total += 1
        try:
            request.execute()
        except Exception as exc:
            print("Unhandled exception while executing the request: %s" % exc,
                  file=sys.stderr)
            return
        self.log.__dict__[request.outcome] += 1
        self.log.total_time += request.duration
        self.log.max_time = max(self.log.max_time, request.duration)
        self.log.store_to_file(request)

    def wait_next(self):
        """Wait some time. At the moment it waits c*X seconds, where c
        is the time_coeff parameter in metrics and X is an
        exponentially distributed random variable, with parameter
        time_lambda in metrics.

        The total waiting time is divided in lots of little sleep()
        call each one of 0.1 seconds, so that the waiting gets
        interrupted if a die signal arrives.

        If a die signal is received, an ActorDying exception is
        raised.

        """
        SLEEP_PERIOD = 0.1
        time_to_wait = self.metrics['time_coeff'] * \
            random.expovariate(self.metrics['time_lambda'])
        sleep_num = int(time_to_wait / SLEEP_PERIOD)
        remaining_sleep = time_to_wait - (sleep_num * SLEEP_PERIOD)
        for i in xrange(sleep_num):                    
            time.sleep(SLEEP_PERIOD)
            if self.die:
                raise ActorDying()
        time.sleep(remaining_sleep)
        if self.die:
            raise ActorDying()

    def login(self):
        """Log in and check to be logged in."""
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=False,
                                     base_url=self.base_url))                    
        self.do_step(LoginRequest(self.browser,                    
                                  self.username,                    
                                  self.password,                    
                                  base_url=self.base_url))                    
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=True,
                                     base_url=self.base_url))                    


class RandomActor(Actor):

    def act(self):
        self.login()

        while True:
            choice = random.random()
            task = random.choice(self.tasks)
            if choice < 0.1 and self.submissions_path is not None:
                self.do_step(SubmitRandomRequest(
                    self.browser,
                    task,
                    base_url=self.base_url,
                    submissions_path=self.submissions_path))
            elif choice < 0.6 and task[2] != []:
                self.do_step(TaskStatementRequest(self.browser,
                                                  task[1],
                                                  random.choice(task[2]),
                                                  base_url=self.base_url))                    
            else:
                self.do_step(TaskRequest(self.browser,
                                         task[1],
                                         base_url=self.base_url))                    


class SubmitActor(Actor):

    def act(self):
        self.login()

        # Then keep forever stumbling across user pages
        while True:
            task = random.choice(self.tasks)
            self.do_step(SubmitRandomRequest(
                self.browser,
                task,
                base_url=self.base_url,
                submissions_path=self.submissions_path))


def harvest_contest_data(contest_id):
    """Retrieve the couples username, password and the task list for a
    given contest.

    contest_id (int): the id of the contest we want.
    return (tuple): the first element is a dictionary mapping
                    usernames to passwords; the second one is the list
                    of the task names.

    """
    users = {}
    tasks = []
    with SessionGen() as session:
        contest = Contest.get_from_id(contest_id, session)
        for participation in contest.participations:
            user = participation.user
            users[user.username] = {'password': user.password}
        for task in contest.tasks:
            tasks.append((task.id, task.name, task.statements.keys()))
    return users, tasks


DEFAULT_METRICS = {'time_coeff': 10.0,
                   'time_lambda': 2.0}


def main():
    parser = argparse.ArgumentParser(description="Stress tester for CMS")
    parser.add_argument(
        "-c", "--contest-id", action="store", type=int, required=True,
        help="ID of the contest to test against")
    parser.add_argument(
        "-n", "--actor-num", action="store", type=int,
        help="the number of actors to spawn")
    parser.add_argument(
        "-s", "--sort-actors", action="store_true",
        help="sort usernames alphabetically before slicing them")
    parser.add_argument(
        "-u", "--base-url", action="store", type=utf8_decoder,
        help="base URL for placing HTTP requests")                    
    parser.add_argument(
        "-S", "--submissions-path", action="store", type=utf8_decoder,
        help="base path for submission to send")
    parser.add_argument(
        "-p", "--prepare-path", action="store", type=utf8_decoder,
        help="file to put contest info to")
    parser.add_argument(
        "-r", "--read-from", action="store", type=utf8_decoder,
        help="file to read contest info from")
    parser.add_argument(
        "-t", "--time-coeff", action="store", type=float, default=10.0,
        help="average wait between actions")
    parser.add_argument(
        "-o", "--only-submit", action="store_true",
        help="whether the actor only submits solutions")
    args = parser.parse_args()

    # If prepare_path is specified we only need to save some useful
    # contest data and exit.
    if args.prepare_path is not None:
        users, tasks = harvest_contest_data(args.contest_id)
        contest_data = dict()
        contest_data['users'] = users
        contest_data['tasks'] = tasks
        with io.open(args.prepare_path, "wt", encoding="utf-8") as file_:
            file_.write("%s" % contest_data)
        return

    assert args.time_coeff > 0.0
    assert not (args.only_submit and args.submissions_path == "")

    users = []
    tasks = []

    # If read_from is not specified, read contest data from database
    # if it is specified - read contest data from the file
    if args.read_from is None:
        users, tasks = harvest_contest_data(args.contest_id)
    else:
        with io.open(args.read_from, "rt", encoding="utf-8") as file_:
            contest_data = ast.literal_eval(file_.read())
        users = contest_data['users']
        tasks = contest_data['tasks']

    if args.actor_num is not None:
        user_items = users.items()
        if args.sort_actors:
            user_items.sort()
        else:
            random.shuffle(user_items)
        users = dict(user_items[:args.actor_num])

    # If the base URL is not specified, we try to guess it; anyway,
    # the guess code isn't very smart...
    if args.base_url is not None:
        base_url = args.base_url
    else:
        base_url = "http://%s:%d/" % \
            (get_service_address(ServiceCoord('ContestWebServer', 0))[0],
             config.contest_listen_port[0])

    metrics = DEFAULT_METRICS
    metrics["time_coeff"] = args.time_coeff
    actor_class = RandomActor
    if args.only_submit:
        actor_class = SubmitActor
    actors = [actor_class(username, data['password'], metrics, tasks,
                          log=RequestLog(log_dir=os.path.join('./test_logs',
                                                              username)),
                          base_url=base_url,
                          submissions_path=args.submissions_path)
              for username, data in users.iteritems()]
    for actor in actors:                    
        actor.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Taking down actors", file=sys.stderr)
        for actor in actors:                    
            actor.die = True

    # Uncomment to turn on some memory profiling.
    # from meliae import scanner
    # print("Dumping")
    # scanner.dump_all_objects('objects.json')
    # print("Dump finished")

    finished = False                    
    while not finished:                    
        for actor in actors:                    
            actor.join()                    

    print("Test finished", file=sys.stderr)

    great_log = RequestLog()
    for actor in actors:                    
        great_log.merge(actor.log)

    great_log.print_stats()


if __name__ == '__main__':
    main()

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2013-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2013-2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
# Copyright  2014 Luca Versari <veluca93@gmail.com>
# Copyright  2014 William Di Luigi <williamdiluigi@gmail.com>
# Copyright  2016 Peyman Jabbarzade Ganje <peyman.jabarzade@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import io
import json
import logging
import os
import re
import subprocess
import sys
import time

import requests

from cmstestsuite.web import Browser
from cmstestsuite.web.AWSRequests import \
    AWSLoginRequest, AWSSubmissionViewRequest, AWSUserTestViewRequest
from cmstestsuite.web.CWSRequests import \
    CWSLoginRequest, SubmitRequest, SubmitUserTestRequest


logger = logging.getLogger(__name__)


# CONFIG is populated by our test script.
CONFIG = {
    'VERBOSITY': 0,
}


# cms_config holds the decoded-JSON of the cms.conf configuration file.
cms_config = None


# List of users and tasks we created as part of the test.
created_users = {}
created_tasks = {}


# Information on the administrator running the tests.
admin_info = {}


# Base URLs for AWS and CWS
AWS_BASE_URL = "http://localhost:8889/"                    
CWS_BASE_URL = "http://localhost:8888/"                    


# Persistent browsers to access AWS and CWS.
aws_browser = None
cws_browser = None


def get_aws_browser():
    global aws_browser
    if aws_browser is None:
        aws_browser = Browser()

        lr = AWSLoginRequest(aws_browser,
                             admin_info["username"], admin_info["password"],
                             base_url=AWS_BASE_URL)
        aws_browser.login(lr)
    return aws_browser


def get_cws_browser(user_id):
    global cws_browser
    if cws_browser is None:
        cws_browser = Browser()
        username = created_users[user_id]['username']
        password = created_users[user_id]['password']
        lr = CWSLoginRequest(
            cws_browser, username, password, base_url=CWS_BASE_URL)
        cws_browser.login(lr)
    return cws_browser


class FrameworkException(Exception):
    pass


def read_cms_config():
    global cms_config
    with io.open("%(CONFIG_PATH)s" % CONFIG, "rt") as f:
        cms_config = json.load(f)


def get_cms_config():
    if cms_config is None:
        read_cms_config()
    return cms_config


def sh(cmdline, ignore_failure=False):
    """Execute a simple shell command.

    If cmdline is a string, it is passed to sh -c verbatim.  All escaping must
    be performed by the user. If cmdline is an array, then no escaping is
    required.

    """
    if CONFIG["VERBOSITY"] >= 1:
        # TODO Use shlex.quote in Python 3.3.
        logger.info('$ ' + ' '.join(cmdline))
    kwargs = dict()
    if CONFIG["VERBOSITY"] >= 3:
        # TODO Use subprocess.DEVNULL in Python 3.3.
        kwargs["stdout"] = io.open(os.devnull, "wb")
        kwargs["stderr"] = subprocess.STDOUT
    ret = subprocess.call(cmdline, **kwargs)
    if not ignore_failure and ret != 0:
        raise FrameworkException(
            # TODO Use shlex.quote in Python 3.3.
            "Execution failed with %d/%d. Tried to execute:\n%s\n" %
            (ret & 0xff, ret >> 8, ' '.join(cmdline)))


def configure_cms(options):
    """Creates the cms.conf file, setting any parameters as requested.

    The parameters are substituted in textually, and thus this may be
    quite fragile.

    options (dict): mapping from parameter to textual JSON argument.

    """
    with io.open("%(TEST_DIR)s/config/cms.conf.sample" % CONFIG,
                 "rt", encoding="utf-8") as in_f:
        lines = in_f.readlines()

    unset = set(options.keys())
    for i, line in enumerate(lines):
        g = re.match(r'^(\s*)"([^"]+)":', line)
        if g:
            whitespace, key = g.groups()
            if key in unset:
                lines[i] = '%s"%s": %s,\n' % (whitespace, key, options[key])
                unset.remove(key)

    with io.open("%(CONFIG_PATH)s" % CONFIG, "wt", encoding="utf-8") as out_f:
        for l in lines:
            out_f.write(l)

    if unset:
        print("These configuration items were not set:")
        print("  " + ", ".join(sorted(list(unset))))

    # Load the config database.
    read_cms_config()


def combine_coverage():
    logger.info("Combining coverage results.")
    sh([sys.executable, "-m", "coverage", "combine"])


def initialize_aws(rand):
    """Create an admin and logs in

    rand (int): some random bit to add to the admin username.

    """
    logger.info("Creating admin...")
    admin_info["username"] = "admin%s" % rand
    admin_info["password"] = "adminpwd"
    sh([sys.executable, "cmscontrib/AddAdmin.py", "%(username)s" % admin_info,
        "-p", "%(password)s" % admin_info])


def admin_req(path, args=None, files=None):
    browser = get_aws_browser()
    return browser.do_request(AWS_BASE_URL + path, args, files)                    


def get_tasks():
    '''Return a list of existing tasks, returned as a dictionary of
      'taskname' => { 'id': ..., 'title': ... }

    '''
    r = admin_req('tasks')
    groups = re.findall(r'''
        <tr>\s*
        <td><a\s+href="./task/(\d+)">(.*)</a></td>\s*
        <td>(.*)</td>\s*
        ''', r.text, re.X)
    tasks = {}
    for g in groups:
        id, name, title = g
        id = int(id)
        tasks[name] = {
            'title': title,
            'id': id,
        }

    return tasks


def get_users(contest_id):
    '''Return a list of existing users, returned as a dictionary of
      'username' => { 'id': ..., 'firstname': ..., 'lastname': ... }

    '''
    r = admin_req('contest/' + str(contest_id) + '/users')
    groups = re.findall(r'''
        <tr> \s*
        <td> \s* (.*) \s* </td> \s*
        <td> \s* (.*) \s* </td> \s*
        <td><a\s+href="./user/(\d+)">(.*)</a></td>
    ''', r.text, re.X)
    users = {}
    for g in groups:
        firstname, lastname, id, username = g
        id = int(id)
        users[username] = {
            'firstname': firstname,
            'lastname': lastname,
            'id': id,
        }

    return users


def add_contest(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "description": kwargs.get('description'),
    }
    resp = admin_req('contests/add', args=add_args)
    # Contest ID is returned as HTTP response.
    page = resp.text
    match = re.search(
        r'<form enctype="multipart/form-data" action="../contest/([0-9]+)" '
        'method="POST" name="edit_contest" style="display:inline;">',
        page)
    if match is not None:
        contest_id = int(match.groups()[0])
        admin_req('contest/%s' % contest_id, args=kwargs)
        return contest_id
    else:
        raise FrameworkException("Unable to create contest.")


def add_task(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "title": kwargs.get('title'),
    }
    r = admin_req('tasks/add', args=add_args)
    response = r.text
    match_task_id = re.search(r'/task/([0-9]+)$', r.url)
    match_dataset_id = re.search(r'/dataset/([0-9]+)', response)
    if match_task_id and match_dataset_id:
        task_id = int(match_task_id.group(1))
        dataset_id = int(match_dataset_id.group(1))
        edit_args = {}
        for k, v in kwargs.iteritems():
            edit_args[k.replace("{{dataset_id}}", str(dataset_id))] = v
        r = admin_req('task/%s' % task_id, args=edit_args)
        created_tasks[task_id] = kwargs
    else:
        raise FrameworkException("Unable to create task.")

    r = admin_req('contest/' + kwargs["contest_id"] + '/tasks/add',
                  args={"task_id": str(task_id)})
    g = re.search('<input type="radio" name="task_id" value="' +
                  str(task_id) + '"/>', r.text)
    if g:
        return task_id
    else:
        raise FrameworkException("Unable to assign task to contest.")


def add_manager(task_id, manager):
    args = {}
    files = [
        ('manager', manager),
    ]
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/managers/add' % dataset_id, files=files, args=args)


def get_task_active_dataset_id(task_id):
    resp = admin_req('task/%d' % task_id)
    page = resp.text
    match = re.search(
        r'id="title_dataset_([0-9]+).* \(Live\)</',
        page)
    if match is None:
        raise FrameworkException("Unable to create contest.")
    dataset_id = int(match.groups()[0])
    return dataset_id


def add_testcase(task_id, num, input_file, output_file, public):
    files = [
        ('input', input_file),
        ('output', output_file),
    ]
    args = {}
    args["codename"] = "%03d" % num
    if public:
        args['public'] = '1'
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/testcases/add' % dataset_id, files=files, args=args)


def add_user(**kwargs):
    r = admin_req('users/add', args=kwargs)
    g = re.search(r'/user/([0-9]+)$', r.url)
    if g:
        user_id = int(g.group(1))
        created_users[user_id] = kwargs
    else:
        raise FrameworkException("Unable to create user.")

    kwargs["user_id"] = user_id
    r = admin_req('contest/' + kwargs["contest_id"] + '/users/add',
                  args=kwargs)
    g = re.search('<input type="radio" name="user_id" value="' +
                  str(user_id) + '"/>', r.text)
    if g:
        return user_id
    else:
        raise FrameworkException("Unable to create participation.")


def add_existing_task(task_id, **kwargs):
    '''Add information about an existing task to our database so that we can
    use it for submitting later.'''
    created_tasks[task_id] = kwargs


def add_existing_user(user_id, **kwargs):
    '''Add information about an existing user to our database so that we can
    use it for submitting later.'''
    created_users[user_id] = kwargs


def cws_submit(contest_id, task_id, user_id, submission_format,
               filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitRequest(browser, task, base_url=CWS_BASE_URL,
                       submission_format=submission_format,
                       filenames=filenames, language=language)
    sr.execute()
    submission_id = sr.get_submission_id()

    if submission_id is None:
        raise FrameworkException("Failed to submit solution.")

    return submission_id


def cws_submit_user_test(contest_id, task_id, user_id, submission_format,
                         filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitUserTestRequest(
        browser, task, base_url=CWS_BASE_URL,
        submission_format=submission_format,
        filenames=filenames)
    sr.execute()
    user_test_id = sr.get_user_test_id()

    if user_test_id is None:
        raise FrameworkException("Failed to submit user test.")

    return user_test_id


def get_evaluation_result(contest_id, submission_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.|Scoring\.\.\.|Evaluated')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated \(|Scored \(')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSSubmissionViewRequest(browser,
                                      submission_id,
                                      base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_submission_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown submission status: %s" % status)

    raise FrameworkException("Waited too long for submission result.")


def get_user_test_result(contest_id, user_test_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSUserTestViewRequest(browser,
                                    user_test_id,
                                    base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_user_test_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown user test status: %s" % status)

    raise FrameworkException("Waited too long for user test result.")

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import re

from bs4 import BeautifulSoup

from cmstestsuite.web import GenericRequest, LoginRequest


class AWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        fail_re = re.compile('Failed to log in.')
        if fail_re.search(self.res_data) is not None:
            return False
        username_re = re.compile(self.username)
        if username_re.search(self.res_data) is None:
            return False
        return True


class AWSSubmissionViewRequest(GenericRequest):
    """Load the view of a submission in AWS.

    """
    def __init__(self, browser, submission_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.submission_id = submission_id
        self.url = "%ssubmission/%s" % (self.base_url, submission_id)                    

    def describe(self):
        return "check submission %s" % self.submission_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_submission_info()
            return True
        except:
            return False

    def get_submission_info(self):
        # Only valid after self.execute()
        # Parse submission information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get submission status.
        tag = soup.find_all(id="submission_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.find_all(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = "\n".join(
                [pre.text.strip() for pre in content.findAll("pre")])
        else:
            info['compile_output'] = None

        # Get evaluation results.
        evaluations = []
        tags = soup.find_all(id=re.compile(r"^eval_outcome_"))
        text_tags = soup.find_all(id=re.compile(r"^eval_text_"))
        for outcome_tag, text_tag in zip(tags, text_tags):
            # Get evaluation text also.
            evaluations.append({
                'outcome': outcome_tag.text.strip(),
                'text': text_tag.text.strip(),
            })

        info['evaluations'] = evaluations

        return info


class AWSUserTestViewRequest(GenericRequest):
    """Load the view of a user test in AWS."""
    def __init__(self, browser, user_test_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.user_test_id = user_test_id
        self.url = "%suser_test/%s" % (self.base_url, user_test_id)                    

    def describe(self):
        return "check user_test %s" % self.user_test_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_user_test_info()
            return True
        except:
            return False

    def get_user_test_info(self):
        # Only valid after self.execute()
        # Parse user test information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get user test status.
        tag = soup.findAll(id="user_test_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.findAll(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = content.pre.text.strip()
        else:
            info['compile_output'] = None

        return info

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import logging
import os
import random
import re
import tempfile

from cms.grading.languagemanager import filename_to_language
from cmscommon.crypto import decrypt_number
from cmstestsuite.web import GenericRequest, LoginRequest


logger = logging.getLogger(__name__)


class CWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        if self.redirected_to != self.base_url:
            return False
        return True


class HomepageRequest(GenericRequest):
    """Load the main page of CWS.

    """
    def __init__(self, browser, username, loggedin, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = self.base_url
        self.username = username
        self.loggedin = loggedin

    def describe(self):
        return "check the main page"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        username_re = re.compile(self.username)
        if self.loggedin:
            if username_re.search(self.res_data) is None:
                return False
        else:
            if username_re.search(self.res_data) is not None:
                return False
        return True


class TaskRequest(GenericRequest):
    """Load a task page in CWS.

    """
    def __init__(self, browser, task_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/description" % (self.base_url, task_id)                    
        self.task_id = task_id

    def describe(self):
        return "load page for task %s (%s)" % (self.task_id, self.url)


class TaskStatementRequest(GenericRequest):
    """Load a task statement in CWS.

    """
    def __init__(self, browser, task_id, language_code, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/statements/%s" % (self.base_url,                    
                                                 task_id, language_code)                    
        self.task_id = task_id

    def describe(self):
        return "load statement for task %s (%s)" % (self.task_id, self.url)

    def specific_info(self):
        return '\nNO DATA DUMP FOR TASK STATEMENTS\n'


class SubmitRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        self.files = list(zip(self.submission_format, self.filenames))

    def describe(self):
        return "submit sources %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_submission_id() is not None

    def get_submission_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("?")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            submission_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt submission id from page: `%s'",
                           self.redirected_to)
            return None
        return submission_id


class SubmitUserTestRequest(GenericRequest):
    """Submit a user test in CWS."""
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/test" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        # Let's generate an arbitrary input file.
        # TODO: delete this file once we're done with it.
        _, temp_filename = tempfile.mkstemp()
        self.files = \
            list(zip(self.submission_format, self.filenames)) + \
            [("input", temp_filename)]

    def describe(self):
        return "submit user test %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_user_test_id() is not None

    def get_user_test_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("&")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            user_test_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt user test id from page: `%s'",
                           self.redirected_to)
            return None
        return user_test_id


class TokenRequest(GenericRequest):
    """Release test a submission.

    """
    def __init__(self, browser, task, submission_num, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submissions/%s/token" % (self.base_url,                    
                                                        task[1],
                                                        submission_num)                    
        self.task = task
        self.submission_num = submission_num
        self.data = {}

    def describe(self):
        return "release test the %s-th submission for task %s (ID %d)" % \
            (self.submission_num, self.task[1], self.task[0])

    def specific_info(self):
        return 'Task: %s (ID %d)\nSubmission: %s\n' % \
            (self.task[1], self.task[0], self.submission_num) + \                    
            GenericRequest.specific_info(self)


class SubmitRandomRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, base_url=None,
                 submissions_path=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submissions_path = submissions_path
        self.data = {}

    def _prepare(self):
        """Select a random solution and prepare it for submission.

        If task/ is the task directory, it might contain files (only
        if the submission format is with a single file) and
        directory. If it contains a file, it is assumed that it is the
        only element in the submission format, and is the basename
        without extension of the file. If it is a directory, all files
        inside are assumed to be part of the submission format with
        their basenames without extension.

        """
        GenericRequest._prepare(self)

        # Select a random directory or file inside the task directory.
        task_path = os.path.join(self.submissions_path, self.task[1])
        sources = os.listdir(task_path)
        source = random.choice(sources)
        self.source_path = os.path.join(task_path, source)

        # Compose the submission format
        self.files = []
        if os.path.isdir(self.source_path):
            submission_formats = os.listdir(self.source_path)
            self.files = [('%s.%%l' % (os.path.splitext(sf)[0]),
                           os.path.join(self.source_path, sf))
                          for sf in submission_formats]
        else:
            submission_format = os.path.splitext(source)[0]
            self.files = [('%s.%%l' % (submission_format), self.source_path)]

    def describe(self):
        return "submit source %s for task %s (ID %d) %s" % \
            (self.source_path, self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], self.source_path) + \
            GenericRequest.specific_info(self)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import codecs
import datetime
import io
import os
import sys
import time
import traceback
import urllib

import requests


debug = False


class Browser(object):
    def __init__(self):
        self.xsrf_token = None
        self.session = requests.Session()

    def read_xsrf_token(self, url):
        response = self.session.get(url)                    
        for cookie in response.cookies:                    
            if cookie.name == "_xsrf":
                self.xsrf_token = cookie.value

    def login(self, login_request):
        self.read_xsrf_token(login_request.base_url)
        login_request.execute()

    def do_request(self, url, data=None, file_names=None):
        """Open an URL in a mechanize browser, optionally passing the                    
        specified data and files as POST arguments.                    

        browser (mechanize.Browser): the browser to use.                    
        url (string): the URL to open.
        data (dict): a dictionary of parameters to pass as POST
            arguments.
        file_names ([(str, str)]): a list of files to pass as POST
            arguments. Each entry is a tuple containing two strings:
            the field name and the name of the file to send.

        """
        if file_names is None:
            if data is None:
                response = self.session.get(url)                    
            else:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                response = self.session.post(url, data)
        else:
            try:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                file_objs = dict((k, io.open(v, "rb")) for k, v in file_names)
                response = self.session.post(url, data, files=file_objs)
            finally:
                for fobj in file_objs.itervalues():
                    fobj.close()
        return response


class GenericRequest(object):
    """Request to a server.

    """

    OUTCOME_SUCCESS = 'success'
    OUTCOME_FAILURE = 'failure'
    OUTCOME_UNDECIDED = 'undecided'
    OUTCOME_ERROR = 'error'

    MINIMUM_LENGTH = 100

    def __init__(self, browser, base_url=None):
        if base_url is None:
            base_url = 'http://localhost:8888/'
        self.browser = browser
        self.base_url = base_url
        self.outcome = None

        self.start_time = None
        self.stop_time = None
        self.duration = None
        self.exception_data = None

        self.url = None
        self.data = None
        self.files = None

        self.status_code = None
        self.response = None
        self.res_data = None
        self.redirected_to = None

    def execute(self):
        """Main entry point to execute the test"""
        self._prepare()
        self._execute()

    def _prepare(self):
        """Optional convenience hook called just after creating the Request"""
        pass

    def _execute(self):
        """Execute the test"""
        description = self.describe()
        self.start_time = time.time()
        try:
            self.response = self.browser.do_request(
                self.url, self.data, self.files)
            self.response.raise_for_status()

            self.status_code = self.response.status_code
            self.res_data = self.response.text

            if len(self.response.history) > 0:
                self.redirected_to = self.response.url

        # Catch possible exceptions
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        else:
            self.outcome = None

        finally:
            self.stop_time = time.time()
            self.duration = self.stop_time - self.start_time

        success = None
        try:
            success = self.test_success()
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        # If no exceptions were casted, decode the test evaluation
        if self.outcome is None:

            # Could not decide on the evaluation
            if success is None:
                if debug:
                    print("Could not determine status for request '%s'" %
                          (description), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_UNDECIDED

            # Success
            elif success:
                if debug:
                    print("Request '%s' successfully completed in %.3fs" %
                          (description, self.duration), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_SUCCESS

            # Failure
            elif not success:
                if debug:
                    print("Request '%s' failed" % (description),
                          file=sys.stderr)
                    if self.exception_data is not None:
                        print(self.exception_data, file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_FAILURE

        # Otherwise report the exception
        else:
            print("Request '%s' terminated with an exception: %s\n%s" %
                  (description, repr(exc), self.exception_data),
                  file=sys.stderr)

    def test_success(self):
        if self.status_code not in [200, 302]:
            return False
        if self.status_code == 200 and self.res_data is None:
            return False
        if self.status_code == 200 and \
                len(self.res_data) < GenericRequest.MINIMUM_LENGTH:
            return False
        return True

    def specific_info(self):
        res = "URL: %s\n" % (unicode(self.url))
        if self.response is not None:
            res += "\nREQUEST HEADERS\n"
            for (key, value) in self.response.request.headers.iteritems():
                res += "%s: %s\n" % (key, value)
            res += "\nREQUEST DATA\n%s\n" % self.response.request.body
        else:
            res += "\nNO REQUEST INFORMATION AVAILABLE\n"
        if self.res_data is not None:
            headers = self.response.headers.items()
            res += "\nRESPONSE HEADERS\n%s" % (
                "".join(["%s: %s\n" % (header[0], header[1])
                         for header in headers]))
            res += "\nRESPONSE DATA\n%s\n" % (self.res_data)
        else:
            res += "\nNO RESPONSE INFORMATION AVAILABLE\n"
        return res

    def describe(self):
        raise NotImplementedError("Please subclass this class "
                                  "and actually implement some request")

    def store_to_file(self, fd):
        print("Test type: %s" % (self.__class__.__name__), file=fd)
        print("Execution start time: %s" %
              (datetime.datetime.fromtimestamp(self.start_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Execution stop time: %s" %
              (datetime.datetime.fromtimestamp(self.stop_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Duration: %f seconds" % (self.duration), file=fd)
        print("Outcome: %s" % (self.outcome), file=fd)
        fd.write(self.specific_info())
        if self.exception_data is not None:
            print("", file=fd)
            print("EXCEPTION CASTED", file=fd)
            fd.write(unicode(self.exception_data))


class LoginRequest(GenericRequest):
    """Try to login to CWS or AWS with the given credentials.

    """
    def __init__(self, browser, username, password, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.username = username
        self.password = password
        self.url = '%slogin' % self.base_url                    
        self.data = {'username': self.username,
                     'password': self.password,                    
                     'next': '/'}                    

    def describe(self):
        return "try to login"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        # Additional checks need to be done by the subclasses.
        return True

    def specific_info(self):
        return 'Username: %s\nPassword: %s\n' % \
               (self.username, self.password) + \
            GenericRequest.specific_info(self)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import ast
import io
import os
import sys
import threading
import random
import time

from cms import config, ServiceCoord, get_service_address                    
from cms.db import Contest, SessionGen

import cmstestsuite.web
from cmstestsuite.web import Browser
from cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \                    
    TaskRequest, TaskStatementRequest, SubmitRandomRequest


cmstestsuite.web.debug = True


class RequestLog(object):

    def __init__(self, log_dir=None):
        self.total = 0
        self.success = 0
        self.failure = 0
        self.error = 0
        self.undecided = 0
        self.total_time = 0.0
        self.max_time = 0.0

        self.log_dir = log_dir
        if self.log_dir is not None:
            try:
                os.makedirs(self.log_dir)
            except OSError:
                pass

    def print_stats(self):
        print("TOTAL:          %5d" % (self.total), file=sys.stderr)
        print("SUCCESS:        %5d" % (self.success), file=sys.stderr)
        print("FAIL:           %5d" % (self.failure), file=sys.stderr)
        print("ERROR:          %5d" % (self.error), file=sys.stderr)
        print("UNDECIDED:      %5d" % (self.undecided), file=sys.stderr)
        print("Total time:   %7.3f" % (self.total_time), file=sys.stderr)
        print("Average time: %7.3f" % (self.total_time / self.total),
              file=sys.stderr)
        print("Max time:     %7.3f" % (self.max_time), file=sys.stderr)

    def merge(self, log2):
        self.total += log2.total
        self.success += log2.success
        self.failure += log2.failure
        self.error += log2.error
        self.undecided += log2.undecided
        self.total_time += log2.total_time
        self.max_time = max(self.max_time, log2.max_time)

    def store_to_file(self, request):
        if self.log_dir is None:
            return

        filename = "%s_%s.log" % (request.start_time,
                                  request.__class__.__name__)
        filepath = os.path.join(self.log_dir, filename)
        linkpath = os.path.join(self.log_dir, request.__class__.__name__)
        with io.open(filepath, 'wt', encoding='utf-8') as fd:
            request.store_to_file(fd)
        try:
            os.remove(linkpath)
        except OSError:
            pass
        os.symlink(filename, linkpath)


class ActorDying(Exception):
    """Exception to be raised when an Actor is going to die soon. See
    Actor class.

    """
    pass


class Actor(threading.Thread):
    """Class that simulates the behaviour of a user of the system. It
    performs some requests at randomized times (checking CMS pages,
    doing submissions, ...), checking for their success or failure.

    The probability that the users doing actions depends on the value
    specified in an object called "metrics".

    """

    def __init__(self, username, password, metrics, tasks,
                 log=None, base_url=None, submissions_path=None):
        threading.Thread.__init__(self)

        self.username = username
        self.password = password
        self.metrics = metrics
        self.tasks = tasks
        self.log = log
        self.base_url = base_url
        self.submissions_path = submissions_path

        self.name = "Actor thread for user %s" % (self.username)

        self.browser = Browser()
        self.die = False

    def run(self):
        try:
            print("Starting actor for user %s" % (self.username),
                  file=sys.stderr)
            self.act()

        except ActorDying:
            print("Actor dying for user %s" % (self.username), file=sys.stderr)

    def act(self):
        """Define the behaviour of the actor. Subclasses are expected
        to overwrite this stub method properly.

        """
        raise Exception("Not implemented. Please subclass Action"
                        "and overwrite act().")

    def do_step(self, request):
        self.wait_next()
        self.log.total += 1
        try:
            request.execute()
        except Exception as exc:
            print("Unhandled exception while executing the request: %s" % exc,
                  file=sys.stderr)
            return
        self.log.__dict__[request.outcome] += 1
        self.log.total_time += request.duration
        self.log.max_time = max(self.log.max_time, request.duration)
        self.log.store_to_file(request)

    def wait_next(self):
        """Wait some time. At the moment it waits c*X seconds, where c
        is the time_coeff parameter in metrics and X is an
        exponentially distributed random variable, with parameter
        time_lambda in metrics.

        The total waiting time is divided in lots of little sleep()
        call each one of 0.1 seconds, so that the waiting gets
        interrupted if a die signal arrives.

        If a die signal is received, an ActorDying exception is
        raised.

        """
        SLEEP_PERIOD = 0.1
        time_to_wait = self.metrics['time_coeff'] * \
            random.expovariate(self.metrics['time_lambda'])
        sleep_num = int(time_to_wait / SLEEP_PERIOD)
        remaining_sleep = time_to_wait - (sleep_num * SLEEP_PERIOD)
        for i in xrange(sleep_num):                    
            time.sleep(SLEEP_PERIOD)
            if self.die:
                raise ActorDying()
        time.sleep(remaining_sleep)
        if self.die:
            raise ActorDying()

    def login(self):
        """Log in and check to be logged in."""
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=False,
                                     base_url=self.base_url))                    
        self.do_step(LoginRequest(self.browser,                    
                                  self.username,                    
                                  self.password,                    
                                  base_url=self.base_url))                    
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=True,
                                     base_url=self.base_url))                    


class RandomActor(Actor):

    def act(self):
        self.login()

        while True:
            choice = random.random()
            task = random.choice(self.tasks)
            if choice < 0.1 and self.submissions_path is not None:
                self.do_step(SubmitRandomRequest(
                    self.browser,
                    task,
                    base_url=self.base_url,
                    submissions_path=self.submissions_path))
            elif choice < 0.6 and task[2] != []:
                self.do_step(TaskStatementRequest(self.browser,
                                                  task[1],
                                                  random.choice(task[2]),
                                                  base_url=self.base_url))                    
            else:
                self.do_step(TaskRequest(self.browser,
                                         task[1],
                                         base_url=self.base_url))                    


class SubmitActor(Actor):

    def act(self):
        self.login()

        # Then keep forever stumbling across user pages
        while True:
            task = random.choice(self.tasks)
            self.do_step(SubmitRandomRequest(
                self.browser,
                task,
                base_url=self.base_url,
                submissions_path=self.submissions_path))


def harvest_contest_data(contest_id):
    """Retrieve the couples username, password and the task list for a
    given contest.

    contest_id (int): the id of the contest we want.
    return (tuple): the first element is a dictionary mapping
                    usernames to passwords; the second one is the list
                    of the task names.

    """
    users = {}
    tasks = []
    with SessionGen() as session:
        contest = Contest.get_from_id(contest_id, session)
        for participation in contest.participations:
            user = participation.user
            users[user.username] = {'password': user.password}
        for task in contest.tasks:
            tasks.append((task.id, task.name, task.statements.keys()))
    return users, tasks


DEFAULT_METRICS = {'time_coeff': 10.0,
                   'time_lambda': 2.0}


def main():
    parser = argparse.ArgumentParser(description="Stress tester for CMS")
    parser.add_argument(
        "-c", "--contest-id", action="store", type=int, required=True,
        help="ID of the contest to test against")
    parser.add_argument(
        "-n", "--actor-num", action="store", type=int,
        help="the number of actors to spawn")
    parser.add_argument(
        "-s", "--sort-actors", action="store_true",
        help="sort usernames alphabetically before slicing them")
    parser.add_argument(
        "-u", "--base-url", action="store", type=utf8_decoder,
        help="base URL for placing HTTP requests")                    
    parser.add_argument(
        "-S", "--submissions-path", action="store", type=utf8_decoder,
        help="base path for submission to send")
    parser.add_argument(
        "-p", "--prepare-path", action="store", type=utf8_decoder,
        help="file to put contest info to")
    parser.add_argument(
        "-r", "--read-from", action="store", type=utf8_decoder,
        help="file to read contest info from")
    parser.add_argument(
        "-t", "--time-coeff", action="store", type=float, default=10.0,
        help="average wait between actions")
    parser.add_argument(
        "-o", "--only-submit", action="store_true",
        help="whether the actor only submits solutions")
    args = parser.parse_args()

    # If prepare_path is specified we only need to save some useful
    # contest data and exit.
    if args.prepare_path is not None:
        users, tasks = harvest_contest_data(args.contest_id)
        contest_data = dict()
        contest_data['users'] = users
        contest_data['tasks'] = tasks
        with io.open(args.prepare_path, "wt", encoding="utf-8") as file_:
            file_.write("%s" % contest_data)
        return

    assert args.time_coeff > 0.0
    assert not (args.only_submit and args.submissions_path == "")

    users = []
    tasks = []

    # If read_from is not specified, read contest data from database
    # if it is specified - read contest data from the file
    if args.read_from is None:
        users, tasks = harvest_contest_data(args.contest_id)
    else:
        with io.open(args.read_from, "rt", encoding="utf-8") as file_:
            contest_data = ast.literal_eval(file_.read())
        users = contest_data['users']
        tasks = contest_data['tasks']

    if args.actor_num is not None:
        user_items = users.items()
        if args.sort_actors:
            user_items.sort()
        else:
            random.shuffle(user_items)
        users = dict(user_items[:args.actor_num])

    # If the base URL is not specified, we try to guess it; anyway,
    # the guess code isn't very smart...
    if args.base_url is not None:
        base_url = args.base_url
    else:
        base_url = "http://%s:%d/" % \
            (get_service_address(ServiceCoord('ContestWebServer', 0))[0],
             config.contest_listen_port[0])

    metrics = DEFAULT_METRICS
    metrics["time_coeff"] = args.time_coeff
    actor_class = RandomActor
    if args.only_submit:
        actor_class = SubmitActor
    actors = [actor_class(username, data['password'], metrics, tasks,
                          log=RequestLog(log_dir=os.path.join('./test_logs',
                                                              username)),
                          base_url=base_url,
                          submissions_path=args.submissions_path)
              for username, data in users.iteritems()]
    for actor in actors:                    
        actor.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Taking down actors", file=sys.stderr)
        for actor in actors:                    
            actor.die = True

    # Uncomment to turn on some memory profiling.
    # from meliae import scanner
    # print("Dumping")
    # scanner.dump_all_objects('objects.json')
    # print("Dump finished")

    finished = False                    
    while not finished:                    
        for actor in actors:                    
            actor.join()                    

    print("Test finished", file=sys.stderr)

    great_log = RequestLog()
    for actor in actors:                    
        great_log.merge(actor.log)

    great_log.print_stats()


if __name__ == '__main__':
    main()

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2013-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2013-2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
# Copyright  2014 Luca Versari <veluca93@gmail.com>
# Copyright  2014 William Di Luigi <williamdiluigi@gmail.com>
# Copyright  2016 Peyman Jabbarzade Ganje <peyman.jabarzade@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import io
import json
import logging
import os
import re
import subprocess
import sys
import time

import requests

from cmstestsuite.web import Browser
from cmstestsuite.web.AWSRequests import \
    AWSLoginRequest, AWSSubmissionViewRequest, AWSUserTestViewRequest
from cmstestsuite.web.CWSRequests import \
    CWSLoginRequest, SubmitRequest, SubmitUserTestRequest


logger = logging.getLogger(__name__)


# CONFIG is populated by our test script.
CONFIG = {
    'VERBOSITY': 0,
}


# cms_config holds the decoded-JSON of the cms.conf configuration file.
cms_config = None


# List of users and tasks we created as part of the test.
created_users = {}
created_tasks = {}


# Information on the administrator running the tests.
admin_info = {}


# Base URLs for AWS and CWS
AWS_BASE_URL = "http://localhost:8889/"                    
CWS_BASE_URL = "http://localhost:8888/"                    


# Persistent browsers to access AWS and CWS.
aws_browser = None
cws_browser = None


def get_aws_browser():
    global aws_browser
    if aws_browser is None:
        aws_browser = Browser()

        lr = AWSLoginRequest(aws_browser,
                             admin_info["username"], admin_info["password"],
                             base_url=AWS_BASE_URL)
        aws_browser.login(lr)
    return aws_browser


def get_cws_browser(user_id):
    global cws_browser
    if cws_browser is None:
        cws_browser = Browser()
        username = created_users[user_id]['username']
        password = created_users[user_id]['password']
        lr = CWSLoginRequest(
            cws_browser, username, password, base_url=CWS_BASE_URL)
        cws_browser.login(lr)
    return cws_browser


class FrameworkException(Exception):
    pass


def read_cms_config():
    global cms_config
    with io.open("%(CONFIG_PATH)s" % CONFIG, "rt") as f:
        cms_config = json.load(f)


def get_cms_config():
    if cms_config is None:
        read_cms_config()
    return cms_config


def sh(cmdline, ignore_failure=False):
    """Execute a simple shell command.

    If cmdline is a string, it is passed to sh -c verbatim.  All escaping must
    be performed by the user. If cmdline is an array, then no escaping is
    required.

    """
    if CONFIG["VERBOSITY"] >= 1:
        # TODO Use shlex.quote in Python 3.3.
        logger.info('$ ' + ' '.join(cmdline))
    kwargs = dict()
    if CONFIG["VERBOSITY"] >= 3:
        # TODO Use subprocess.DEVNULL in Python 3.3.
        kwargs["stdout"] = io.open(os.devnull, "wb")
        kwargs["stderr"] = subprocess.STDOUT
    ret = subprocess.call(cmdline, **kwargs)
    if not ignore_failure and ret != 0:
        raise FrameworkException(
            # TODO Use shlex.quote in Python 3.3.
            "Execution failed with %d/%d. Tried to execute:\n%s\n" %
            (ret & 0xff, ret >> 8, ' '.join(cmdline)))


def configure_cms(options):
    """Creates the cms.conf file, setting any parameters as requested.

    The parameters are substituted in textually, and thus this may be
    quite fragile.

    options (dict): mapping from parameter to textual JSON argument.

    """
    with io.open("%(TEST_DIR)s/config/cms.conf.sample" % CONFIG,
                 "rt", encoding="utf-8") as in_f:
        lines = in_f.readlines()

    unset = set(options.keys())
    for i, line in enumerate(lines):
        g = re.match(r'^(\s*)"([^"]+)":', line)
        if g:
            whitespace, key = g.groups()
            if key in unset:
                lines[i] = '%s"%s": %s,\n' % (whitespace, key, options[key])
                unset.remove(key)

    with io.open("%(CONFIG_PATH)s" % CONFIG, "wt", encoding="utf-8") as out_f:
        for l in lines:
            out_f.write(l)

    if unset:
        print("These configuration items were not set:")
        print("  " + ", ".join(sorted(list(unset))))

    # Load the config database.
    read_cms_config()


def combine_coverage():
    logger.info("Combining coverage results.")
    sh([sys.executable, "-m", "coverage", "combine"])


def initialize_aws(rand):
    """Create an admin and logs in

    rand (int): some random bit to add to the admin username.

    """
    logger.info("Creating admin...")
    admin_info["username"] = "admin%s" % rand
    admin_info["password"] = "adminpwd"
    sh([sys.executable, "cmscontrib/AddAdmin.py", "%(username)s" % admin_info,
        "-p", "%(password)s" % admin_info])


def admin_req(path, args=None, files=None):
    browser = get_aws_browser()
    return browser.do_request(AWS_BASE_URL + path, args, files)                    


def get_tasks():
    '''Return a list of existing tasks, returned as a dictionary of
      'taskname' => { 'id': ..., 'title': ... }

    '''
    r = admin_req('tasks')
    groups = re.findall(r'''
        <tr>\s*
        <td><a\s+href="./task/(\d+)">(.*)</a></td>\s*
        <td>(.*)</td>\s*
        ''', r.text, re.X)
    tasks = {}
    for g in groups:
        id, name, title = g
        id = int(id)
        tasks[name] = {
            'title': title,
            'id': id,
        }

    return tasks


def get_users(contest_id):
    '''Return a list of existing users, returned as a dictionary of
      'username' => { 'id': ..., 'firstname': ..., 'lastname': ... }

    '''
    r = admin_req('contest/' + str(contest_id) + '/users')
    groups = re.findall(r'''
        <tr> \s*
        <td> \s* (.*) \s* </td> \s*
        <td> \s* (.*) \s* </td> \s*
        <td><a\s+href="./user/(\d+)">(.*)</a></td>
    ''', r.text, re.X)
    users = {}
    for g in groups:
        firstname, lastname, id, username = g
        id = int(id)
        users[username] = {
            'firstname': firstname,
            'lastname': lastname,
            'id': id,
        }

    return users


def add_contest(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "description": kwargs.get('description'),
    }
    resp = admin_req('contests/add', args=add_args)
    # Contest ID is returned as HTTP response.
    page = resp.text
    match = re.search(
        r'<form enctype="multipart/form-data" action="../contest/([0-9]+)" '
        'method="POST" name="edit_contest" style="display:inline;">',
        page)
    if match is not None:
        contest_id = int(match.groups()[0])
        admin_req('contest/%s' % contest_id, args=kwargs)
        return contest_id
    else:
        raise FrameworkException("Unable to create contest.")


def add_task(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "title": kwargs.get('title'),
    }
    r = admin_req('tasks/add', args=add_args)
    response = r.text
    match_task_id = re.search(r'/task/([0-9]+)$', r.url)
    match_dataset_id = re.search(r'/dataset/([0-9]+)', response)
    if match_task_id and match_dataset_id:
        task_id = int(match_task_id.group(1))
        dataset_id = int(match_dataset_id.group(1))
        edit_args = {}
        for k, v in kwargs.iteritems():
            edit_args[k.replace("{{dataset_id}}", str(dataset_id))] = v
        r = admin_req('task/%s' % task_id, args=edit_args)
        created_tasks[task_id] = kwargs
    else:
        raise FrameworkException("Unable to create task.")

    r = admin_req('contest/' + kwargs["contest_id"] + '/tasks/add',
                  args={"task_id": str(task_id)})
    g = re.search('<input type="radio" name="task_id" value="' +
                  str(task_id) + '"/>', r.text)
    if g:
        return task_id
    else:
        raise FrameworkException("Unable to assign task to contest.")


def add_manager(task_id, manager):
    args = {}
    files = [
        ('manager', manager),
    ]
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/managers/add' % dataset_id, files=files, args=args)


def get_task_active_dataset_id(task_id):
    resp = admin_req('task/%d' % task_id)
    page = resp.text
    match = re.search(
        r'id="title_dataset_([0-9]+).* \(Live\)</',
        page)
    if match is None:
        raise FrameworkException("Unable to create contest.")
    dataset_id = int(match.groups()[0])
    return dataset_id


def add_testcase(task_id, num, input_file, output_file, public):
    files = [
        ('input', input_file),
        ('output', output_file),
    ]
    args = {}
    args["codename"] = "%03d" % num
    if public:
        args['public'] = '1'
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/testcases/add' % dataset_id, files=files, args=args)


def add_user(**kwargs):
    r = admin_req('users/add', args=kwargs)
    g = re.search(r'/user/([0-9]+)$', r.url)
    if g:
        user_id = int(g.group(1))
        created_users[user_id] = kwargs
    else:
        raise FrameworkException("Unable to create user.")

    kwargs["user_id"] = user_id
    r = admin_req('contest/' + kwargs["contest_id"] + '/users/add',
                  args=kwargs)
    g = re.search('<input type="radio" name="user_id" value="' +
                  str(user_id) + '"/>', r.text)
    if g:
        return user_id
    else:
        raise FrameworkException("Unable to create participation.")


def add_existing_task(task_id, **kwargs):
    '''Add information about an existing task to our database so that we can
    use it for submitting later.'''
    created_tasks[task_id] = kwargs


def add_existing_user(user_id, **kwargs):
    '''Add information about an existing user to our database so that we can
    use it for submitting later.'''
    created_users[user_id] = kwargs


def cws_submit(contest_id, task_id, user_id, submission_format,
               filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitRequest(browser, task, base_url=CWS_BASE_URL,
                       submission_format=submission_format,
                       filenames=filenames, language=language)
    sr.execute()
    submission_id = sr.get_submission_id()

    if submission_id is None:
        raise FrameworkException("Failed to submit solution.")

    return submission_id


def cws_submit_user_test(contest_id, task_id, user_id, submission_format,
                         filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitUserTestRequest(
        browser, task, base_url=CWS_BASE_URL,
        submission_format=submission_format,
        filenames=filenames)
    sr.execute()
    user_test_id = sr.get_user_test_id()

    if user_test_id is None:
        raise FrameworkException("Failed to submit user test.")

    return user_test_id


def get_evaluation_result(contest_id, submission_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.|Scoring\.\.\.|Evaluated')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated \(|Scored \(')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSSubmissionViewRequest(browser,
                                      submission_id,
                                      base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_submission_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown submission status: %s" % status)

    raise FrameworkException("Waited too long for submission result.")


def get_user_test_result(contest_id, user_test_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSUserTestViewRequest(browser,
                                    user_test_id,
                                    base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_user_test_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown user test status: %s" % status)

    raise FrameworkException("Waited too long for user test result.")

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import re

from bs4 import BeautifulSoup

from cmstestsuite.web import GenericRequest, LoginRequest


class AWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        fail_re = re.compile('Failed to log in.')
        if fail_re.search(self.res_data) is not None:
            return False
        username_re = re.compile(self.username)
        if username_re.search(self.res_data) is None:
            return False
        return True


class AWSSubmissionViewRequest(GenericRequest):
    """Load the view of a submission in AWS.

    """
    def __init__(self, browser, submission_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.submission_id = submission_id
        self.url = "%ssubmission/%s" % (self.base_url, submission_id)                    

    def describe(self):
        return "check submission %s" % self.submission_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_submission_info()
            return True
        except:
            return False

    def get_submission_info(self):
        # Only valid after self.execute()
        # Parse submission information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get submission status.
        tag = soup.find_all(id="submission_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.find_all(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = "\n".join(
                [pre.text.strip() for pre in content.findAll("pre")])
        else:
            info['compile_output'] = None

        # Get evaluation results.
        evaluations = []
        tags = soup.find_all(id=re.compile(r"^eval_outcome_"))
        text_tags = soup.find_all(id=re.compile(r"^eval_text_"))
        for outcome_tag, text_tag in zip(tags, text_tags):
            # Get evaluation text also.
            evaluations.append({
                'outcome': outcome_tag.text.strip(),
                'text': text_tag.text.strip(),
            })

        info['evaluations'] = evaluations

        return info


class AWSUserTestViewRequest(GenericRequest):
    """Load the view of a user test in AWS."""
    def __init__(self, browser, user_test_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.user_test_id = user_test_id
        self.url = "%suser_test/%s" % (self.base_url, user_test_id)                    

    def describe(self):
        return "check user_test %s" % self.user_test_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_user_test_info()
            return True
        except:
            return False

    def get_user_test_info(self):
        # Only valid after self.execute()
        # Parse user test information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get user test status.
        tag = soup.findAll(id="user_test_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.findAll(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = content.pre.text.strip()
        else:
            info['compile_output'] = None

        return info

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import logging
import os
import random
import re
import tempfile

from cms.grading.languagemanager import filename_to_language
from cmscommon.crypto import decrypt_number
from cmstestsuite.web import GenericRequest, LoginRequest


logger = logging.getLogger(__name__)


class CWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        if self.redirected_to != self.base_url:
            return False
        return True


class HomepageRequest(GenericRequest):
    """Load the main page of CWS.

    """
    def __init__(self, browser, username, loggedin, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = self.base_url
        self.username = username
        self.loggedin = loggedin

    def describe(self):
        return "check the main page"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        username_re = re.compile(self.username)
        if self.loggedin:
            if username_re.search(self.res_data) is None:
                return False
        else:
            if username_re.search(self.res_data) is not None:
                return False
        return True


class TaskRequest(GenericRequest):
    """Load a task page in CWS.

    """
    def __init__(self, browser, task_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/description" % (self.base_url, task_id)                    
        self.task_id = task_id

    def describe(self):
        return "load page for task %s (%s)" % (self.task_id, self.url)


class TaskStatementRequest(GenericRequest):
    """Load a task statement in CWS.

    """
    def __init__(self, browser, task_id, language_code, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/statements/%s" % (self.base_url,                    
                                                 task_id, language_code)                    
        self.task_id = task_id

    def describe(self):
        return "load statement for task %s (%s)" % (self.task_id, self.url)

    def specific_info(self):
        return '\nNO DATA DUMP FOR TASK STATEMENTS\n'


class SubmitRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        self.files = list(zip(self.submission_format, self.filenames))

    def describe(self):
        return "submit sources %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_submission_id() is not None

    def get_submission_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("?")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            submission_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt submission id from page: `%s'",
                           self.redirected_to)
            return None
        return submission_id


class SubmitUserTestRequest(GenericRequest):
    """Submit a user test in CWS."""
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/test" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        # Let's generate an arbitrary input file.
        # TODO: delete this file once we're done with it.
        _, temp_filename = tempfile.mkstemp()
        self.files = \
            list(zip(self.submission_format, self.filenames)) + \
            [("input", temp_filename)]

    def describe(self):
        return "submit user test %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_user_test_id() is not None

    def get_user_test_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("&")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            user_test_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt user test id from page: `%s'",
                           self.redirected_to)
            return None
        return user_test_id


class TokenRequest(GenericRequest):
    """Release test a submission.

    """
    def __init__(self, browser, task, submission_num, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submissions/%s/token" % (self.base_url,                    
                                                        task[1],
                                                        submission_num)                    
        self.task = task
        self.submission_num = submission_num
        self.data = {}

    def describe(self):
        return "release test the %s-th submission for task %s (ID %d)" % \
            (self.submission_num, self.task[1], self.task[0])

    def specific_info(self):
        return 'Task: %s (ID %d)\nSubmission: %s\n' % \
            (self.task[1], self.task[0], self.submission_num) + \                    
            GenericRequest.specific_info(self)


class SubmitRandomRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, base_url=None,
                 submissions_path=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submissions_path = submissions_path
        self.data = {}

    def _prepare(self):
        """Select a random solution and prepare it for submission.

        If task/ is the task directory, it might contain files (only
        if the submission format is with a single file) and
        directory. If it contains a file, it is assumed that it is the
        only element in the submission format, and is the basename
        without extension of the file. If it is a directory, all files
        inside are assumed to be part of the submission format with
        their basenames without extension.

        """
        GenericRequest._prepare(self)

        # Select a random directory or file inside the task directory.
        task_path = os.path.join(self.submissions_path, self.task[1])
        sources = os.listdir(task_path)
        source = random.choice(sources)
        self.source_path = os.path.join(task_path, source)

        # Compose the submission format
        self.files = []
        if os.path.isdir(self.source_path):
            submission_formats = os.listdir(self.source_path)
            self.files = [('%s.%%l' % (os.path.splitext(sf)[0]),
                           os.path.join(self.source_path, sf))
                          for sf in submission_formats]
        else:
            submission_format = os.path.splitext(source)[0]
            self.files = [('%s.%%l' % (submission_format), self.source_path)]

    def describe(self):
        return "submit source %s for task %s (ID %d) %s" % \
            (self.source_path, self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], self.source_path) + \
            GenericRequest.specific_info(self)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import codecs
import datetime
import io
import os
import sys
import time
import traceback
import urllib

import requests


debug = False


class Browser(object):
    def __init__(self):
        self.xsrf_token = None
        self.session = requests.Session()

    def read_xsrf_token(self, url):
        response = self.session.get(url)                    
        for cookie in response.cookies:                    
            if cookie.name == "_xsrf":
                self.xsrf_token = cookie.value

    def login(self, login_request):
        self.read_xsrf_token(login_request.base_url)
        login_request.execute()

    def do_request(self, url, data=None, file_names=None):
        """Open an URL in a mechanize browser, optionally passing the                    
        specified data and files as POST arguments.                    

        browser (mechanize.Browser): the browser to use.                    
        url (string): the URL to open.
        data (dict): a dictionary of parameters to pass as POST
            arguments.
        file_names ([(str, str)]): a list of files to pass as POST
            arguments. Each entry is a tuple containing two strings:
            the field name and the name of the file to send.

        """
        if file_names is None:
            if data is None:
                response = self.session.get(url)                    
            else:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                response = self.session.post(url, data)
        else:
            try:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                file_objs = dict((k, io.open(v, "rb")) for k, v in file_names)
                response = self.session.post(url, data, files=file_objs)
            finally:
                for fobj in file_objs.itervalues():
                    fobj.close()
        return response


class GenericRequest(object):
    """Request to a server.

    """

    OUTCOME_SUCCESS = 'success'
    OUTCOME_FAILURE = 'failure'
    OUTCOME_UNDECIDED = 'undecided'
    OUTCOME_ERROR = 'error'

    MINIMUM_LENGTH = 100

    def __init__(self, browser, base_url=None):
        if base_url is None:
            base_url = 'http://localhost:8888/'
        self.browser = browser
        self.base_url = base_url
        self.outcome = None

        self.start_time = None
        self.stop_time = None
        self.duration = None
        self.exception_data = None

        self.url = None
        self.data = None
        self.files = None

        self.status_code = None
        self.response = None
        self.res_data = None
        self.redirected_to = None

    def execute(self):
        """Main entry point to execute the test"""
        self._prepare()
        self._execute()

    def _prepare(self):
        """Optional convenience hook called just after creating the Request"""
        pass

    def _execute(self):
        """Execute the test"""
        description = self.describe()
        self.start_time = time.time()
        try:
            self.response = self.browser.do_request(
                self.url, self.data, self.files)
            self.response.raise_for_status()

            self.status_code = self.response.status_code
            self.res_data = self.response.text

            if len(self.response.history) > 0:
                self.redirected_to = self.response.url

        # Catch possible exceptions
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        else:
            self.outcome = None

        finally:
            self.stop_time = time.time()
            self.duration = self.stop_time - self.start_time

        success = None
        try:
            success = self.test_success()
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        # If no exceptions were casted, decode the test evaluation
        if self.outcome is None:

            # Could not decide on the evaluation
            if success is None:
                if debug:
                    print("Could not determine status for request '%s'" %
                          (description), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_UNDECIDED

            # Success
            elif success:
                if debug:
                    print("Request '%s' successfully completed in %.3fs" %
                          (description, self.duration), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_SUCCESS

            # Failure
            elif not success:
                if debug:
                    print("Request '%s' failed" % (description),
                          file=sys.stderr)
                    if self.exception_data is not None:
                        print(self.exception_data, file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_FAILURE

        # Otherwise report the exception
        else:
            print("Request '%s' terminated with an exception: %s\n%s" %
                  (description, repr(exc), self.exception_data),
                  file=sys.stderr)

    def test_success(self):
        if self.status_code not in [200, 302]:
            return False
        if self.status_code == 200 and self.res_data is None:
            return False
        if self.status_code == 200 and \
                len(self.res_data) < GenericRequest.MINIMUM_LENGTH:
            return False
        return True

    def specific_info(self):
        res = "URL: %s\n" % (unicode(self.url))
        if self.response is not None:
            res += "\nREQUEST HEADERS\n"
            for (key, value) in self.response.request.headers.iteritems():
                res += "%s: %s\n" % (key, value)
            res += "\nREQUEST DATA\n%s\n" % self.response.request.body
        else:
            res += "\nNO REQUEST INFORMATION AVAILABLE\n"
        if self.res_data is not None:
            headers = self.response.headers.items()
            res += "\nRESPONSE HEADERS\n%s" % (
                "".join(["%s: %s\n" % (header[0], header[1])
                         for header in headers]))
            res += "\nRESPONSE DATA\n%s\n" % (self.res_data)
        else:
            res += "\nNO RESPONSE INFORMATION AVAILABLE\n"
        return res

    def describe(self):
        raise NotImplementedError("Please subclass this class "
                                  "and actually implement some request")

    def store_to_file(self, fd):
        print("Test type: %s" % (self.__class__.__name__), file=fd)
        print("Execution start time: %s" %
              (datetime.datetime.fromtimestamp(self.start_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Execution stop time: %s" %
              (datetime.datetime.fromtimestamp(self.stop_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Duration: %f seconds" % (self.duration), file=fd)
        print("Outcome: %s" % (self.outcome), file=fd)
        fd.write(self.specific_info())
        if self.exception_data is not None:
            print("", file=fd)
            print("EXCEPTION CASTED", file=fd)
            fd.write(unicode(self.exception_data))


class LoginRequest(GenericRequest):
    """Try to login to CWS or AWS with the given credentials.

    """
    def __init__(self, browser, username, password, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.username = username
        self.password = password
        self.url = '%slogin' % self.base_url                    
        self.data = {'username': self.username,
                     'password': self.password,                    
                     'next': '/'}                    

    def describe(self):
        return "try to login"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        # Additional checks need to be done by the subclasses.
        return True

    def specific_info(self):
        return 'Username: %s\nPassword: %s\n' % \
               (self.username, self.password) + \
            GenericRequest.specific_info(self)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import ast
import io
import os
import sys
import threading
import random
import time

from cms import config, ServiceCoord, get_service_address                    
from cms.db import Contest, SessionGen

import cmstestsuite.web
from cmstestsuite.web import Browser
from cmstestsuite.web.CWSRequests import HomepageRequest, LoginRequest, \                    
    TaskRequest, TaskStatementRequest, SubmitRandomRequest


cmstestsuite.web.debug = True


class RequestLog(object):

    def __init__(self, log_dir=None):
        self.total = 0
        self.success = 0
        self.failure = 0
        self.error = 0
        self.undecided = 0
        self.total_time = 0.0
        self.max_time = 0.0

        self.log_dir = log_dir
        if self.log_dir is not None:
            try:
                os.makedirs(self.log_dir)
            except OSError:
                pass

    def print_stats(self):
        print("TOTAL:          %5d" % (self.total), file=sys.stderr)
        print("SUCCESS:        %5d" % (self.success), file=sys.stderr)
        print("FAIL:           %5d" % (self.failure), file=sys.stderr)
        print("ERROR:          %5d" % (self.error), file=sys.stderr)
        print("UNDECIDED:      %5d" % (self.undecided), file=sys.stderr)
        print("Total time:   %7.3f" % (self.total_time), file=sys.stderr)
        print("Average time: %7.3f" % (self.total_time / self.total),
              file=sys.stderr)
        print("Max time:     %7.3f" % (self.max_time), file=sys.stderr)

    def merge(self, log2):
        self.total += log2.total
        self.success += log2.success
        self.failure += log2.failure
        self.error += log2.error
        self.undecided += log2.undecided
        self.total_time += log2.total_time
        self.max_time = max(self.max_time, log2.max_time)

    def store_to_file(self, request):
        if self.log_dir is None:
            return

        filename = "%s_%s.log" % (request.start_time,
                                  request.__class__.__name__)
        filepath = os.path.join(self.log_dir, filename)
        linkpath = os.path.join(self.log_dir, request.__class__.__name__)
        with io.open(filepath, 'wt', encoding='utf-8') as fd:
            request.store_to_file(fd)
        try:
            os.remove(linkpath)
        except OSError:
            pass
        os.symlink(filename, linkpath)


class ActorDying(Exception):
    """Exception to be raised when an Actor is going to die soon. See
    Actor class.

    """
    pass


class Actor(threading.Thread):
    """Class that simulates the behaviour of a user of the system. It
    performs some requests at randomized times (checking CMS pages,
    doing submissions, ...), checking for their success or failure.

    The probability that the users doing actions depends on the value
    specified in an object called "metrics".

    """

    def __init__(self, username, password, metrics, tasks,
                 log=None, base_url=None, submissions_path=None):
        threading.Thread.__init__(self)

        self.username = username
        self.password = password
        self.metrics = metrics
        self.tasks = tasks
        self.log = log
        self.base_url = base_url
        self.submissions_path = submissions_path

        self.name = "Actor thread for user %s" % (self.username)

        self.browser = Browser()
        self.die = False

    def run(self):
        try:
            print("Starting actor for user %s" % (self.username),
                  file=sys.stderr)
            self.act()

        except ActorDying:
            print("Actor dying for user %s" % (self.username), file=sys.stderr)

    def act(self):
        """Define the behaviour of the actor. Subclasses are expected
        to overwrite this stub method properly.

        """
        raise Exception("Not implemented. Please subclass Action"
                        "and overwrite act().")

    def do_step(self, request):
        self.wait_next()
        self.log.total += 1
        try:
            request.execute()
        except Exception as exc:
            print("Unhandled exception while executing the request: %s" % exc,
                  file=sys.stderr)
            return
        self.log.__dict__[request.outcome] += 1
        self.log.total_time += request.duration
        self.log.max_time = max(self.log.max_time, request.duration)
        self.log.store_to_file(request)

    def wait_next(self):
        """Wait some time. At the moment it waits c*X seconds, where c
        is the time_coeff parameter in metrics and X is an
        exponentially distributed random variable, with parameter
        time_lambda in metrics.

        The total waiting time is divided in lots of little sleep()
        call each one of 0.1 seconds, so that the waiting gets
        interrupted if a die signal arrives.

        If a die signal is received, an ActorDying exception is
        raised.

        """
        SLEEP_PERIOD = 0.1
        time_to_wait = self.metrics['time_coeff'] * \
            random.expovariate(self.metrics['time_lambda'])
        sleep_num = int(time_to_wait / SLEEP_PERIOD)
        remaining_sleep = time_to_wait - (sleep_num * SLEEP_PERIOD)
        for i in xrange(sleep_num):                    
            time.sleep(SLEEP_PERIOD)
            if self.die:
                raise ActorDying()
        time.sleep(remaining_sleep)
        if self.die:
            raise ActorDying()

    def login(self):
        """Log in and check to be logged in."""
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=False,
                                     base_url=self.base_url))                    
        self.do_step(LoginRequest(self.browser,                    
                                  self.username,                    
                                  self.password,                    
                                  base_url=self.base_url))                    
        self.do_step(HomepageRequest(self.browser,
                                     self.username,                    
                                     loggedin=True,
                                     base_url=self.base_url))                    


class RandomActor(Actor):

    def act(self):
        self.login()

        while True:
            choice = random.random()
            task = random.choice(self.tasks)
            if choice < 0.1 and self.submissions_path is not None:
                self.do_step(SubmitRandomRequest(
                    self.browser,
                    task,
                    base_url=self.base_url,
                    submissions_path=self.submissions_path))
            elif choice < 0.6 and task[2] != []:
                self.do_step(TaskStatementRequest(self.browser,
                                                  task[1],
                                                  random.choice(task[2]),
                                                  base_url=self.base_url))                    
            else:
                self.do_step(TaskRequest(self.browser,
                                         task[1],
                                         base_url=self.base_url))                    


class SubmitActor(Actor):

    def act(self):
        self.login()

        # Then keep forever stumbling across user pages
        while True:
            task = random.choice(self.tasks)
            self.do_step(SubmitRandomRequest(
                self.browser,
                task,
                base_url=self.base_url,
                submissions_path=self.submissions_path))


def harvest_contest_data(contest_id):
    """Retrieve the couples username, password and the task list for a
    given contest.

    contest_id (int): the id of the contest we want.
    return (tuple): the first element is a dictionary mapping
                    usernames to passwords; the second one is the list
                    of the task names.

    """
    users = {}
    tasks = []
    with SessionGen() as session:
        contest = Contest.get_from_id(contest_id, session)
        for participation in contest.participations:
            user = participation.user
            users[user.username] = {'password': user.password}
        for task in contest.tasks:
            tasks.append((task.id, task.name, task.statements.keys()))
    return users, tasks


DEFAULT_METRICS = {'time_coeff': 10.0,
                   'time_lambda': 2.0}


def main():
    parser = argparse.ArgumentParser(description="Stress tester for CMS")
    parser.add_argument(
        "-c", "--contest-id", action="store", type=int, required=True,
        help="ID of the contest to test against")
    parser.add_argument(
        "-n", "--actor-num", action="store", type=int,
        help="the number of actors to spawn")
    parser.add_argument(
        "-s", "--sort-actors", action="store_true",
        help="sort usernames alphabetically before slicing them")
    parser.add_argument(
        "-u", "--base-url", action="store", type=utf8_decoder,
        help="base URL for placing HTTP requests")                    
    parser.add_argument(
        "-S", "--submissions-path", action="store", type=utf8_decoder,
        help="base path for submission to send")
    parser.add_argument(
        "-p", "--prepare-path", action="store", type=utf8_decoder,
        help="file to put contest info to")
    parser.add_argument(
        "-r", "--read-from", action="store", type=utf8_decoder,
        help="file to read contest info from")
    parser.add_argument(
        "-t", "--time-coeff", action="store", type=float, default=10.0,
        help="average wait between actions")
    parser.add_argument(
        "-o", "--only-submit", action="store_true",
        help="whether the actor only submits solutions")
    args = parser.parse_args()

    # If prepare_path is specified we only need to save some useful
    # contest data and exit.
    if args.prepare_path is not None:
        users, tasks = harvest_contest_data(args.contest_id)
        contest_data = dict()
        contest_data['users'] = users
        contest_data['tasks'] = tasks
        with io.open(args.prepare_path, "wt", encoding="utf-8") as file_:
            file_.write("%s" % contest_data)
        return

    assert args.time_coeff > 0.0
    assert not (args.only_submit and args.submissions_path == "")

    users = []
    tasks = []

    # If read_from is not specified, read contest data from database
    # if it is specified - read contest data from the file
    if args.read_from is None:
        users, tasks = harvest_contest_data(args.contest_id)
    else:
        with io.open(args.read_from, "rt", encoding="utf-8") as file_:
            contest_data = ast.literal_eval(file_.read())
        users = contest_data['users']
        tasks = contest_data['tasks']

    if args.actor_num is not None:
        user_items = users.items()
        if args.sort_actors:
            user_items.sort()
        else:
            random.shuffle(user_items)
        users = dict(user_items[:args.actor_num])

    # If the base URL is not specified, we try to guess it; anyway,
    # the guess code isn't very smart...
    if args.base_url is not None:
        base_url = args.base_url
    else:
        base_url = "http://%s:%d/" % \
            (get_service_address(ServiceCoord('ContestWebServer', 0))[0],
             config.contest_listen_port[0])

    metrics = DEFAULT_METRICS
    metrics["time_coeff"] = args.time_coeff
    actor_class = RandomActor
    if args.only_submit:
        actor_class = SubmitActor
    actors = [actor_class(username, data['password'], metrics, tasks,
                          log=RequestLog(log_dir=os.path.join('./test_logs',
                                                              username)),
                          base_url=base_url,
                          submissions_path=args.submissions_path)
              for username, data in users.iteritems()]
    for actor in actors:                    
        actor.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Taking down actors", file=sys.stderr)
        for actor in actors:                    
            actor.die = True

    # Uncomment to turn on some memory profiling.
    # from meliae import scanner
    # print("Dumping")
    # scanner.dump_all_objects('objects.json')
    # print("Dump finished")

    finished = False                    
    while not finished:                    
        for actor in actors:                    
            actor.join()                    

    print("Test finished", file=sys.stderr)

    great_log = RequestLog()
    for actor in actors:                    
        great_log.merge(actor.log)

    great_log.print_stats()


if __name__ == '__main__':
    main()

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2013-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2013-2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
# Copyright  2014 Luca Versari <veluca93@gmail.com>
# Copyright  2014 William Di Luigi <williamdiluigi@gmail.com>
# Copyright  2016 Peyman Jabbarzade Ganje <peyman.jabarzade@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import io
import json
import logging
import os
import re
import subprocess
import sys
import time

import requests

from cmstestsuite.web import Browser
from cmstestsuite.web.AWSRequests import \
    AWSLoginRequest, AWSSubmissionViewRequest, AWSUserTestViewRequest
from cmstestsuite.web.CWSRequests import \
    CWSLoginRequest, SubmitRequest, SubmitUserTestRequest


logger = logging.getLogger(__name__)


# CONFIG is populated by our test script.
CONFIG = {
    'VERBOSITY': 0,
}


# cms_config holds the decoded-JSON of the cms.conf configuration file.
cms_config = None


# List of users and tasks we created as part of the test.
created_users = {}
created_tasks = {}


# Information on the administrator running the tests.
admin_info = {}


# Base URLs for AWS and CWS
AWS_BASE_URL = "http://localhost:8889/"                    
CWS_BASE_URL = "http://localhost:8888/"                    


# Persistent browsers to access AWS and CWS.
aws_browser = None
cws_browser = None


def get_aws_browser():
    global aws_browser
    if aws_browser is None:
        aws_browser = Browser()

        lr = AWSLoginRequest(aws_browser,
                             admin_info["username"], admin_info["password"],
                             base_url=AWS_BASE_URL)
        aws_browser.login(lr)
    return aws_browser


def get_cws_browser(user_id):
    global cws_browser
    if cws_browser is None:
        cws_browser = Browser()
        username = created_users[user_id]['username']
        password = created_users[user_id]['password']
        lr = CWSLoginRequest(
            cws_browser, username, password, base_url=CWS_BASE_URL)
        cws_browser.login(lr)
    return cws_browser


class FrameworkException(Exception):
    pass


def read_cms_config():
    global cms_config
    with io.open("%(CONFIG_PATH)s" % CONFIG, "rt") as f:
        cms_config = json.load(f)


def get_cms_config():
    if cms_config is None:
        read_cms_config()
    return cms_config


def sh(cmdline, ignore_failure=False):
    """Execute a simple shell command.

    If cmdline is a string, it is passed to sh -c verbatim.  All escaping must
    be performed by the user. If cmdline is an array, then no escaping is
    required.

    """
    if CONFIG["VERBOSITY"] >= 1:
        # TODO Use shlex.quote in Python 3.3.
        logger.info('$ ' + ' '.join(cmdline))
    kwargs = dict()
    if CONFIG["VERBOSITY"] >= 3:
        # TODO Use subprocess.DEVNULL in Python 3.3.
        kwargs["stdout"] = io.open(os.devnull, "wb")
        kwargs["stderr"] = subprocess.STDOUT
    ret = subprocess.call(cmdline, **kwargs)
    if not ignore_failure and ret != 0:
        raise FrameworkException(
            # TODO Use shlex.quote in Python 3.3.
            "Execution failed with %d/%d. Tried to execute:\n%s\n" %
            (ret & 0xff, ret >> 8, ' '.join(cmdline)))


def configure_cms(options):
    """Creates the cms.conf file, setting any parameters as requested.

    The parameters are substituted in textually, and thus this may be
    quite fragile.

    options (dict): mapping from parameter to textual JSON argument.

    """
    with io.open("%(TEST_DIR)s/config/cms.conf.sample" % CONFIG,
                 "rt", encoding="utf-8") as in_f:
        lines = in_f.readlines()

    unset = set(options.keys())
    for i, line in enumerate(lines):
        g = re.match(r'^(\s*)"([^"]+)":', line)
        if g:
            whitespace, key = g.groups()
            if key in unset:
                lines[i] = '%s"%s": %s,\n' % (whitespace, key, options[key])
                unset.remove(key)

    with io.open("%(CONFIG_PATH)s" % CONFIG, "wt", encoding="utf-8") as out_f:
        for l in lines:
            out_f.write(l)

    if unset:
        print("These configuration items were not set:")
        print("  " + ", ".join(sorted(list(unset))))

    # Load the config database.
    read_cms_config()


def combine_coverage():
    logger.info("Combining coverage results.")
    sh([sys.executable, "-m", "coverage", "combine"])


def initialize_aws(rand):
    """Create an admin and logs in

    rand (int): some random bit to add to the admin username.

    """
    logger.info("Creating admin...")
    admin_info["username"] = "admin%s" % rand
    admin_info["password"] = "adminpwd"
    sh([sys.executable, "cmscontrib/AddAdmin.py", "%(username)s" % admin_info,
        "-p", "%(password)s" % admin_info])


def admin_req(path, args=None, files=None):
    browser = get_aws_browser()
    return browser.do_request(AWS_BASE_URL + path, args, files)                    


def get_tasks():
    '''Return a list of existing tasks, returned as a dictionary of
      'taskname' => { 'id': ..., 'title': ... }

    '''
    r = admin_req('tasks')
    groups = re.findall(r'''
        <tr>\s*
        <td><a\s+href="./task/(\d+)">(.*)</a></td>\s*
        <td>(.*)</td>\s*
        ''', r.text, re.X)
    tasks = {}
    for g in groups:
        id, name, title = g
        id = int(id)
        tasks[name] = {
            'title': title,
            'id': id,
        }

    return tasks


def get_users(contest_id):
    '''Return a list of existing users, returned as a dictionary of
      'username' => { 'id': ..., 'firstname': ..., 'lastname': ... }

    '''
    r = admin_req('contest/' + str(contest_id) + '/users')
    groups = re.findall(r'''
        <tr> \s*
        <td> \s* (.*) \s* </td> \s*
        <td> \s* (.*) \s* </td> \s*
        <td><a\s+href="./user/(\d+)">(.*)</a></td>
    ''', r.text, re.X)
    users = {}
    for g in groups:
        firstname, lastname, id, username = g
        id = int(id)
        users[username] = {
            'firstname': firstname,
            'lastname': lastname,
            'id': id,
        }

    return users


def add_contest(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "description": kwargs.get('description'),
    }
    resp = admin_req('contests/add', args=add_args)
    # Contest ID is returned as HTTP response.
    page = resp.text
    match = re.search(
        r'<form enctype="multipart/form-data" action="../contest/([0-9]+)" '
        'method="POST" name="edit_contest" style="display:inline;">',
        page)
    if match is not None:
        contest_id = int(match.groups()[0])
        admin_req('contest/%s' % contest_id, args=kwargs)
        return contest_id
    else:
        raise FrameworkException("Unable to create contest.")


def add_task(**kwargs):
    add_args = {
        "name": kwargs.get('name'),
        "title": kwargs.get('title'),
    }
    r = admin_req('tasks/add', args=add_args)
    response = r.text
    match_task_id = re.search(r'/task/([0-9]+)$', r.url)
    match_dataset_id = re.search(r'/dataset/([0-9]+)', response)
    if match_task_id and match_dataset_id:
        task_id = int(match_task_id.group(1))
        dataset_id = int(match_dataset_id.group(1))
        edit_args = {}
        for k, v in kwargs.iteritems():
            edit_args[k.replace("{{dataset_id}}", str(dataset_id))] = v
        r = admin_req('task/%s' % task_id, args=edit_args)
        created_tasks[task_id] = kwargs
    else:
        raise FrameworkException("Unable to create task.")

    r = admin_req('contest/' + kwargs["contest_id"] + '/tasks/add',
                  args={"task_id": str(task_id)})
    g = re.search('<input type="radio" name="task_id" value="' +
                  str(task_id) + '"/>', r.text)
    if g:
        return task_id
    else:
        raise FrameworkException("Unable to assign task to contest.")


def add_manager(task_id, manager):
    args = {}
    files = [
        ('manager', manager),
    ]
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/managers/add' % dataset_id, files=files, args=args)


def get_task_active_dataset_id(task_id):
    resp = admin_req('task/%d' % task_id)
    page = resp.text
    match = re.search(
        r'id="title_dataset_([0-9]+).* \(Live\)</',
        page)
    if match is None:
        raise FrameworkException("Unable to create contest.")
    dataset_id = int(match.groups()[0])
    return dataset_id


def add_testcase(task_id, num, input_file, output_file, public):
    files = [
        ('input', input_file),
        ('output', output_file),
    ]
    args = {}
    args["codename"] = "%03d" % num
    if public:
        args['public'] = '1'
    dataset_id = get_task_active_dataset_id(task_id)
    admin_req('dataset/%d/testcases/add' % dataset_id, files=files, args=args)


def add_user(**kwargs):
    r = admin_req('users/add', args=kwargs)
    g = re.search(r'/user/([0-9]+)$', r.url)
    if g:
        user_id = int(g.group(1))
        created_users[user_id] = kwargs
    else:
        raise FrameworkException("Unable to create user.")

    kwargs["user_id"] = user_id
    r = admin_req('contest/' + kwargs["contest_id"] + '/users/add',
                  args=kwargs)
    g = re.search('<input type="radio" name="user_id" value="' +
                  str(user_id) + '"/>', r.text)
    if g:
        return user_id
    else:
        raise FrameworkException("Unable to create participation.")


def add_existing_task(task_id, **kwargs):
    '''Add information about an existing task to our database so that we can
    use it for submitting later.'''
    created_tasks[task_id] = kwargs


def add_existing_user(user_id, **kwargs):
    '''Add information about an existing user to our database so that we can
    use it for submitting later.'''
    created_users[user_id] = kwargs


def cws_submit(contest_id, task_id, user_id, submission_format,
               filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitRequest(browser, task, base_url=CWS_BASE_URL,
                       submission_format=submission_format,
                       filenames=filenames, language=language)
    sr.execute()
    submission_id = sr.get_submission_id()

    if submission_id is None:
        raise FrameworkException("Failed to submit solution.")

    return submission_id


def cws_submit_user_test(contest_id, task_id, user_id, submission_format,
                         filenames, language):
    task = (task_id, created_tasks[task_id]['name'])

    browser = get_cws_browser(user_id)
    sr = SubmitUserTestRequest(
        browser, task, base_url=CWS_BASE_URL,
        submission_format=submission_format,
        filenames=filenames)
    sr.execute()
    user_test_id = sr.get_user_test_id()

    if user_test_id is None:
        raise FrameworkException("Failed to submit user test.")

    return user_test_id


def get_evaluation_result(contest_id, submission_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.|Scoring\.\.\.|Evaluated')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated \(|Scored \(')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSSubmissionViewRequest(browser,
                                      submission_id,
                                      base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_submission_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown submission status: %s" % status)

    raise FrameworkException("Waited too long for submission result.")


def get_user_test_result(contest_id, user_test_id, timeout=60):
    WAITING_STATUSES = re.compile(
        r'Compiling\.\.\.|Evaluating\.\.\.')
    COMPLETED_STATUS = re.compile(
        r'Compilation failed|Evaluated')

    browser = get_aws_browser()
    sleep_interval = 0.1
    while timeout > 0:
        timeout -= sleep_interval

        sr = AWSUserTestViewRequest(browser,
                                    user_test_id,
                                    base_url=AWS_BASE_URL)
        sr.execute()

        result = sr.get_user_test_info()
        status = result['status']

        if COMPLETED_STATUS.search(status):
            return result

        if WAITING_STATUSES.search(status):
            time.sleep(sleep_interval)
            continue

        raise FrameworkException("Unknown user test status: %s" % status)

    raise FrameworkException("Waited too long for user test result.")

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import re

from bs4 import BeautifulSoup

from cmstestsuite.web import GenericRequest, LoginRequest


class AWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        fail_re = re.compile('Failed to log in.')
        if fail_re.search(self.res_data) is not None:
            return False
        username_re = re.compile(self.username)
        if username_re.search(self.res_data) is None:
            return False
        return True


class AWSSubmissionViewRequest(GenericRequest):
    """Load the view of a submission in AWS.

    """
    def __init__(self, browser, submission_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.submission_id = submission_id
        self.url = "%ssubmission/%s" % (self.base_url, submission_id)                    

    def describe(self):
        return "check submission %s" % self.submission_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_submission_info()
            return True
        except:
            return False

    def get_submission_info(self):
        # Only valid after self.execute()
        # Parse submission information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get submission status.
        tag = soup.find_all(id="submission_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.find_all(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = "\n".join(
                [pre.text.strip() for pre in content.findAll("pre")])
        else:
            info['compile_output'] = None

        # Get evaluation results.
        evaluations = []
        tags = soup.find_all(id=re.compile(r"^eval_outcome_"))
        text_tags = soup.find_all(id=re.compile(r"^eval_text_"))
        for outcome_tag, text_tag in zip(tags, text_tags):
            # Get evaluation text also.
            evaluations.append({
                'outcome': outcome_tag.text.strip(),
                'text': text_tag.text.strip(),
            })

        info['evaluations'] = evaluations

        return info


class AWSUserTestViewRequest(GenericRequest):
    """Load the view of a user test in AWS."""
    def __init__(self, browser, user_test_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.user_test_id = user_test_id
        self.url = "%suser_test/%s" % (self.base_url, user_test_id)                    

    def describe(self):
        return "check user_test %s" % self.user_test_id

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        try:
            self.get_user_test_info()
            return True
        except:
            return False

    def get_user_test_info(self):
        # Only valid after self.execute()
        # Parse user test information out of response.
        # "html.parser" is Python's built-in parser. Alternatives that require
        # external dependencies are "lxml" and "html5lib".
        soup = BeautifulSoup(self.res_data, "html.parser")

        info = {}

        # Get user test status.
        tag = soup.findAll(id="user_test_status")[0]
        info['status'] = tag.text.strip()

        # Get compilation text.
        tags = soup.findAll(id="compilation")
        if tags:
            content = tags[0]
            info['compile_output'] = content.pre.text.strip()
        else:
            info['compile_output'] = None

        return info

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2017 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2014 Artem Iglikov <artem.iglikov@gmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import logging
import os
import random
import re
import tempfile

from cms.grading.languagemanager import filename_to_language
from cmscommon.crypto import decrypt_number
from cmstestsuite.web import GenericRequest, LoginRequest


logger = logging.getLogger(__name__)


class CWSLoginRequest(LoginRequest):
    def test_success(self):
        if not LoginRequest.test_success(self):
            return False
        if self.redirected_to != self.base_url:
            return False
        return True


class HomepageRequest(GenericRequest):
    """Load the main page of CWS.

    """
    def __init__(self, browser, username, loggedin, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = self.base_url
        self.username = username
        self.loggedin = loggedin

    def describe(self):
        return "check the main page"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        username_re = re.compile(self.username)
        if self.loggedin:
            if username_re.search(self.res_data) is None:
                return False
        else:
            if username_re.search(self.res_data) is not None:
                return False
        return True


class TaskRequest(GenericRequest):
    """Load a task page in CWS.

    """
    def __init__(self, browser, task_id, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/description" % (self.base_url, task_id)                    
        self.task_id = task_id

    def describe(self):
        return "load page for task %s (%s)" % (self.task_id, self.url)


class TaskStatementRequest(GenericRequest):
    """Load a task statement in CWS.

    """
    def __init__(self, browser, task_id, language_code, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/statements/%s" % (self.base_url,                    
                                                 task_id, language_code)                    
        self.task_id = task_id

    def describe(self):
        return "load statement for task %s (%s)" % (self.task_id, self.url)

    def specific_info(self):
        return '\nNO DATA DUMP FOR TASK STATEMENTS\n'


class SubmitRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        self.files = list(zip(self.submission_format, self.filenames))

    def describe(self):
        return "submit sources %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_submission_id() is not None

    def get_submission_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("?")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            submission_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt submission id from page: `%s'",
                           self.redirected_to)
            return None
        return submission_id


class SubmitUserTestRequest(GenericRequest):
    """Submit a user test in CWS."""
    def __init__(self, browser, task, submission_format,
                 filenames, language=None, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/test" % (self.base_url, task[1])                    
        self.task = task
        self.submission_format = submission_format
        self.filenames = filenames
        self.data = {}
        # If not passed, try to recover the language from the filenames.
        if language is None:
            for filename in filenames:
                lang = filename_to_language(filename)
                if lang is not None:
                    language = lang.name
                    break
        # Only send the language in the request if not None.
        if language is not None:
            self.data = {"language": language}

    def _prepare(self):
        GenericRequest._prepare(self)
        # Let's generate an arbitrary input file.
        # TODO: delete this file once we're done with it.
        _, temp_filename = tempfile.mkstemp()
        self.files = \
            list(zip(self.submission_format, self.filenames)) + \
            [("input", temp_filename)]

    def describe(self):
        return "submit user test %s for task %s (ID %d) %s" % \
            (repr(self.filenames), self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], repr(self.filenames)) + \
            GenericRequest.specific_info(self)

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False

        return self.get_user_test_id() is not None

    def get_user_test_id(self):
        # Only valid after self.execute()
        # Parse submission ID out of redirect.
        if self.redirected_to is None:
            return None

        p = self.redirected_to.split("&")
        if len(p) != 2:
            logger.warning("Redirected to an unexpected page: `%s'",
                           self.redirected_to)
            return None
        try:
            user_test_id = decrypt_number(p[-1])
        except Exception:
            logger.warning("Unable to decrypt user test id from page: `%s'",
                           self.redirected_to)
            return None
        return user_test_id


class TokenRequest(GenericRequest):
    """Release test a submission.

    """
    def __init__(self, browser, task, submission_num, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submissions/%s/token" % (self.base_url,                    
                                                        task[1],
                                                        submission_num)                    
        self.task = task
        self.submission_num = submission_num
        self.data = {}

    def describe(self):
        return "release test the %s-th submission for task %s (ID %d)" % \
            (self.submission_num, self.task[1], self.task[0])

    def specific_info(self):
        return 'Task: %s (ID %d)\nSubmission: %s\n' % \
            (self.task[1], self.task[0], self.submission_num) + \                    
            GenericRequest.specific_info(self)


class SubmitRandomRequest(GenericRequest):
    """Submit a solution in CWS.

    """
    def __init__(self, browser, task, base_url=None,
                 submissions_path=None):
        GenericRequest.__init__(self, browser, base_url)
        self.url = "%stasks/%s/submit" % (self.base_url, task[1])                    
        self.task = task
        self.submissions_path = submissions_path
        self.data = {}

    def _prepare(self):
        """Select a random solution and prepare it for submission.

        If task/ is the task directory, it might contain files (only
        if the submission format is with a single file) and
        directory. If it contains a file, it is assumed that it is the
        only element in the submission format, and is the basename
        without extension of the file. If it is a directory, all files
        inside are assumed to be part of the submission format with
        their basenames without extension.

        """
        GenericRequest._prepare(self)

        # Select a random directory or file inside the task directory.
        task_path = os.path.join(self.submissions_path, self.task[1])
        sources = os.listdir(task_path)
        source = random.choice(sources)
        self.source_path = os.path.join(task_path, source)

        # Compose the submission format
        self.files = []
        if os.path.isdir(self.source_path):
            submission_formats = os.listdir(self.source_path)
            self.files = [('%s.%%l' % (os.path.splitext(sf)[0]),
                           os.path.join(self.source_path, sf))
                          for sf in submission_formats]
        else:
            submission_format = os.path.splitext(source)[0]
            self.files = [('%s.%%l' % (submission_format), self.source_path)]

    def describe(self):
        return "submit source %s for task %s (ID %d) %s" % \
            (self.source_path, self.task[1], self.task[0], self.url)

    def specific_info(self):
        return 'Task: %s (ID %d)\nFile: %s\n' % \
            (self.task[1], self.task[0], self.source_path) + \
            GenericRequest.specific_info(self)

#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Contest Management System - http://cms-dev.github.io/
# Copyright  2012 Bernard Blackham <bernard@largestprime.net>
# Copyright  2010-2012 Giovanni Mascellani <mascellani@poisson.phc.unipi.it>
# Copyright  2010-2016 Stefano Maggiolo <s.maggiolo@gmail.com>
# Copyright  2010-2012 Matteo Boscariol <boscarim@hotmail.com>
# Copyright  2016 Luca Wehrstedt <luca.wehrstedt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import codecs
import datetime
import io
import os
import sys
import time
import traceback
import urllib

import requests


debug = False


class Browser(object):
    def __init__(self):
        self.xsrf_token = None
        self.session = requests.Session()

    def read_xsrf_token(self, url):
        response = self.session.get(url)                    
        for cookie in response.cookies:                    
            if cookie.name == "_xsrf":
                self.xsrf_token = cookie.value

    def login(self, login_request):
        self.read_xsrf_token(login_request.base_url)
        login_request.execute()

    def do_request(self, url, data=None, file_names=None):
        """Open an URL in a mechanize browser, optionally passing the                    
        specified data and files as POST arguments.                    

        browser (mechanize.Browser): the browser to use.                    
        url (string): the URL to open.
        data (dict): a dictionary of parameters to pass as POST
            arguments.
        file_names ([(str, str)]): a list of files to pass as POST
            arguments. Each entry is a tuple containing two strings:
            the field name and the name of the file to send.

        """
        if file_names is None:
            if data is None:
                response = self.session.get(url)                    
            else:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                response = self.session.post(url, data)
        else:
            try:
                data = data.copy()
                data['_xsrf'] = self.xsrf_token
                file_objs = dict((k, io.open(v, "rb")) for k, v in file_names)
                response = self.session.post(url, data, files=file_objs)
            finally:
                for fobj in file_objs.itervalues():
                    fobj.close()
        return response


class GenericRequest(object):
    """Request to a server.

    """

    OUTCOME_SUCCESS = 'success'
    OUTCOME_FAILURE = 'failure'
    OUTCOME_UNDECIDED = 'undecided'
    OUTCOME_ERROR = 'error'

    MINIMUM_LENGTH = 100

    def __init__(self, browser, base_url=None):
        if base_url is None:
            base_url = 'http://localhost:8888/'
        self.browser = browser
        self.base_url = base_url
        self.outcome = None

        self.start_time = None
        self.stop_time = None
        self.duration = None
        self.exception_data = None

        self.url = None
        self.data = None
        self.files = None

        self.status_code = None
        self.response = None
        self.res_data = None
        self.redirected_to = None

    def execute(self):
        """Main entry point to execute the test"""
        self._prepare()
        self._execute()

    def _prepare(self):
        """Optional convenience hook called just after creating the Request"""
        pass

    def _execute(self):
        """Execute the test"""
        description = self.describe()
        self.start_time = time.time()
        try:
            self.response = self.browser.do_request(
                self.url, self.data, self.files)
            self.response.raise_for_status()

            self.status_code = self.response.status_code
            self.res_data = self.response.text

            if len(self.response.history) > 0:
                self.redirected_to = self.response.url

        # Catch possible exceptions
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        else:
            self.outcome = None

        finally:
            self.stop_time = time.time()
            self.duration = self.stop_time - self.start_time

        success = None
        try:
            success = self.test_success()
        except Exception as exc:
            self.exception_data = traceback.format_exc()
            self.outcome = GenericRequest.OUTCOME_ERROR

        # If no exceptions were casted, decode the test evaluation
        if self.outcome is None:

            # Could not decide on the evaluation
            if success is None:
                if debug:
                    print("Could not determine status for request '%s'" %
                          (description), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_UNDECIDED

            # Success
            elif success:
                if debug:
                    print("Request '%s' successfully completed in %.3fs" %
                          (description, self.duration), file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_SUCCESS

            # Failure
            elif not success:
                if debug:
                    print("Request '%s' failed" % (description),
                          file=sys.stderr)
                    if self.exception_data is not None:
                        print(self.exception_data, file=sys.stderr)
                self.outcome = GenericRequest.OUTCOME_FAILURE

        # Otherwise report the exception
        else:
            print("Request '%s' terminated with an exception: %s\n%s" %
                  (description, repr(exc), self.exception_data),
                  file=sys.stderr)

    def test_success(self):
        if self.status_code not in [200, 302]:
            return False
        if self.status_code == 200 and self.res_data is None:
            return False
        if self.status_code == 200 and \
                len(self.res_data) < GenericRequest.MINIMUM_LENGTH:
            return False
        return True

    def specific_info(self):
        res = "URL: %s\n" % (unicode(self.url))
        if self.response is not None:
            res += "\nREQUEST HEADERS\n"
            for (key, value) in self.response.request.headers.iteritems():
                res += "%s: %s\n" % (key, value)
            res += "\nREQUEST DATA\n%s\n" % self.response.request.body
        else:
            res += "\nNO REQUEST INFORMATION AVAILABLE\n"
        if self.res_data is not None:
            headers = self.response.headers.items()
            res += "\nRESPONSE HEADERS\n%s" % (
                "".join(["%s: %s\n" % (header[0], header[1])
                         for header in headers]))
            res += "\nRESPONSE DATA\n%s\n" % (self.res_data)
        else:
            res += "\nNO RESPONSE INFORMATION AVAILABLE\n"
        return res

    def describe(self):
        raise NotImplementedError("Please subclass this class "
                                  "and actually implement some request")

    def store_to_file(self, fd):
        print("Test type: %s" % (self.__class__.__name__), file=fd)
        print("Execution start time: %s" %
              (datetime.datetime.fromtimestamp(self.start_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Execution stop time: %s" %
              (datetime.datetime.fromtimestamp(self.stop_time).
               strftime("%d/%m/%Y %H:%M:%S.%f")), file=fd)
        print("Duration: %f seconds" % (self.duration), file=fd)
        print("Outcome: %s" % (self.outcome), file=fd)
        fd.write(self.specific_info())
        if self.exception_data is not None:
            print("", file=fd)
            print("EXCEPTION CASTED", file=fd)
            fd.write(unicode(self.exception_data))


class LoginRequest(GenericRequest):
    """Try to login to CWS or AWS with the given credentials.

    """
    def __init__(self, browser, username, password, base_url=None):
        GenericRequest.__init__(self, browser, base_url)
        self.username = username
        self.password = password
        self.url = '%slogin' % self.base_url                    
        self.data = {'username': self.username,
                     'password': self.password,                    
                     'next': '/'}                    

    def describe(self):
        return "try to login"

    def test_success(self):
        if not GenericRequest.test_success(self):
            return False
        # Additional checks need to be done by the subclasses.
        return True

    def specific_info(self):
        return 'Username: %s\nPassword: %s\n' % \
               (self.username, self.password) + \
            GenericRequest.specific_info(self)

#!/usr/bin/python
# -*- coding: utf-8 -*-
import os,sys,re,urllib2,json,datetime,hashlib,random
import flask
import markdown
import requests

app = flask.Flask(__name__)
API_ROOT="http://localhost:8080/"
app.config['SECRET_KEY'] = requests.get(API_ROOT + "api/config?key=flask_secret_key").json()["value"]

@app.route('/favicon.ico')
def favicon():
    return "Not found", 404

@app.route('/robots.txt')
def robots():
    return "Not found", 404

@app.route('/', defaults={'path': ''}, methods=['GET','POST'])
@app.route('/<path:path>', methods=['GET','POST'])
def catch_all(path):
    data = {}
    auth_status = {}

    request_headers = {}
    if "Cookie" in flask.request.headers: request_headers["Cookie"] = flask.request.headers["Cookie"]
    if "Content-Type" in flask.request.headers: request_headers["Content-Type"] = flask.request.headers["Content-Type"]
    if "Content-Length" in flask.request.headers:
        content_length = flask.request.headers["Content-Length"]
        if content_length is not None and content_length.isdigit():
            request_headers["Content-Length"] = content_length

    response_headers = {}

    try:
        res = requests.get(API_ROOT + "api/auth/status", headers=request_headers)
        if not res.ok: return "Internel Server Error(api/auth/status failed)", 500
        if "Set-Cookie" in res.headers: response_headers["Set-Cookie"] = res.headers["Set-Cookie"]
        auth_status.update(res.json())

        res = None
        if flask.request.method == "GET":
            res = requests.get(API_ROOT + "site/" + path, headers=request_headers)
        else: # POST
            xsrf_token = flask.session.get("XSRF-TOKEN")
            xsrf_token_hdr = flask.request.headers.get("X-XSRF-TOKEN")
            if xsrf_token is None or xsrf_token_hdr is None or xsrf_token != xsrf_token_hdr:
                return "403 Forbidden(Token mismatch)", 403
            res = requests.post(API_ROOT + "site/" + path, headers=request_headers, data=flask.request.get_data())
        if not res.ok: return "%d %s" % (res.status_code, res.reason), res.status_code
        data.update(res.json())
    except requests.exceptions.ConnectionError:
        return "503 Service temporarily unavailable", 503

    if "user" in auth_status and auth_status["user"]:
        data["login_user"] = auth_status["user"]

    response = None
        
    if "template" in data:
        response = flask.Response(flask.render_template(data["template"], **data))
    else:
        response = flask.jsonify(data)

    for k, v in response_headers.iteritems():
        response.headers[k] = v

    if flask.session.get("XSRF-TOKEN") is None:                    
        xsrf_token = "%030x" % random.randrange(16**30)
        flask.session["XSRF-TOKEN"] = xsrf_token
        response.set_cookie("XSRF-TOKEN", xsrf_token)
        
    return response

@app.template_filter("markdown")
def __markdown(md):
    return markdown.markdown(md, extensions=['gfm'])

@app.template_filter("datetime")
def _datetime(t):
    now = datetime.datetime.fromtimestamp(t / 1000)
    return now.strftime(u"%Y-%m-%d %H:%M")

@app.template_filter("gravater_hash")
def _gravater_hash(email):
    return hashlib.md5(email.lower()).hexdigest()

@app.template_filter("yen")
def _yen(value):
    return u'{:,d}'.format(value)

if __name__ == "__main__":
    if len(sys.argv) > 1:
        API_ROOT = sys.argv[1]
        if not API_ROOT.endswith("/"): API_ROOT += "/"
    print "API_ROOT=%s" % API_ROOT
    app.run(host='0.0.0.0',debug=True)

# Copyright 2014, Rackspace, US, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""API over the nova service.
"""
from collections import OrderedDict

from django.http import HttpResponse                    
from django.template.defaultfilters import slugify                    
from django.utils import http as utils_http
from django.utils.translation import ugettext_lazy as _
from django.views import generic

from horizon import exceptions as hz_exceptions

from novaclient import exceptions

from openstack_dashboard import api
from openstack_dashboard.api.rest import json_encoder
from openstack_dashboard.api.rest import urls
from openstack_dashboard.api.rest import utils as rest_utils
from openstack_dashboard.usage import quotas


@urls.register                    
class Snapshots(generic.View):
    """API for nova snapshots.
    """
    url_regex = r'nova/snapshots/$'

    @rest_utils.ajax(data_required=True)
    def post(self, request):
        instance_id = request.DATA['instance_id']
        name = request.DATA['name']
        result = api.nova.snapshot_create(request,
                                          instance_id=instance_id,
                                          name=name)
        return result


@urls.register                    
class Keypairs(generic.View):
    """API for nova keypairs.
    """
    url_regex = r'nova/keypairs/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of keypairs associated with the current logged-in
        account.

        The listing result is an object with property "items".
        """
        result = api.nova.keypair_list(request)
        return {'items': [u.to_dict() for u in result]}

    @rest_utils.ajax(data_required=True)
    def post(self, request):
        """Create a keypair.

        Create a keypair using the parameters supplied in the POST
        application/json object. The parameters are:

        :param name: the name to give the keypair
        :param public_key: (optional) a key to import

        This returns the new keypair object on success.                    
        """
        if 'public_key' in request.DATA:
            new = api.nova.keypair_import(request, request.DATA['name'],
                                          request.DATA['public_key'])
        else:                    
            new = api.nova.keypair_create(request, request.DATA['name'])
        return rest_utils.CreatedResponse(
            '/api/nova/keypairs/%s' % utils_http.urlquote(new.name),
            new.to_dict()
        )


@urls.register                    
class Keypair(generic.View):                    
    url_regex = r'nova/keypairs/(?P<keypair_name>.+)/$'                    

    def get(self, request, keypair_name):                    
        """Creates a new keypair and associates it to the current project.                    

        * Since the response for this endpoint creates a new keypair and                    
          is not idempotent, it normally would be represented by a POST HTTP                    
          request. However, this solution was adopted as it                    
          would support automatic file download across browsers.                    

        :param keypair_name: the name to associate the keypair to                    
        :param regenerate: (optional) if set to the string 'true',                    
            replaces the existing keypair with a new keypair                    

        This returns the new keypair object on success.                    
        """
        try:                    
            regenerate = request.GET.get('regenerate') == 'true'                    
            if regenerate:                    
                api.nova.keypair_delete(request, keypair_name)                    

            keypair = api.nova.keypair_create(request, keypair_name)                    

        except exceptions.Conflict:                    
            return HttpResponse(status=409)                    

        except Exception:                    
            return HttpResponse(status=500)                    

        else:                    
            response = HttpResponse(content_type='application/binary')                    
            response['Content-Disposition'] = ('attachment; filename=%s.pem'                    
                                               % slugify(keypair_name))                    
            response.write(keypair.private_key)                    
            response['Content-Length'] = str(len(response.content))                    

            return response                    


@urls.register                    
class Services(generic.View):
    """API for nova services.
    """
    url_regex = r'nova/services/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of nova services.
        Will return HTTP 501 status code if the service_list extension is
        not supported.
        """
        if api.base.is_service_enabled(request, 'compute') \
           and api.nova.extension_supported('Services', request):
            result = api.nova.service_list(request)
            return {'items': [u.to_dict() for u in result]}
        else:                    
            raise rest_utils.AjaxError(501, '')


@urls.register                    
class AvailabilityZones(generic.View):
    """API for nova availability zones.
    """
    url_regex = r'nova/availzones/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of availability zones.

        The following get parameters may be passed in the GET
        request:

        :param detailed: If this equals "true" then the result will
            include more detail.

        The listing result is an object with property "items".
        """
        detailed = request.GET.get('detailed') == 'true'
        result = api.nova.availability_zone_list(request, detailed)
        return {'items': [u.to_dict() for u in result]}


@urls.register                    
class Limits(generic.View):
    """API for nova limits.
    """
    url_regex = r'nova/limits/$'

    @rest_utils.ajax(json_encoder=json_encoder.NaNJSONEncoder)
    def get(self, request):
        """Get an object describing the current project limits.

        Note: the Horizon API doesn't support any other project (tenant) but
        the underlying client does...

        The following get parameters may be passed in the GET
        request:

        :param reserved: Take into account the reserved limits. Reserved limits
            may be instances in the rebuild process for example.

        The result is an object with limits as properties.
        """
        reserved = request.GET.get('reserved') == 'true'
        result = api.nova.tenant_absolute_limits(request, reserved)
        return result


@urls.register                    
class ServerActions(generic.View):
    """API over all server actions.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+)/actions/$'

    @rest_utils.ajax()
    def get(self, request, server_id):
        """Get a list of server actions.

        The listing result is an object with property "items". Each item is
        an action taken against the given server.

        Example GET:
        http://localhost/api/nova/servers/abcd/actions/
        """
        actions = api.nova.instance_action_list(request, server_id)
        return {'items': [s.to_dict() for s in actions]}


@urls.register                    
class SecurityGroups(generic.View):
    """API over all server security groups.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+)/security-groups/$'

    @rest_utils.ajax()
    def get(self, request, server_id):
        """Get a list of server security groups.

        The listing result is an object with property "items". Each item is
        security group associated with this server.

        Example GET:
        http://localhost/api/nova/servers/abcd/security-groups/
        """
        groups = api.network.server_security_groups(request, server_id)
        return {'items': [s.to_dict() for s in groups]}


@urls.register                    
class Volumes(generic.View):
    """API over all server volumes.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+)/volumes/$'

    @rest_utils.ajax()
    def get(self, request, server_id):
        """Get a list of server volumes.

        The listing result is an object with property "items". Each item is
        a volume.

        Example GET:
        http://localhost/api/nova/servers/abcd/volumes/
        """
        volumes = api.nova.instance_volumes_list(request, server_id)
        return {'items': [s.to_dict() for s in volumes]}


@urls.register                    
class RemoteConsoleInfo(generic.View):
    """API for remote console information.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+)/console-info/$'

    @rest_utils.ajax()
    def post(self, request, server_id):
        """Gets information about an available remote console for the given
        server.

        Example POST:
        http://localhost/api/nova/servers/abcd/console-info/
        """
        console_type = request.DATA.get('console_type', 'AUTO')
        CONSOLES = OrderedDict([('VNC', api.nova.server_vnc_console),
                                ('SPICE', api.nova.server_spice_console),
                                ('RDP', api.nova.server_rdp_console),
                                ('SERIAL', api.nova.server_serial_console)])

        """Get a tuple of console url and console type."""
        if console_type == 'AUTO':
            check_consoles = CONSOLES
        else:                    
            try:                    
                check_consoles = {console_type: CONSOLES[console_type]}
            except KeyError:
                msg = _('Console type "%s" not supported.') % console_type
                raise hz_exceptions.NotAvailable(msg)

        # Ugly workaround due novaclient API change from 2.17 to 2.18.
        try:                    
            httpnotimplemented = exceptions.HttpNotImplemented
        except AttributeError:
            httpnotimplemented = exceptions.HTTPNotImplemented

        for con_type, api_call in check_consoles.items():
            try:                    
                console = api_call(request, server_id)
            # If not supported, don't log it to avoid lot of errors in case
            # of AUTO.
            except httpnotimplemented:
                continue
            except Exception:                    
                continue

            if con_type == 'SERIAL':
                console_url = console.url
            else:                    
                console_url = "%s&%s(%s)" % (
                              console.url,
                              utils_http.urlencode({'title': _("Console")}),
                              server_id)

            return {"type": con_type, "url": console_url}
        raise hz_exceptions.NotAvailable(_('No available console found.'))


@urls.register                    
class ConsoleOutput(generic.View):
    """API for console output.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+)/console-output/$'

    @rest_utils.ajax()
    def post(self, request, server_id):
        """Get a list of lines of console output.

        The listing result is an object with property "items". Each item is
        a line of output from the server.

        Example GET:
        http://localhost/api/nova/servers/abcd/console-output/
        """
        log_length = request.DATA.get('length', 100)
        console_lines = api.nova.server_console_output(request, server_id,
                                                       tail_length=log_length)
        return {"lines": [x for x in console_lines.split('\n')]}


@urls.register                    
class Servers(generic.View):
    """API over all servers.
    """
    url_regex = r'nova/servers/$'

    _optional_create = [
        'block_device_mapping', 'block_device_mapping_v2', 'nics', 'meta',
        'availability_zone', 'instance_count', 'admin_pass', 'disk_config',
        'config_drive', 'scheduler_hints'
    ]

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of servers.

        The listing result is an object with property "items". Each item is
        a server.

        Example GET:
        http://localhost/api/nova/servers
        """
        servers = api.nova.server_list(request)[0]
        return {'items': [s.to_dict() for s in servers]}

    @rest_utils.ajax(data_required=True)
    def post(self, request):
        """Create a server.

        Create a server using the parameters supplied in the POST
        application/json object. The required parameters as specified by
        the underlying novaclient are:

        :param name: The new server name.
        :param source_id: The ID of the image to use.
        :param flavor_id: The ID of the flavor to use.
        :param key_name: (optional extension) name of previously created
                      keypair to inject into the instance.
        :param user_data: user data to pass to be exposed by the metadata
                      server this can be a file type object as well or a
                      string.
        :param security_groups: An array of one or more objects with a "name"
            attribute.

        Other parameters are accepted as per the underlying novaclient:
        "block_device_mapping", "block_device_mapping_v2", "nics", "meta",
        "availability_zone", "instance_count", "admin_pass", "disk_config",
        "config_drive", "scheduler_hints"

        This returns the new server object on success.
        """
        try:                    
            args = (
                request,
                request.DATA['name'],
                request.DATA['source_id'],
                request.DATA['flavor_id'],
                request.DATA['key_name'],
                request.DATA['user_data'],
                request.DATA['security_groups'],
            )
        except KeyError as e:
            raise rest_utils.AjaxError(400, 'missing required parameter '
                                            "'%s'" % e.args[0])
        kw = {}
        for name in self._optional_create:
            if name in request.DATA:
                kw[name] = request.DATA[name]

        new = api.nova.server_create(*args, **kw)
        return rest_utils.CreatedResponse(
            '/api/nova/servers/%s' % utils_http.urlquote(new.id),
            new.to_dict()
        )


@urls.register                    
class Server(generic.View):
    """API for retrieving a single server
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+|default)$'

    @rest_utils.ajax()
    def get(self, request, server_id):
        """Get a specific server

        http://localhost/api/nova/servers/1
        """
        return api.nova.server_get(request, server_id).to_dict()

    @rest_utils.ajax(data_required=True)
    def post(self, request, server_id):
        """Perform a change to a server
        """
        operation = request.DATA.get('operation', 'none')
        operations = {
            'stop': api.nova.server_stop,
            'start': api.nova.server_start,
            'pause': api.nova.server_pause,
            'unpause': api.nova.server_unpause,
            'suspend': api.nova.server_suspend,
            'resume': api.nova.server_resume,
            'hard_reboot': lambda r, s: api.nova.server_reboot(r, s, False),
            'soft_reboot': lambda r, s: api.nova.server_reboot(r, s, True),
        }
        return operations[operation](request, server_id)

    @rest_utils.ajax()
    def delete(self, request, server_id):
        api.nova.server_delete(request, server_id)


@urls.register                    
class ServerGroups(generic.View):
    """API for nova server groups.
    """
    url_regex = r'nova/servergroups/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of server groups.

        The listing result is an object with property "items".
        """
        result = api.nova.server_group_list(request)
        return {'items': [u.to_dict() for u in result]}


@urls.register                    
class ServerMetadata(generic.View):
    """API for server metadata.
    """
    url_regex = r'nova/servers/(?P<server_id>[^/]+|default)/metadata$'

    @rest_utils.ajax()
    def get(self, request, server_id):
        """Get a specific server's metadata

        http://localhost/api/nova/servers/1/metadata
        """
        return api.nova.server_get(request,
                                   server_id).to_dict().get('metadata')

    @rest_utils.ajax()
    def patch(self, request, server_id):
        """Update metadata items for a server

        http://localhost/api/nova/servers/1/metadata
        """
        updated = request.DATA['updated']
        removed = request.DATA['removed']
        if updated:
            api.nova.server_metadata_update(request, server_id, updated)
        if removed:
            api.nova.server_metadata_delete(request, server_id, removed)


@urls.register                    
class Extensions(generic.View):
    """API for nova extensions.
    """
    url_regex = r'nova/extensions/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of extensions.

        The listing result is an object with property "items". Each item is
        an image.

        Example GET:
        http://localhost/api/nova/extensions
        """
        result = api.nova.list_extensions(request)
        return {'items': [e.to_dict() for e in result]}


@urls.register                    
class Flavors(generic.View):
    """API for nova flavors.
    """
    url_regex = r'nova/flavors/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of flavors.

        The listing result is an object with property "items". Each item is
        a flavor. By default this will return the flavors for the user's
        current project. If the user is admin, public flavors will also be
        returned.

        :param is_public: For a regular user, set to True to see all public
            flavors. For an admin user, set to False to not see public flavors.
        :param get_extras: Also retrieve the extra specs.

        Example GET:
        http://localhost/api/nova/flavors?is_public=true
        """
        is_public = request.GET.get('is_public')
        is_public = (is_public and is_public.lower() == 'true')
        get_extras = request.GET.get('get_extras')
        get_extras = bool(get_extras and get_extras.lower() == 'true')
        flavors = api.nova.flavor_list(request, is_public=is_public,
                                       get_extras=get_extras)
        result = {'items': []}
        for flavor in flavors:
            d = flavor.to_dict()
            if get_extras:
                d['extras'] = flavor.extras
            result['items'].append(d)
        return result

    @rest_utils.ajax(data_required=True)
    def post(self, request):
        flavor_access = request.DATA.get('flavor_access', [])
        flavor_id = request.DATA['id']
        is_public = not flavor_access

        flavor = api.nova.flavor_create(request,
                                        name=request.DATA['name'],
                                        memory=request.DATA['ram'],
                                        vcpu=request.DATA['vcpus'],
                                        disk=request.DATA['disk'],
                                        ephemeral=request
                                        .DATA['OS-FLV-EXT-DATA:ephemeral'],
                                        swap=request.DATA['swap'],
                                        flavorid=flavor_id,
                                        is_public=is_public
                                        )

        for project in flavor_access:
            api.nova.add_tenant_to_flavor(
                request, flavor.id, project.get('id'))

        return rest_utils.CreatedResponse(
            '/api/nova/flavors/%s' % flavor.id,
            flavor.to_dict()
        )


@urls.register                    
class Flavor(generic.View):
    """API for retrieving a single flavor
    """
    url_regex = r'nova/flavors/(?P<flavor_id>[^/]+)/$'

    @rest_utils.ajax()
    def get(self, request, flavor_id):
        """Get a specific flavor

        :param get_extras: Also retrieve the extra specs.

        Example GET:
        http://localhost/api/nova/flavors/1
        """
        get_extras = self.extract_boolean(request, 'get_extras')
        get_access_list = self.extract_boolean(request, 'get_access_list')
        flavor = api.nova.flavor_get(request, flavor_id, get_extras=get_extras)

        result = flavor.to_dict()
        # Bug: nova API stores and returns empty string when swap equals 0
        # https://bugs.launchpad.net/nova/+bug/1408954
        if 'swap' in result and result['swap'] == '':
            result['swap'] = 0
        if get_extras:
            result['extras'] = flavor.extras

        if get_access_list and not flavor.is_public:
            access_list = [item.tenant_id for item in
                           api.nova.flavor_access_list(request, flavor_id)]
            result['access-list'] = access_list
        return result

    @rest_utils.ajax()
    def delete(self, request, flavor_id):
        api.nova.flavor_delete(request, flavor_id)

    @rest_utils.ajax(data_required=True)
    def patch(self, request, flavor_id):
        flavor_access = request.DATA.get('flavor_access', [])
        is_public = not flavor_access

        # Grab any existing extra specs, because flavor edit is currently
        # implemented as a delete followed by a create.
        extras_dict = api.nova.flavor_get_extras(request, flavor_id, raw=True)
        # Mark the existing flavor as deleted.
        api.nova.flavor_delete(request, flavor_id)
        # Then create a new flavor with the same name but a new ID.
        # This is in the same try/except block as the delete call
        # because if the delete fails the API will error out because
        # active flavors can't have the same name.
        flavor = api.nova.flavor_create(request,
                                        name=request.DATA['name'],
                                        memory=request.DATA['ram'],
                                        vcpu=request.DATA['vcpus'],
                                        disk=request.DATA['disk'],
                                        ephemeral=request
                                        .DATA['OS-FLV-EXT-DATA:ephemeral'],
                                        swap=request.DATA['swap'],
                                        flavorid=flavor_id,
                                        is_public=is_public
                                        )
        for project in flavor_access:
            api.nova.add_tenant_to_flavor(
                request, flavor.id, project.get('id'))

        if extras_dict:
            api.nova.flavor_extra_set(request, flavor.id, extras_dict)

    def extract_boolean(self, request, name):
        bool_string = request.GET.get(name)
        return bool(bool_string and bool_string.lower() == 'true')


@urls.register                    
class FlavorExtraSpecs(generic.View):
    """API for managing flavor extra specs
    """
    url_regex = r'nova/flavors/(?P<flavor_id>[^/]+)/extra-specs/$'

    @rest_utils.ajax()
    def get(self, request, flavor_id):
        """Get a specific flavor's extra specs

        Example GET:
        http://localhost/api/nova/flavors/1/extra-specs
        """
        return api.nova.flavor_get_extras(request, flavor_id, raw=True)

    @rest_utils.ajax(data_required=True)
    def patch(self, request, flavor_id):
        """Update a specific flavor's extra specs.

        This method returns HTTP 204 (no content) on success.
        """
        if request.DATA.get('removed'):
            api.nova.flavor_extra_delete(
                request, flavor_id, request.DATA.get('removed')
            )
        api.nova.flavor_extra_set(
            request, flavor_id, request.DATA['updated']
        )


@urls.register                    
class AggregateExtraSpecs(generic.View):
    """API for managing aggregate extra specs
    """
    url_regex = r'nova/aggregates/(?P<aggregate_id>[^/]+)/extra-specs/$'

    @rest_utils.ajax()
    def get(self, request, aggregate_id):
        """Get a specific aggregate's extra specs

        Example GET:
        http://localhost/api/nova/flavors/1/extra-specs
        """
        return api.nova.aggregate_get(request, aggregate_id).metadata

    @rest_utils.ajax(data_required=True)
    def patch(self, request, aggregate_id):
        """Update a specific aggregate's extra specs.

        This method returns HTTP 204 (no content) on success.
        """
        updated = request.DATA['updated']
        if request.DATA.get('removed'):
            for name in request.DATA.get('removed'):
                updated[name] = None
        api.nova.aggregate_set_metadata(request, aggregate_id, updated)


@urls.register                    
class DefaultQuotaSets(generic.View):
    """API for getting default quotas for nova
    """
    url_regex = r'nova/quota-sets/defaults/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get the values for Nova specific quotas

        Example GET:
        http://localhost/api/nova/quota-sets/defaults/
        """
        if api.base.is_service_enabled(request, 'compute'):
            quota_set = api.nova.default_quota_get(request,
                                                   request.user.tenant_id)

            disabled_quotas = quotas.get_disabled_quotas(request)

            filtered_quotas = [quota for quota in quota_set
                               if quota.name not in disabled_quotas]

            result = [{
                'display_name': quotas.QUOTA_NAMES.get(
                    quota.name,
                    quota.name.replace("_", " ").title()
                ) + '',
                'name': quota.name,
                'limit': quota.limit
            } for quota in filtered_quotas]

            return {'items': result}
        else:                    
            raise rest_utils.AjaxError(501, _('Service Nova is disabled.'))

    @rest_utils.ajax(data_required=True)
    def patch(self, request):
        """Update the values for Nova specific quotas

        This method returns HTTP 204 (no content) on success.
        """
        if api.base.is_service_enabled(request, 'compute'):
            disabled_quotas = quotas.get_disabled_quotas(request)

            filtered_quotas = [quota for quota in quotas.NOVA_QUOTA_FIELDS
                               if quota not in disabled_quotas]

            request_data = {
                key: request.DATA.get(key, None) for key in filtered_quotas
            }

            nova_data = {key: value for key, value in request_data.items()
                         if value is not None}

            api.nova.default_quota_update(request, **nova_data)
        else:                    
            raise rest_utils.AjaxError(501, _('Service Nova is disabled.'))


@urls.register                    
class EditableQuotaSets(generic.View):
    """API for editable quotas.
    """
    url_regex = r'nova/quota-sets/editable/$'

    @rest_utils.ajax()
    def get(self, request):
        """Get a list of editable quota fields.

        The listing result is an object with property "items". Each item
        is an editable quota. Returns an empty list in case no editable
        quota is found.
        """
        disabled_quotas = quotas.get_disabled_quotas(request)
        editable_quotas = [quota for quota in quotas.QUOTA_FIELDS
                           if quota not in disabled_quotas]
        return {'items': editable_quotas}


@urls.register                    
class QuotaSets(generic.View):
    """API for setting quotas for a given project.
    """
    url_regex = r'nova/quota-sets/(?P<project_id>[0-9a-f]+)$'

    @rest_utils.ajax(data_required=True)
    def patch(self, request, project_id):
        """Update a single project quota data.

        The PATCH data should be an application/json object with the
        attributes to set to new quota values.

        This method returns HTTP 204 (no content) on success.
        """
        disabled_quotas = quotas.get_disabled_quotas(request)

        if api.base.is_service_enabled(request, 'compute'):
            nova_data = {
                key: request.DATA[key] for key in quotas.NOVA_QUOTA_FIELDS
                if key not in disabled_quotas
            }

            api.nova.tenant_quota_update(request, project_id, **nova_data)
        else:                    
            raise rest_utils.AjaxError(501, _('Service Nova is disabled.'))

# Copyright 2012 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
# Copyright 2012 Nebula, Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import re

from django.utils.translation import ugettext_lazy as _

from horizon import exceptions
from horizon import forms
from horizon import messages

from openstack_dashboard import api


NEW_LINES = re.compile(r"\r|\n")

KEYPAIR_NAME_REGEX = re.compile(r"^\w+(?:[- ]\w+)*$", re.UNICODE)
KEYPAIR_ERROR_MESSAGES = {
    'invalid': _('Key pair name may only contain letters, '
                 'numbers, underscores, spaces, and hyphens '
                 'and may not be white space.')}


class CreateKeypair(forms.SelfHandlingForm):                    
    name = forms.RegexField(max_length=255,                    
                            label=_("Key Pair Name"),                    
                            regex=KEYPAIR_NAME_REGEX,                    
                            error_messages=KEYPAIR_ERROR_MESSAGES)                    

    def handle(self, request, data):                    
        return True  # We just redirect to the download view.

    def clean(self):                    
        cleaned_data = super(CreateKeypair, self).clean()                    
        name = cleaned_data.get('name')                    
        try:                    
            keypairs = api.nova.keypair_list(self.request)                    
        except Exception:                    
            exceptions.handle(self.request, ignore=True)                    
            keypairs = []                    
        if name in [keypair.name for keypair in keypairs]:                    
            error_msg = _("The name is already in use.")                    
            self._errors['name'] = self.error_class([error_msg])                    
        return cleaned_data                    


class ImportKeypair(forms.SelfHandlingForm):
    name = forms.RegexField(max_length=255,                    
                            label=_("Key Pair Name"),                    
                            regex=KEYPAIR_NAME_REGEX,                    
                            error_messages=KEYPAIR_ERROR_MESSAGES)                    
    public_key = forms.CharField(label=_("Public Key"),
                                 widget=forms.Textarea())

    def handle(self, request, data):                    
        try:                    
            # Remove any new lines in the public key
            data['public_key'] = NEW_LINES.sub("", data['public_key'])
            keypair = api.nova.keypair_import(request,
                                              data['name'],
                                              data['public_key'])
            messages.success(request,
                             _('Successfully imported public key: %s')
                             % data['name'])
            return keypair
        except Exception:                    
            exceptions.handle(request, ignore=True)
            self.api_error(_('Unable to import key pair.'))
            return False

# Copyright 2012 Nebula, Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

from django.utils.translation import string_concat
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ungettext_lazy

from horizon import tables

from openstack_dashboard import api
from openstack_dashboard.usage import quotas


class DeleteKeyPairs(tables.DeleteAction):
    policy_rules = (("compute", "os_compute_api:os-keypairs:delete"),)
    help_text = _("Removing a key pair can leave OpenStack resources orphaned."
                  " You should not remove a key pair unless you are certain it"
                  " is not being used anywhere.")

    @staticmethod
    def action_present(count):
        return ungettext_lazy(
            u"Delete Key Pair",
            u"Delete Key Pairs",
            count
        )

    @staticmethod
    def action_past(count):
        return ungettext_lazy(
            u"Deleted Key Pair",
            u"Deleted Key Pairs",
            count
        )

    def delete(self, request, obj_id):
        api.nova.keypair_delete(request, obj_id)


class QuotaKeypairMixin(object):
    def allowed(self, request, datum=None):
        usages = quotas.tenant_quota_usages(request)
        count = len(self.table.data)
        if (usages.get('key_pairs') and usages['key_pairs']['quota'] <= count):
            if "disabled" not in self.classes:
                self.classes = [c for c in self.classes] + ['disabled']
                self.verbose_name = string_concat(self.verbose_name, ' ',
                                                  _("(Quota exceeded)"))
            return False
        else:
            classes = [c for c in self.classes if c != "disabled"]
            self.classes = classes
            return True


class ImportKeyPair(QuotaKeypairMixin, tables.LinkAction):
    name = "import"
    verbose_name = _("Import Key Pair")
    url = "horizon:project:key_pairs:import"
    classes = ("ajax-modal",)                    
    icon = "upload"
    policy_rules = (("compute", "os_compute_api:os-keypairs:create"),)

    def allowed(self, request, keypair=None):
        if super(ImportKeyPair, self).allowed(request, keypair):
            self.verbose_name = _("Import Key Pair")
        return True


class CreateKeyPair(QuotaKeypairMixin, tables.LinkAction):                    
    name = "create"                    
    verbose_name = _("Create Key Pair")
    url = "horizon:project:key_pairs:create"                    
    classes = ("ajax-modal",)                    
    icon = "plus"
    policy_rules = (("compute", "os_compute_api:os-keypairs:create"),)

    def allowed(self, request, keypair=None):
        if super(CreateKeyPair, self).allowed(request, keypair):                    
            self.verbose_name = _("Create Key Pair")
        return True


class KeypairsFilterAction(tables.FilterAction):

    def filter(self, table, keypairs, filter_string):
        """Naive case-insensitive search."""
        query = filter_string.lower()
        return [keypair for keypair in keypairs
                if query in keypair.name.lower()]


class KeyPairsTable(tables.DataTable):
    detail_link = "horizon:project:key_pairs:detail"
    name = tables.Column("name", verbose_name=_("Key Pair Name"),
                         link=detail_link)
    fingerprint = tables.Column("fingerprint", verbose_name=_("Fingerprint"))

    def get_object_id(self, keypair):
        return keypair.name

    class Meta(object):
        name = "keypairs"
        verbose_name = _("Key Pairs")
        table_actions = (CreateKeyPair, ImportKeyPair, DeleteKeyPairs,                    
                         KeypairsFilterAction,)
        row_actions = (DeleteKeyPairs,)

# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Setups a local GAE instance to test against a live server for integration
tests.

It makes sure Google AppEngine SDK is found and starts the server on a free
inbound TCP port.
"""

import cookielib
import logging
import os
import re
import signal
import socket
import subprocess
import tempfile
import time
import sys
import urllib
import urllib2

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
GAE_SDK = None


def _load_modules():
  """Loads all the necessary modules.

  Update sys.path to be able to import chromium-status and GAE SDK.
  """
  global GAE_SDK
  if GAE_SDK:
    return
  root_dir = BASE_DIR
  # First, verify the Google AppEngine SDK is available.
  while True:
    if os.path.isfile(os.path.join(root_dir, 'google_appengine', 'VERSION')):
      break
    next_root = os.path.dirname(root_dir)
    if next_root == root_dir:
      raise Failure(                    
          'Install google_appengine sdk in %s' % os.path.dirname(BASE_DIR))
    root_dir = next_root
  GAE_SDK = os.path.realpath(os.path.join(root_dir, 'google_appengine'))
  # Need yaml later.
  gae_sdk_lib = os.path.realpath(os.path.join(GAE_SDK, 'lib'))
  sys.path.insert(0, os.path.realpath(os.path.join(gae_sdk_lib, 'yaml', 'lib')))


class Failure(Exception):
  pass


def test_port(port):
  s = socket.socket()
  try:
    return s.connect_ex(('127.0.0.1', port)) == 0
  finally:
    s.close()


def find_free_port():                    
  """Finds an available port starting at 8080."""
  port = 8080                    
  max_val = (2<<16)
  while test_port(port) and port < max_val:
    port += 1
  if port == max_val:
    raise Failure('Having issues finding an available port')                    
  return port


class LocalGae(object):
  """Wraps up starting a GAE local instance for integration tests."""

  def __init__(self, base_dir=None):
    """base_dir defaults to .. from the file's directory."""
    # Paths
    self.base_dir = base_dir
    if not self.base_dir:
      self.base_dir = os.path.dirname(os.path.abspath(__file__))
      self.base_dir = os.path.realpath(os.path.join(self.base_dir, '..'))
    self.test_server = None
    self.port = None
    self.app_id = None
    self.url = None
    self.tmp_db = None
    self._xsrf_token = None
    self._cookie_jar = cookielib.CookieJar()
    cookie_processor = urllib2.HTTPCookieProcessor(self._cookie_jar)
    redirect_handler = urllib2.HTTPRedirectHandler()
    self._opener = urllib2.build_opener(redirect_handler, cookie_processor)

  def install_prerequisites(self):
    # Load GAE SDK.
    _load_modules()

    # Now safe to import GAE SDK modules.
    # Unable to import 'yaml'
    # pylint: disable=F0401

    import yaml
    self.app_id = yaml.load(
        open(os.path.join(self.base_dir, 'app.yaml'), 'r'))['application']
    logging.debug('Instance app id: %s' % self.app_id)
    assert self.app_id

  def start_server(self, verbose=False):
    self.install_prerequisites()
    self.port = find_free_port()
    if verbose:
      stdout = None
      stderr = None
    else:
      stdout = subprocess.PIPE
      stderr = subprocess.PIPE
    # Generate a friendly environment.
    env = os.environ.copy()
    env['LANGUAGE'] = 'en'
    h, self.tmp_db = tempfile.mkstemp(prefix='local_gae')
    os.close(h)
    cmd = [
        sys.executable,
        os.path.join(GAE_SDK, 'dev_appserver.py'),
        self.base_dir,
        '--port', str(self.port),
        '--datastore_path', self.tmp_db,
        '--datastore_consistency_policy', 'consistent',
        '--skip_sdk_update_check',
    ]
    if verbose:
      cmd.extend([
          '--log_level', 'debug',
      ])
    self.test_server = subprocess.Popen(
        cmd, stdout=stdout, stderr=stderr, env=env)
    # Loop until port 127.0.0.1:port opens or the process dies.
    while not test_port(self.port):
      self.test_server.poll()                    
      if self.test_server.returncode is not None:                    
        raise Failure(                    
            'Test GAE instance failed early on port %s' %                    
            self.port)
      time.sleep(0.001)                    
    self.url = 'http://localhost:%d/' % self.port

  def stop_server(self):
    if self.test_server:
      # pylint: disable=E1101
      if hasattr(self.test_server, 'kill'):
        self.test_server.kill()
      else:
        os.kill(self.test_server.pid, signal.SIGKILL)
      self.test_server = None
      self.port = None
      self.url = None
      if self.tmp_db:
        try:
          os.remove(self.tmp_db)
        except OSError:
          pass
        self.tmp_db = None

  def get(self, suburl):                    
    request = urllib2.Request(self.url + suburl)                    
    f = self._opener.open(request)
    data = f.read()
    return data

  def post(self, suburl, data):                    
    request = urllib2.Request(self.url + suburl, urllib.urlencode(data))                    
    f = self._opener.open(request)
    return f.read()

  def clear_cookies(self):
    self._cookie_jar.clear()

  def login(self, username, admin):
    try:
      self.get('_ah/login?email=%s&admin=%r&action=Login&continue=/' % (                    
          urllib.quote_plus(username), admin))
    except urllib2.HTTPError:
      # Ignore http errors as the continue url may be inaccessible.
      pass

  def query(self, cmd):
    """Lame way to modify the db remotely on dev server.

    Using remote_api inside the unit test is a bit too invasive.
    """
    data = {
        'code': 'from google.appengine.ext import db\n' + cmd,
        'xsrf_token': self.xsrf_token,
    }
    result = self.post('_ah/admin/interactive/execute', data)                    
    match = re.search(                    
        re.escape(r'<pre id="output">') + r'(.*?)' +                    
        re.escape('</pre>\n</body>\n</html>\n'),                    
        result,                    
        re.DOTALL)                    
    return match.group(1)                    

  @property
  def xsrf_token(self):
    if self._xsrf_token is None:
      self.clear_cookies()
      interactive = self.get(                    
          '_ah/login?email=georges%40example.com&admin=True&action=Login&'                    
          'continue=/_ah/admin/interactive')
      self._xsrf_token = re.search(                    
          r'name="xsrf_token" value="(.*?)"/>', interactive).group(1)                    
      self.clear_cookies()
    return self._xsrf_token

# vim: ts=2:sw=2:tw=80:et:


# Copyright 2015 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Versioned singleton entity with the global configuration."""

import logging

from google.appengine.ext import ndb

from gae_libs.model.versioned_model import VersionedModel


class VersionedConfig(VersionedModel):
  """Singleton entity with the global configuration of the service.

  All changes are stored in the revision log.
  """

  # When this revision of configuration was created.
  updated_ts = ndb.DateTimeProperty(indexed=False, auto_now=True)

  # Who created this revision of configuration.
  updated_by = ndb.StringProperty(indexed=False)

  @classmethod
  def Get(cls, version=None):
    """Returns the version of the config entity, the latest if not specified."""
    config_data = cls.GetVersion(version=version)
    return config_data or cls() if version is None else config_data

  def Update(self, user, is_admin, **kwargs):                    
    """Apply ``kwargs`` dict to the entity and stores the entity if changed."""
    if not is_admin:
      raise Exception('Only admin could update config.')

    dirty = False
    for k, v in kwargs.iteritems():
      assert k in self._properties, k
      if getattr(self, k) != v:
        setattr(self, k, v)
        dirty = True

    if dirty:
      user_name = user.email().split('@')[0]
      self.updated_by = user_name
      self.Save()
      logging.info('Config %s was updated by %s', self.__class__, user_name)

    return dirty


# Copyright 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

from google.appengine.ext import ndb

from gae_libs.handlers.base_handler import BaseHandler
from gae_libs.handlers.base_handler import Permission


def _GetLowerAndUpperBoundCommitPositions(lower_bound, upper_bound):
  if lower_bound is None and upper_bound is None:
    return None, None

  lower_bound = lower_bound if lower_bound is not None else upper_bound
  upper_bound = upper_bound if upper_bound is not None else lower_bound

  return min(lower_bound, upper_bound), max(lower_bound, upper_bound)


def _ValidateInput(lower_bound_commit_position, upper_bound_commit_position,
                   iterations_to_rerun):
  if (lower_bound_commit_position is None and
      upper_bound_commit_position is None):
    return False

  try:
    if lower_bound_commit_position is not None:
      lower_bound_commit_position = int(lower_bound_commit_position)
    if upper_bound_commit_position is not None:
      upper_bound_commit_position = int(upper_bound_commit_position)
    iterations_to_rerun = int(iterations_to_rerun)
    return True
  except ValueError:
    return False


class AnalyzeRegressionRange(BaseHandler):
  PERMISSION_LEVEL = Permission.CORP_USER

  def HandleGet(self):                    
    return self.HandlePost()                    

  def HandlePost(self):
    lower_bound_commit_position = self.request.get(
        'lower_bound_commit_position')
    upper_bound_commit_position = self.request.get(
        'upper_bound_commit_position')
    urlsafe_analysis_key = self.request.get('key')
    iterations_to_rerun = self.request.get('iterations_to_rerun')

    if not _ValidateInput(lower_bound_commit_position,
                          upper_bound_commit_position,
                          iterations_to_rerun):  # pragma: no cover
      return {
          'template': 'error.html',
          'data': {
              'error_message': 'Input format is invalid.',
          },
          'return_code': 400
      }

    analysis = ndb.Key(urlsafe=urlsafe_analysis_key).get()

    if not analysis:  # pragma: no cover
      return {
          'template': 'error.html',
          'data': {
              'error_message': 'Flake analysis was deleted unexpectedly!',
          },
          'return_code': 400
      }

    lower_bound, upper_bound = _GetLowerAndUpperBoundCommitPositions(
        lower_bound_commit_position, upper_bound_commit_position)

    # TODO(lijeffrey): Convert lower/upper bound commit positions to build
    # numbers and pass to recursive_flake_pipeline.
    return {
        'data': {
            'lower_bound_commit_position': lower_bound,
            'upper_bound_commit_position': upper_bound,
            'urlsafe_analysis_key': urlsafe_analysis_key,
            'iterations_to_rerun': iterations_to_rerun
        }
    }


# Copyright 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import mock
import webapp2

from google.appengine.api import users

from handlers.flake import analyze_regression_range
from handlers.flake.analyze_regression_range import AnalyzeRegressionRange
from model.flake.master_flake_analysis import MasterFlakeAnalysis
from waterfall.test import wf_testcase


class AnalyzeRegressionRangeTest(wf_testcase.WaterfallTestCase):
  app_module = webapp2.WSGIApplication([
      ('/waterfall/analyze_regression_range', AnalyzeRegressionRange)],
                                       debug=True)

  def testValidateInput(self):
    self.assertTrue(
        analyze_regression_range._ValidateInput('1', '1', '100'))
    self.assertTrue(
        analyze_regression_range._ValidateInput('2', '1', '100'))
    self.assertTrue(
        analyze_regression_range._ValidateInput(None, '1', '100'))
    self.assertTrue(
        analyze_regression_range._ValidateInput('1', None, '100'))
    self.assertFalse(
        analyze_regression_range._ValidateInput(None, None, '100'))
    self.assertFalse(
        analyze_regression_range._ValidateInput('a', '1', '100'))

  def testGetLowerAndUpperBoundCopmmitPositions(self):
    self.assertEqual(
        (0, 0),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(0, 0))
    self.assertEqual(
        (0, 0),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(None, 0))
    self.assertEqual(
        (0, 0),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(0, None))
    self.assertEqual(
        (None, None),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(
            None, None))
    self.assertEqual(
        (1, 2),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(1, 2))
    self.assertEqual(
        (1, 2),
        analyze_regression_range._GetLowerAndUpperBoundCommitPositions(2, 1))

  @mock.patch.object(users, 'is_current_user_admin', return_value=True)
  def testPost(self, _):                    
    analysis = MasterFlakeAnalysis.Create('m', 'b', 123, 's', 't')
    analysis.put()

    self.mock_current_user(user_email='test@google.com')                    

    response = self.test_app.get('/waterfall/analyze_regression_range', params={                    
        'lower_bound_commit_position': 1,                    
        'upper_bound_commit_position': 2,                    
        'iterations_to_rerun': 100,                    
        'key': analysis.key.urlsafe()                    
    })                    

    self.assertEqual(200, response.status_int)


# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""This module is to handle manual triage of a suspected flake result.

This handler will mark the suspected flake result as correct or incorrect.
"""

from google.appengine.ext import ndb
from google.appengine.api import users

from gae_libs.handlers.base_handler import BaseHandler
from gae_libs.handlers.base_handler import Permission
from libs import analysis_status


def _UpdateSuspectedFlakeAnalysis(key_urlsafe, triage_result, user_name):
  master_flake_analysis = ndb.Key(urlsafe=key_urlsafe).get()

  assert master_flake_analysis
  assert master_flake_analysis.status == analysis_status.COMPLETED
  assert master_flake_analysis.suspected_flake_build_number is not None

  if master_flake_analysis.culprit:
    suspect_info = {
      'culprit_revision': master_flake_analysis.culprit.revision,
      'culprit_commit_position': master_flake_analysis.culprit.commit_position,
      'culprit_url': master_flake_analysis.culprit.url
    }
  else:
    suspect_info = {
        'build_number': master_flake_analysis.suspected_flake_build_number
    }

  master_flake_analysis.UpdateTriageResult(
      triage_result, suspect_info, user_name,
      master_flake_analysis.version_number)
  master_flake_analysis.put()
  return True


class TriageFlakeAnalysis(BaseHandler):
  PERMISSION_LEVEL = Permission.CORP_USER
  LOGIN_REDIRECT_TO_DISTINATION_PAGE_FOR_GET = False

  def HandleGet(self):  # pragma: no cover
    """Sets the manual triage result for the suspected flake analysis."""
    key_urlsafe = self.request.get('key').strip()
    triage_result = self.request.get('triage_result')

    if not key_urlsafe or triage_result is None:
      return {'data': {'success': False}}

    # As the permission level is CORP_USER, we could assume the current user
    # already logged in.
    user_name = users.get_current_user().email().split('@')[0]

    success = _UpdateSuspectedFlakeAnalysis(
        key_urlsafe, int(triage_result), user_name)

    return {'data': {'success': success}}

  def HandlePost(self):  # pragma: no cover
    return self.HandleGet()                    

# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import calendar
from datetime import datetime
import mock

import webapp2

from handlers import triage_suspected_cl
from libs import time_util
from model import analysis_approach_type
from model import result_status
from model import suspected_cl_status
from model.wf_analysis import WfAnalysis
from model.wf_suspected_cl import WfSuspectedCL
from waterfall import buildbot
from waterfall.test import wf_testcase


class TriageSuspectedClTest(wf_testcase.WaterfallTestCase):
  app_module = webapp2.WSGIApplication([
      ('/triage-suspected-cl', triage_suspected_cl.TriageSuspectedCl),
      ], debug=True)

  def setUp(self):
    super(TriageSuspectedClTest, self).setUp()
    self.master_name = 'm'
    self.builder_name = 'b'
    # self.build_number_incomplete = 120  # Analysis is not completed yet.
    self.build_number_1 = 122
    self.build_number_2 = 123
    self.build_key_1 = '%s/%s/%d' % (
        self.master_name, self.builder_name, self.build_number_1)
    self.build_key_2 = '%s/%s/%d' % (
        self.master_name, self.builder_name, self.build_number_2)

    self.repo_name = 'chromium'
    self.revision_1 = 'r1'
    self.commit_position = 123
    self.suspected_cl_1 = {
        'repo_name': self.repo_name,
        'revision': self.revision_1,
        'commit_position': self.commit_position,
        'url': 'https://codereview.chromium.org/123',
    }

    self.revision_2 = 'r2'
    self.suspected_cl_2 = {
        'repo_name': self.repo_name,
        'revision': self.revision_2,
        'commit_position': 111,
        'url': 'https://codereview.chromium.org/111',
    }

    self.mock_current_user(user_email='test@chromium.org', is_admin=True)

  def testSuccessfulTriage(self):                    
    build_url = buildbot.CreateBuildUrl(
      self.master_name, self.builder_name, self.build_number_1)
    response = self.test_app.get(                    
      '/triage-suspected-cl',
      params={
        'url': build_url,
        'status': '0',
        'cl_info': 'chromium/rev1',
        'format': 'json'                    
      })
    self.assertEquals(200, response.status_int)
    self.assertEquals(
      {
        'success': False
      },
      response.json_body)

  def testUpdateSuspectedCLNonFirstTimeFailure(self):
    suspected_cl = WfSuspectedCL.Create(
        self.repo_name, self.revision_1, self.commit_position)

    suspected_cl.builds = {
        self.build_key_1: {
            'failure_type': 'test',
            'failures': {
                's1': ['t1', 't2']
            },
            'status': None,
            'approaches': [analysis_approach_type.HEURISTIC,
                           analysis_approach_type.TRY_JOB],
            'top_score': None,
            'Confidence': 80.0
        }
    }
    suspected_cl.put()
    self.assertTrue(triage_suspected_cl._UpdateSuspectedCL(
        self.repo_name, self.revision_1, self.build_key_2,None))

  def testUpdateSuspectedCLCorrect(self):
    suspected_cl = WfSuspectedCL.Create(
        self.repo_name, self.revision_1, self.commit_position)

    suspected_cl.builds = {
        self.build_key_1: {
            'failure_type': 'test',
            'failures': {
                's1': ['t1', 't2']
            },
            'status': None,
            'approaches': [analysis_approach_type.HEURISTIC,
                           analysis_approach_type.TRY_JOB],
            'top_score': None,
            'Confidence': 80.0
        }
    }
    suspected_cl.put()

    cl_status = suspected_cl_status.CORRECT
    triage_suspected_cl._UpdateSuspectedCL(
        self.repo_name, self.revision_1, self.build_key_1, cl_status)

    suspected_cl = WfSuspectedCL.Get(self.repo_name, self.revision_1)

    self.assertEqual(
        suspected_cl.builds[self.build_key_1]['status'], cl_status)
    self.assertEqual(suspected_cl.status, cl_status)

  def testUpdateSuspectedCLIncorrect(self):
    suspected_cl = WfSuspectedCL.Create(
      self.repo_name, self.revision_1, self.commit_position)

    suspected_cl.builds = {
      self.build_key_1: {
          'failure_type': 'test',
          'failures': {
              's1': ['t1', 't2']
          },
          'status': None,
          'approaches': [analysis_approach_type.HEURISTIC,
                         analysis_approach_type.TRY_JOB],
          'top_score': None,
          'Confidence': 80.0
      }
    }
    suspected_cl.put()

    cl_status = suspected_cl_status.INCORRECT
    triage_suspected_cl._UpdateSuspectedCL(
        self.repo_name, self.revision_1, self.build_key_1, cl_status)

    suspected_cl = WfSuspectedCL.Get(self.repo_name, self.revision_1)

    self.assertEqual(
        suspected_cl.builds[self.build_key_1]['status'], cl_status)
    self.assertEqual(suspected_cl.status, cl_status)


  def testUpdateSuspectedCLPartially(self):
    suspected_cl = WfSuspectedCL.Create(
        self.repo_name, self.revision_1, self.commit_position)

    suspected_cl.builds = {
      self.build_key_1: {
          'failure_type': 'test',
          'failures': {
              's1': ['t1', 't2']
          },
          'status': None,
          'approaches': [analysis_approach_type.HEURISTIC,
                       analysis_approach_type.TRY_JOB],
          'top_score': None,
          'Confidence': 80.0
      },
      self.build_key_2: {
          'failure_type': 'test',
          'failures': {
              's1': ['t1', 't2']
          },
          'status': None,
          'approaches': [analysis_approach_type.HEURISTIC,
                         analysis_approach_type.TRY_JOB],
          'top_score': None,
          'Confidence': 80.0
      }
    }
    suspected_cl.put()

    triage_suspected_cl._UpdateSuspectedCL(
        self.repo_name, self.revision_1, self.build_key_1,
        suspected_cl_status.CORRECT)

    suspected_cl = WfSuspectedCL.Get(self.repo_name, self.revision_1)

    self.assertEqual(
        suspected_cl.builds[self.build_key_1]['status'],
        suspected_cl_status.CORRECT)
    self.assertEqual(
        suspected_cl.status, suspected_cl_status.PARTIALLY_TRIAGED)

    triage_suspected_cl._UpdateSuspectedCL(
        self.repo_name, self.revision_1, self.build_key_2,
        suspected_cl_status.INCORRECT)

    suspected_cl = WfSuspectedCL.Get(self.repo_name, self.revision_1)

    self.assertEqual(
        suspected_cl.builds[self.build_key_2]['status'],
        suspected_cl_status.INCORRECT)
    self.assertEqual(
        suspected_cl.status, suspected_cl_status.PARTIALLY_CORRECT)

  def testUpdateAnalysisNone(self):
    self.assertFalse(triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_1, None
    ))

  def testUpdateAnalysisPartiallyTriaged(self):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)

    analysis.suspected_cls = [self.suspected_cl_1, self.suspected_cl_2]
    analysis.result_status = result_status.FOUND_UNTRIAGED
    analysis.put()

    success = triage_suspected_cl._UpdateAnalysis(
      self.master_name, self.builder_name, self.build_number_1,
      self.repo_name, self.revision_1, suspected_cl_status.CORRECT)

    expected_suspected_cls = [
      {
        'repo_name': self.repo_name,
        'revision': self.revision_1,
        'commit_position': self.commit_position,
        'url': 'https://codereview.chromium.org/123',
        'status': suspected_cl_status.CORRECT
      },
      self.suspected_cl_2
    ]

    analysis = WfAnalysis.Get(
        self.master_name, self.builder_name, self.build_number_1)
    self.assertTrue(success)
    self.assertEqual(analysis.result_status, result_status.FOUND_UNTRIAGED)
    self.assertEqual(analysis.suspected_cls, expected_suspected_cls)

  def testUpdateAnalysisAllCorrect(self):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)

    analysis.suspected_cls = [self.suspected_cl_1, self.suspected_cl_2]
    analysis.result_status = result_status.FOUND_UNTRIAGED
    analysis.put()

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_1, suspected_cl_status.CORRECT)

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_2, suspected_cl_status.CORRECT)

    analysis = WfAnalysis.Get(
        self.master_name, self.builder_name, self.build_number_1)
    self.assertEqual(analysis.result_status, result_status.FOUND_CORRECT)

  def testUpdateAnalysisAllIncorrect(self):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)

    analysis.suspected_cls = [self.suspected_cl_1, self.suspected_cl_2]
    analysis.result_status = result_status.FOUND_UNTRIAGED
    analysis.put()

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_1, suspected_cl_status.INCORRECT)

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_2, suspected_cl_status.INCORRECT)

    analysis = WfAnalysis.Get(
        self.master_name, self.builder_name, self.build_number_1)
    self.assertEqual(analysis.result_status, result_status.FOUND_INCORRECT)

  def testUpdateAnalysisPartiallyCorrect(self):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)

    analysis.suspected_cls = [self.suspected_cl_1, self.suspected_cl_2]
    analysis.result_status = result_status.FOUND_UNTRIAGED
    analysis.put()

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_1, suspected_cl_status.CORRECT)

    triage_suspected_cl._UpdateAnalysis(
        self.master_name, self.builder_name, self.build_number_1,
        self.repo_name, self.revision_2, suspected_cl_status.INCORRECT)

    analysis = WfAnalysis.Get(
        self.master_name, self.builder_name, self.build_number_1)
    self.assertEqual(
        analysis.result_status, result_status.PARTIALLY_CORRECT_FOUND)

  def testAppendTriageHistoryRecordWithHistory(self):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)
    analysis.version = 'version'
    analysis.triage_history = [{'some_info': True}]
    analysis.put()
    cl_info = '%s/%s' % (self.repo_name, self.revision_1)

    mocked_now = datetime(2017, 05, 01, 10, 10, 10)
    mocked_timestamp = calendar.timegm(mocked_now.timetuple())
    self.MockUTCNow(mocked_now)

    triage_suspected_cl._AppendTriageHistoryRecord(
        self.master_name, self.builder_name, self.build_number_1,
        cl_info, suspected_cl_status.CORRECT, 'test')
    analysis = WfAnalysis.Get(
        self.master_name, self.builder_name, self.build_number_1)

    expected_history = [
        {'some_info': True},
        {
          'triage_timestamp': mocked_timestamp,
          'user_name': 'test',
          'cl_status': suspected_cl_status.CORRECT,
          'version': 'version',
          'triaged_cl': cl_info
        }
    ]
    self.assertEqual(analysis.triage_history, expected_history)
    self.assertFalse(analysis.triage_email_obscured)
    self.assertEqual(mocked_now, analysis.triage_record_last_add)

  @mock.patch.object(time_util, 'GetUTCNowTimestamp')
  def testUpdateSuspectedCLAndAnalysis(self, mock_fn):
    analysis = WfAnalysis.Create(
        self.master_name, self.builder_name, self.build_number_1)
    analysis.version = 'version'
    analysis.suspected_cls = [
        self.suspected_cl_1
    ]
    analysis.put()

    suspected_cl = WfSuspectedCL.Create(
        self.repo_name, self.revision_1, self.commit_position)
    suspected_cl.builds = {
      self.build_key_1: {
          'failure_type': 'test',
          'failures': {
              's1': ['t1', 't2']
          },
          'status': None,
          'approaches': [analysis_approach_type.HEURISTIC,
                         analysis_approach_type.TRY_JOB],
          'top_score': None,
          'Confidence': 80.0
      }
    }
    suspected_cl.put()

    cl_info = '%s/%s' % (self.repo_name, self.revision_1)

    mocked_timestamp = calendar.timegm(datetime(2016, 7, 1, 00, 00).timetuple())
    mock_fn.return_value = mocked_timestamp

    success = triage_suspected_cl._UpdateSuspectedCLAndAnalysis(
        self.master_name, self.builder_name, self.build_number_1, cl_info,
        suspected_cl_status.CORRECT, 'test')

    self.assertTrue(success)

# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""This module is to handle manual triage of a suspected CL.

This handler will flag the suspected cl as correct or incorrect.
"""

from google.appengine.api import users
from google.appengine.ext import ndb

from gae_libs.handlers.base_handler import BaseHandler
from gae_libs.handlers.base_handler import Permission
from libs import time_util
from model import result_status
from model import suspected_cl_status
from model.wf_analysis import WfAnalysis
from model.wf_suspected_cl import WfSuspectedCL
from waterfall import build_util
from waterfall import buildbot
from waterfall.suspected_cl_util import GetCLInfo


@ndb.transactional
def _UpdateSuspectedCL(
    repo_name, revision, build_key, cl_status, updated_time=None):
  suspected_cl = WfSuspectedCL.Get(repo_name, revision)
  if (not suspected_cl or not suspected_cl.builds):
    return False

  if not suspected_cl.builds.get(build_key):
    # The failure is not a first time failure.
    # Will not update suspected_cl but will update analysis.
    return True

  suspected_cl.builds[build_key]['status'] = cl_status

  cl_correct = True
  cl_incorrect = True
  partial_triaged = False
  # Checks if all the builds have been triaged and checks the status of the cl
  # on each build.
  # If all the builds are  correct, the cl is correct;
  # If all the builds are incorrect, the cl is incorrect;
  # If some builds are correct while others aren't, the cl is partially correct;
  # If not all the builds have been triaged, the cl is partially triaged.
  for build in suspected_cl.builds.values():
    if build['status'] is None:
      partial_triaged = True
    elif build['status'] == suspected_cl_status.CORRECT:
      cl_incorrect = False
    else:
      cl_correct = False

  if partial_triaged:
    suspected_cl.status = suspected_cl_status.PARTIALLY_TRIAGED
  elif cl_correct:
    suspected_cl.status = suspected_cl_status.CORRECT
  elif cl_incorrect:
    suspected_cl.status = suspected_cl_status.INCORRECT
  else:
    suspected_cl.status = suspected_cl_status.PARTIALLY_CORRECT

  suspected_cl.updated_time = updated_time or time_util.GetUTCNow()

  suspected_cl.put()
  return True


@ndb.transactional
def _UpdateAnalysis(
    master_name, builder_name, build_number, repo_name, revision, cl_status):
  analysis = WfAnalysis.Get(master_name, builder_name, build_number)
  if not analysis or not analysis.suspected_cls:
    return False

  num_correct = 0
  num_incorrect = 0
  for cl in analysis.suspected_cls:
    if cl['repo_name'] == repo_name and cl['revision'] == revision:
      # Updates this cl's status.
      cl['status'] = cl_status

    # Checks if all the cls have been triaged and checks the status of each cl
    # on the build.
    if cl.get('status') == suspected_cl_status.CORRECT:
      num_correct += 1
    elif cl.get('status') == suspected_cl_status.INCORRECT:
      num_incorrect += 1

  if num_correct + num_incorrect == len(analysis.suspected_cls):  # All triaged.
    if num_correct == 0:
      analysis.result_status = result_status.FOUND_INCORRECT
    elif num_incorrect == 0:
      analysis.result_status = result_status.FOUND_CORRECT
    else:
      analysis.result_status = result_status.PARTIALLY_CORRECT_FOUND

  analysis.put()
  return True


def _AppendTriageHistoryRecord(
    master_name, builder_name, build_number, cl_info, cl_status, user_name):

  analysis = WfAnalysis.Get(master_name, builder_name, build_number)
  if not analysis:  # pragma: no cover
    return

  triage_record = {
      'triage_timestamp': time_util.GetUTCNowTimestamp(),
      'user_name': user_name,
      'cl_status': cl_status,
      'version': analysis.version,
      'triaged_cl': cl_info
  }
  if not analysis.triage_history:
    analysis.triage_history = []
  analysis.triage_history.append(triage_record)
  analysis.triage_email_obscured = False
  analysis.triage_record_last_add = time_util.GetUTCNow()

  analysis.put()


def _UpdateSuspectedCLAndAnalysis(
    master_name, builder_name, build_number, cl_info, cl_status, user_name):
  repo_name, revision  = GetCLInfo(cl_info)
  build_key = build_util.CreateBuildId(
      master_name, builder_name, build_number)

  success = (
      _UpdateSuspectedCL(repo_name, revision, build_key, cl_status) and
      _UpdateAnalysis(master_name, builder_name, build_number,
                      repo_name, revision, cl_status))

  if success:
    _AppendTriageHistoryRecord(
        master_name, builder_name, build_number, cl_info, cl_status, user_name)

  return success


class TriageSuspectedCl(BaseHandler):
  PERMISSION_LEVEL = Permission.CORP_USER
  LOGIN_REDIRECT_TO_DISTINATION_PAGE_FOR_GET = False

  def HandleGet(self):  # pragma: no cover
    """Sets the manual triage result for the cl."""
    url = self.request.get('url').strip()
    build_info = buildbot.ParseBuildUrl(url)
    if not build_info:
      return {'data': {'success': False}}
    master_name, builder_name, build_number = build_info

    cl_status = int(self.request.get('status'))
    cl_info = self.request.get('cl_info')
    # As the permission level is CORP_USER, we could assume the current user
    # already logged in.
    user_name = users.get_current_user().email().split('@')[0]
    success = _UpdateSuspectedCLAndAnalysis(
      master_name, builder_name, build_number, cl_info, cl_status, user_name)

    return {'data': {'success': success}}


  def HandlePost(self):  # pragma: no cover
    return self.HandleGet()                    

# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""Utility routines for avoiding cross-site-request-forgery."""

import base64
import hmac
import logging
import time

# This is a file in the top-level directory that you must edit before deploying
import settings
from framework import framework_constants
from services import secrets_svc

# This is how long tokens are valid.
TOKEN_TIMEOUT_SEC = 2 * framework_constants.SECS_PER_HOUR

# The token refresh servlet accepts old tokens to generate new ones, but
# we still impose a limit on how old they can be.
REFRESH_TOKEN_TIMEOUT_SEC = 10 * framework_constants.SECS_PER_DAY

# When the JS on a page decides whether or not it needs to refresh the
# XSRF token before submitting a form, there could be some clock skew,
# so we subtract a little time to avoid having the JS use an existing
# token that the server might consider expired already.
TOKEN_TIMEOUT_MARGIN_SEC = 5 * framework_constants.SECS_PER_MINUTE

# Form tokens and issue stars are limited to only work with the specific
# servlet path for the servlet that processes them.  There are several
# XHR handlers that mainly read data without making changes, so we just
# use 'xhr' with all of them.
XHR_SERVLET_PATH = 'xhr'

DELIMITER = ':'


def GenerateToken(user_id, servlet_path, token_time=None):
  """Return a security token specifically for the given user.

  Args:
    user_id: int user ID of the user viewing an HTML form.
    servlet_path: string URI path to limit the use of the token.
    token_time: Time at which the token is generated in seconds since the
        epoch.  This is used in validation and testing. Defaults to the
        current time.

  Returns:
    A url-safe security token.  The token is a string with the digest
    the user_id and time, followed by plain-text copy of the time that is
    used in validation.

  Raises:
    ValueError: if the XSRF secret was not configured.
  """
  if not user_id:
    return ''  # Don't give tokens out to anonymous visitors.

  token_time = token_time or int(time.time())                    
  digester = hmac.new(secrets_svc.GetXSRFKey())
  digester.update(str(user_id))
  digester.update(DELIMITER)
  digester.update(servlet_path)
  digester.update(DELIMITER)
  digester.update(str(token_time))
  digest = digester.digest()

  token = base64.urlsafe_b64encode('%s%s%d' % (digest, DELIMITER, token_time))
  return token


def ValidateToken(
  token, user_id, servlet_path, now=None, timeout=TOKEN_TIMEOUT_SEC):
  """Return True if the given token is valid for the given scope.

  Args:
    token: String token that was presented by the user.
    user_id: int user ID.
    servlet_path: string URI path to limit the use of the token.
    now: Time in seconds since th epoch.  Defaults to the current time.
        It is explicitly specified only in tests.

  Raises:
    TokenIncorrect: if the token is missing or invalid.
  """
  if not token:
    raise TokenIncorrect('missing token')

  try:
    decoded = base64.urlsafe_b64decode(str(token))
    token_time = long(decoded.split(DELIMITER)[-1])
  except (TypeError, ValueError):
    raise TokenIncorrect('could not decode token')
  now = now or int(time.time())                    

  # The given token should match the generated one with the same time.
  expected_token = GenerateToken(user_id, servlet_path, token_time=token_time)
  if len(token) != len(expected_token):
    raise TokenIncorrect('presented token is wrong size')

  # Perform constant time comparison to avoid timing attacks
  different = 0
  for x, y in zip(token, expected_token):
    different |= ord(x) ^ ord(y)
  if different:
    raise TokenIncorrect(
        'presented token does not match expected token: %r != %r' % (
            token, expected_token))

  # We check expiration last so that we only raise the expriration error
  # if the token would have otherwise been valid.
  if now - token_time > timeout:
    raise TokenIncorrect('token has expired')


def TokenExpiresSec(now=None):
  """Return timestamp when current tokens will expire, minus a safety margin."""
  now = now or int(time.time())                    
  return now + TOKEN_TIMEOUT_SEC - TOKEN_TIMEOUT_MARGIN_SEC


class Error(Exception):
  """Base class for errors from this module."""
  pass


# Caught separately in servlet.py
class TokenIncorrect(Error):
  """The POST body has an incorrect URL Command Attack token."""
  pass



# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""Tests for XSRF utility functions."""

import time
import unittest

from mock import patch

from google.appengine.ext import testbed

import settings
from framework import xsrf


class XsrfTest(unittest.TestCase):
  """Set of unit tests for blocking XSRF attacks."""

  def setUp(self):
    self.testbed = testbed.Testbed()
    self.testbed.activate()
    self.testbed.init_memcache_stub()
    self.testbed.init_datastore_v3_stub()

  def tearDown(self):
    self.testbed.deactivate()

  def testGenerateToken_AnonUserGetsNoToken(self):                    
    self.assertEqual('', xsrf.GenerateToken(0L, '/path'))                    

  def testGenerateToken_DifferentUsersGetDifferentTokens(self):
    self.assertNotEqual(
        xsrf.GenerateToken(111L, '/path'),
        xsrf.GenerateToken(222L, '/path'))

  def testGenerateToken_DifferentPathsGetDifferentTokens(self):
    self.assertNotEqual(
        xsrf.GenerateToken(111L, '/path/one'),
        xsrf.GenerateToken(111L, '/path/two'))

  @patch('time.time')
  def testGenerateToken_CloseTimesGetSameTokens(self, mockTime):
    test_time = 1526671379

    mockTime.return_value = test_time
    token1 = xsrf.GenerateToken(111L, '/path')

    mockTime.return_value = test_time + 1
    token2 = xsrf.GenerateToken(111L, '/path')
    self.assertEqual(token1, token2)

    mockTime.return_value = test_time \
        + xsrf.TOKEN_GRANULARITY_SECONDS \
        - xsrf.TOKEN_TIMEOUT_MARGIN_SEC
    token3 = xsrf.GenerateToken(111L, '/path')
    self.assertEqual(token1, token3)

    mockTime.return_value = test_time + xsrf.TOKEN_GRANULARITY_SECONDS
    token4 = xsrf.GenerateToken(111L, '/path')
    self.assertNotEqual(token1, token4)

  def testValidToken(self):
    token = xsrf.GenerateToken(111L, '/path')
    xsrf.ValidateToken(token, 111L, '/path')  # no exception raised

  def testMalformedToken(self):
    self.assertRaises(
      xsrf.TokenIncorrect,
      xsrf.ValidateToken, 'bad', 111L, '/path')
    self.assertRaises(
      xsrf.TokenIncorrect,
      xsrf.ValidateToken, '', 111L, '/path')

    self.assertRaises(
        xsrf.TokenIncorrect,
        xsrf.ValidateToken, '098a08fe08b08c08a05e:9721973123', 111L, '/path')

  def testWrongUser(self):
    token = xsrf.GenerateToken(111L, '/path')
    self.assertRaises(
      xsrf.TokenIncorrect,
      xsrf.ValidateToken, token, 222L, '/path')

  def testWrongPath(self):
    token = xsrf.GenerateToken(111L, '/path/one')
    self.assertRaises(
      xsrf.TokenIncorrect,
      xsrf.ValidateToken, token, 111L, '/path/two')

  @patch('time.time')
  def testValidateToken_Expiration(self, mockTime):
    test_time = 1526671379
    mockTime.return_value = test_time
    token = xsrf.GenerateToken(111L, '/path')
    xsrf.ValidateToken(token, 111L, '/path')

    mockTime.return_value = test_time + 1
    xsrf.ValidateToken(token, 111L, '/path')

    mockTime.return_value = test_time + xsrf.TOKEN_TIMEOUT_SEC
    xsrf.ValidateToken(token, 111L, '/path')

    mockTime.return_value = test_time + xsrf.TOKEN_TIMEOUT_SEC + 1
    self.assertRaises(
      xsrf.TokenIncorrect,
      xsrf.ValidateToken, token, 11L, '/path')

  @patch('time.time')
  def testGetRoundedTime(self, mockTime):
    mockTime.return_value = 1526344117
    self.assertEqual(1526343600, xsrf.GetRoundedTime())

    # When it divides evenly by 10 minutes (600 seconds).
    mockTime.return_value = 1526344200
    self.assertEqual(1526344200, xsrf.GetRoundedTime())

# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""Utility routines for avoiding cross-site-request-forgery."""

import base64
import hmac
import logging
import time

# This is a file in the top-level directory that you must edit before deploying
import settings
from framework import framework_constants
from services import secrets_svc

# This is how long tokens are valid.
TOKEN_TIMEOUT_SEC = 2 * framework_constants.SECS_PER_HOUR

# The token refresh servlet accepts old tokens to generate new ones, but
# we still impose a limit on how old they can be.
REFRESH_TOKEN_TIMEOUT_SEC = 10 * framework_constants.SECS_PER_DAY

# When the JS on a page decides whether or not it needs to refresh the
# XSRF token before submitting a form, there could be some clock skew,
# so we subtract a little time to avoid having the JS use an existing
# token that the server might consider expired already.
TOKEN_TIMEOUT_MARGIN_SEC = 5 * framework_constants.SECS_PER_MINUTE

# Form tokens and issue stars are limited to only work with the specific
# servlet path for the servlet that processes them.  There are several
# XHR handlers that mainly read data without making changes, so we just
# use 'xhr' with all of them.
XHR_SERVLET_PATH = 'xhr'

# Return the same XSRF token within a 10 minute period to allow the same
# token to be used in multiple requests by the same user. Quickly changing the
# XSRF token defeats URL-based caching. More context in crbug.com/monorail/3814.
TOKEN_GRANULARITY_SECONDS = 10 * framework_constants.SECS_PER_MINUTE

DELIMITER = ':'


def GenerateToken(user_id, servlet_path, token_time=None):
  """Return a security token specifically for the given user.

  Args:
    user_id: int user ID of the user viewing an HTML form.
    servlet_path: string URI path to limit the use of the token.
    token_time: Time at which the token is generated in seconds since the epoch.

  Returns:
    A url-safe security token.  The token is a string with the digest
    the user_id and time, followed by plain-text copy of the time that is
    used in validation.

  Raises:
    ValueError: if the XSRF secret was not configured.
  """
  if not user_id:                    
    return ''  # Don't give tokens out to anonymous visitors.

  token_time = token_time or GetRoundedTime()
  digester = hmac.new(secrets_svc.GetXSRFKey())
  digester.update(str(user_id))
  digester.update(DELIMITER)
  digester.update(servlet_path)
  digester.update(DELIMITER)
  digester.update(str(token_time))
  digest = digester.digest()

  token = base64.urlsafe_b64encode('%s%s%d' % (digest, DELIMITER, token_time))
  return token


def ValidateToken(
  token, user_id, servlet_path, timeout=TOKEN_TIMEOUT_SEC):
  """Return True if the given token is valid for the given scope.

  Args:
    token: String token that was presented by the user.
    user_id: int user ID.
    servlet_path: string URI path to limit the use of the token.

  Raises:
    TokenIncorrect: if the token is missing or invalid.
  """
  if not token:
    raise TokenIncorrect('missing token')

  try:
    decoded = base64.urlsafe_b64decode(str(token))
    token_time = long(decoded.split(DELIMITER)[-1])
  except (TypeError, ValueError):
    raise TokenIncorrect('could not decode token')
  now = GetRoundedTime()

  # The given token should match the generated one with the same time.
  expected_token = GenerateToken(user_id, servlet_path, token_time=token_time)
  if len(token) != len(expected_token):
    raise TokenIncorrect('presented token is wrong size')

  # Perform constant time comparison to avoid timing attacks
  different = 0
  for x, y in zip(token, expected_token):
    different |= ord(x) ^ ord(y)
  if different:
    raise TokenIncorrect(
        'presented token does not match expected token: %r != %r' % (
            token, expected_token))

  # We check expiration last so that we only raise the expriration error
  # if the token would have otherwise been valid.
  if now - token_time > timeout:
    raise TokenIncorrect('token has expired')


def TokenExpiresSec():
  """Return timestamp when current tokens will expire, minus a safety margin."""
  now = GetRoundedTime()
  return now + TOKEN_TIMEOUT_SEC - TOKEN_TIMEOUT_MARGIN_SEC


def GetRoundedTime():
  now = int(time.time())
  rounded = now - (now % TOKEN_GRANULARITY_SECONDS)
  return rounded

class Error(Exception):
  """Base class for errors from this module."""
  pass


# Caught separately in servlet.py
class TokenIncorrect(Error):
  """The POST body has an incorrect URL Command Attack token."""
  pass

# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""ts_mon JavaScript proxy handler."""

from framework import authdata
from framework import sql
from framework import xsrf

from gae_ts_mon.handlers import TSMonJSHandler

from google.appengine.api import users

from infra_libs import ts_mon


ISSUE_CREATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_create_latency', (
    'Latency between Issue Entry form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=[ts_mon.StringField('client_id')])
ISSUE_UPDATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_update_latency', (
    'Latency between Issue Update form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=[ts_mon.StringField('client_id')])
AUTOCOMPLETE_POPULATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/autocomplete_populate_latency', (
    'Latency between page load and autocomplete options loading.'
  ), field_spec=[ts_mon.StringField('client_id')])


class MonorailTSMonJSHandler(TSMonJSHandler):

  def __init__(self, request=None, response=None):
    super(MonorailTSMonJSHandler, self).__init__(request, response)
    self.register_metrics([
        ISSUE_CREATE_LATENCY_METRIC,
        ISSUE_UPDATE_LATENCY_METRIC,
        AUTOCOMPLETE_POPULATE_LATENCY_METRIC])

  def xsrf_is_valid(self, body):                    
    """This method expects the body dictionary to include two fields:
    `token` and `user_id`.
    """
    cnxn = sql.MonorailConnection()                    
    token = body.get('token')                    
    user = users.get_current_user()                    
    email = user.email() if user else None                    

    services = self.app.config.get('services')                    
    auth = authdata.AuthData.FromEmail(cnxn, email, services, autocreate=False)                    
    try:                    
      xsrf.ValidateToken(token, auth.user_id, xsrf.XHR_SERVLET_PATH)                    
      return True                    
    except xsrf.TokenIncorrect:
      return False                    

# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""ts_mon JavaScript proxy handler."""

from framework import authdata
from framework import sql
from framework import xsrf

from gae_ts_mon.handlers import TSMonJSHandler

from google.appengine.api import users

from infra_libs import ts_mon


STANDARD_FIELDS = [
  ts_mon.StringField('client_id'),
  ts_mon.StringField('host_name'),
]


ISSUE_CREATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_create_latency', (
    'Latency between Issue Entry form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=STANDARD_FIELDS)
ISSUE_UPDATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_update_latency', (
    'Latency between Issue Update form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=STANDARD_FIELDS)
AUTOCOMPLETE_POPULATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/autocomplete_populate_latency', (
    'Latency between page load and autocomplete options loading.'
  ), field_spec=STANDARD_FIELDS)


class MonorailTSMonJSHandler(TSMonJSHandler):

  def __init__(self, request=None, response=None):
    super(MonorailTSMonJSHandler, self).__init__(request, response)
    self.register_metrics([
        ISSUE_CREATE_LATENCY_METRIC,
        ISSUE_UPDATE_LATENCY_METRIC,
        AUTOCOMPLETE_POPULATE_LATENCY_METRIC])

  def xsrf_is_valid(self, body):                    
    """This method expects the body dictionary to include two fields:
    `token` and `user_id`.
    """
    cnxn = sql.MonorailConnection()                    
    token = body.get('token')                    
    user = users.get_current_user()                    
    email = user.email() if user else None                    

    services = self.app.config.get('services')                    
    auth = authdata.AuthData.FromEmail(cnxn, email, services, autocreate=False)                    
    try:                    
      xsrf.ValidateToken(token, auth.user_id, xsrf.XHR_SERVLET_PATH)                    
      return True                    
    except xsrf.TokenIncorrect:
      return False                    

# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""Unit tests for issuelistcsv module."""

import unittest

from framework import permissions
from services import service_manager
from testing import testing_helpers
from features import hotlistissuescsv


class HotlistIssuesCsvTest(unittest.TestCase):

  def setUp(self):
    self.services = service_manager.Services()                    
    self.servlet = hotlistissuescsv.HotlistIssuesCsv(
        'req', 'res', services=self.services)                    

  def testGatherPageData_AnonUsers(self):
    """Anonymous users cannot download the issue list."""
    mr = testing_helpers.MakeMonorailRequest()                    
    mr.auth.user_id = 0                    
    self.assertRaises(permissions.PermissionException,
                      self.servlet.GatherPageData, mr)                    

# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

import functools
import logging
import sys
import time
from google.appengine.api import oauth

from google.appengine.api import users
from google.protobuf import json_format
from components.prpc import codes
from components.prpc import server

from infra_libs.ts_mon.common import http_metrics

import settings
from framework import exceptions
from framework import framework_bizobj
from framework import framework_constants
from framework import monorailcontext
from framework import ratelimiter
from framework import permissions
from framework import sql
from framework import xsrf
from services import client_config_svc
from services import features_svc


def ConvertPRPCStatusToHTTPStatus(context):
  """pRPC uses internal codes 0..16, but we want to report HTTP codes."""
  return server._PRPC_TO_HTTP_STATUS.get(context._code, 500)


def PRPCMethod(func):
  @functools.wraps(func)
  def wrapper(self, request, prpc_context, cnxn=None, auth=None):
    return self.Run(
        func, request, prpc_context, cnxn=cnxn, auth=auth)

  wrapper.wrapped = func
  return wrapper


class MonorailServicer(object):
  """Abstract base class for API servicers.
  """

  def __init__(self, services, make_rate_limiter=True, xsrf_timeout=None):
    self.services = services
    if make_rate_limiter:
      self.rate_limiter = ratelimiter.ApiRateLimiter()
    else:
      self.rate_limiter = None
    # We allow subclasses to specify a different timeout. This allows the
    # RefreshToken method to check the token with a longer expiration and
    # generate a new one.
    self.xsrf_timeout = xsrf_timeout or xsrf.TOKEN_TIMEOUT_SEC

  def Run(
      self, handler, request, prpc_context,
      cnxn=None, auth=None, perms=None, start_time=None, end_time=None):
    """Run a Do* method in an API context.

    Args:
      handler: API handler method to call with MonorailContext and request.
      request: API Request proto object.
      prpc_context: pRPC context object with status code.
      cnxn: Optional connection to SQL database.
      auth: AuthData passed in during testing.
      perms: PermissionSet passed in during testing.
      start_time: Int timestamp passed in during testing.
      end_time: Int timestamp passed in during testing.

    Returns:
      The response proto returned from the handler or None if that
      method raised an exception that we handle.

    Raises:
      Only programming errors should be raised as exceptions.  All
      execptions for permission checks and input validation that are
      raised in the Do* method are converted into pRPC status codes.
    """
    start_time = start_time or time.time()
    cnxn = cnxn or sql.MonorailConnection()
    if self.services.cache_manager:
      self.services.cache_manager.DoDistributedInvalidation(cnxn)

    response = None
    client_id = None  # TODO(jrobbins): consider using client ID.
    requester = None
    mc = None
    try:
      requester = auth.email if auth else self.GetRequester(request)                    
      logging.info('request proto is:\n%r\n', request)
      logging.info('requester is %r', requester)

      if self.rate_limiter:
        self.rate_limiter.CheckStart(client_id, requester, start_time)
      mc = monorailcontext.MonorailContext(
          self.services, cnxn=cnxn, requester=requester, auth=auth, perms=perms)
      if not perms:
        mc.LookupLoggedInUserPerms(self.GetRequestProject(mc.cnxn, request))
      self.AssertBaseChecks(mc, request)                    
      response = handler(self, mc, request)

    except Exception as e:
      if not self.ProcessException(e, prpc_context, mc):
        raise e.__class__, e, sys.exc_info()[2]
    finally:
      if mc:
        mc.CleanUp()
      if self.rate_limiter and requester:
        end_time = end_time or time.time()
        self.rate_limiter.CheckEnd(client_id, requester, end_time, start_time)
      self.RecordMonitoringStats(start_time, request, response, prpc_context)

    return response

  def GetRequester(self, request):                    
    """Return the email address of the signed in user or None."""
    # When running on localhost, allow request to specify test account.
    if hasattr(request, 'trace') and request.trace.test_account:                    
      if not settings.local_mode:
        raise exceptions.InputException(
            'test_account only accepted in local_mode')                    
      if not request.trace.test_account.endswith('@example.com'):                    
        raise exceptions.InputException(
            'test_account must end with @example.com')
      logging.info('Using test_account: %r' % request.trace.test_account)                    
      return request.trace.test_account                    

    # Cookie-based auth
    user = users.get_current_user()
    if user:
      logging.info('Using cookie user: %r', user.email())
      return user.email()

    # Oauth
    try:
      user = oauth.get_current_user(framework_constants.OAUTH_SCOPE)
      if user:
        logging.info('Oauth requester %s', user.email())
        return user.email()
    except oauth.Error as ex:
      logging.info('Got oauth error: %r', ex)

    return None

  def AssertBaseChecks(self, mc, request):                    
    """Reject requests that we refuse to serve."""
    # TODO(jrobbins): Add read_only check as an exception raised in sql.py.
    if (settings.read_only and
        not request.__class__.__name__.startswith(('Get', 'List'))):
      raise permissions.PermissionException(
          'This request is not allowed in read-only mode')

    if permissions.IsBanned(mc.auth.user_pb, mc.auth.user_view):
      raise permissions.BannedUserException(
          'The user %s has been banned from using this site' %
          mc.auth.email)

    if request.trace.reason:                    
      logging.info('Request reason: %r', request.trace.reason)                    
    if request.trace.request_id:                    
      # TODO(jrobbins): Ignore requests with duplicate request_ids.
      logging.info('request_id: %r', request.trace.request_id)                    
    self.AssertWhitelistedOrXSRF(mc, request)                    

  def AssertWhitelistedOrXSRF(self, mc, request):                    
    """Raise an exception if we don't want to process this request."""
    # For local development, we accept any request.
    # TODO(jrobbins): make this more realistic by requiring a fake XSRF token.
    if settings.local_mode:
      return

    # Check if the user is whitelisted.
    auth_client_ids, auth_emails = (
        client_config_svc.GetClientConfigSvc().GetClientIDEmails())
    if mc.auth.user_pb.email in auth_emails:
      logging.info('User %r is whitelisted to use any client',
                   mc.auth.user_pb.email)
      return

    # Check if the client is whitelisted.
    client_id = None
    try:
      client_id = oauth.get_client_id(framework_constants.OAUTH_SCOPE)
      logging.info('Oauth client ID %s', client_id)
    except oauth.Error as ex:
      logging.info('oauth.Error: %s' % ex)

    if client_id in auth_client_ids:
      logging.info('Client %r is whitelisted for any user', client_id)
      return

    # Otherwise, require an XSRF token generated by our app UI.
    logging.info('Neither email nor client ID is whitelisted, checking XSRF')
    xsrf.ValidateToken(
        request.trace.token, mc.auth.user_id, xsrf.XHR_SERVLET_PATH,                    
        timeout=self.xsrf_timeout)

  def GetRequestProject(self, cnxn, request):
    """Return the Project business object that the user is viewing or None."""
    if hasattr(request, 'project_name'):
        project = self.services.project.GetProjectByName(
            cnxn, request.project_name)
        if not project:
          logging.info('Request has project_name: %r but it does not exist.',
                       request.project_name)
          return None
        return project
    else:
      return None

  def ProcessException(self, e, prpc_context, mc):
    """Return True if we convert an exception to a pRPC status code."""
    logging.exception(e)
    logging.info(e.message)
    exc_type = type(e)
    if exc_type == exceptions.NoSuchUserException:
      prpc_context.set_code(codes.StatusCode.NOT_FOUND)
      prpc_context.set_details('The user does not exist.')
    elif exc_type == exceptions.NoSuchProjectException:
      prpc_context.set_code(codes.StatusCode.NOT_FOUND)
      prpc_context.set_details('The project does not exist.')
    elif exc_type == exceptions.NoSuchTemplateException:
      prpc_context.set_code(codes.StatusCode.NOT_FOUND)
      prpc_context.set_details('The template does not exist.')
    elif exc_type == exceptions.NoSuchIssueException:
      prpc_context.set_code(codes.StatusCode.NOT_FOUND)
      prpc_context.set_details('The issue does not exist.')
    elif exc_type == exceptions.NoSuchCommentException:
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('No such comment')
    elif exc_type == exceptions.NoSuchComponentException:
      prpc_context.set_code(codes.StatusCode.NOT_FOUND)
      prpc_context.set_details('The component does not exist.')
    elif exc_type == permissions.BannedUserException:
      prpc_context.set_code(codes.StatusCode.PERMISSION_DENIED)
      prpc_context.set_details('The requesting user has been banned.')
    elif exc_type == permissions.PermissionException:
      logging.info('perms is %r', mc.perms)
      prpc_context.set_code(codes.StatusCode.PERMISSION_DENIED)
      prpc_context.set_details('Permission denied.')
    elif exc_type == exceptions.GroupExistsException:
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('The user group already exists.')
    elif exc_type == features_svc.HotlistAlreadyExists:
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('A hotlist with that name already exists.')
    elif exc_type == exceptions.InvalidComponentNameException:
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('That component name is invalid.')
    elif exc_type == exceptions.InputException:
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('Invalid arguments: %s' % e.message)
    elif exc_type == ratelimiter.ApiRateLimitExceeded:
      prpc_context.set_code(codes.StatusCode.PERMISSION_DENIED)
      prpc_context.set_details('The requester has exceeded API quotas limit.')
    elif exc_type == oauth.InvalidOAuthTokenError:
      prpc_context.set_code(codes.StatusCode.UNAUTHENTICATED)
      prpc_context.set_details(
          'The oauth token was not valid or must be refreshed.')
    elif exc_type == xsrf.TokenIncorrect:
      logging.info('Bad XSRF token: %r', e.message)
      prpc_context.set_code(codes.StatusCode.INVALID_ARGUMENT)
      prpc_context.set_details('Bad XSRF token.')
    else:
      return False  # Re-raise any exception from programming errors.
    return True  # It if was one of the cases above, don't reraise.

  def RecordMonitoringStats(
      self, start_time, request, response, prpc_context, now=None):
    """Record monitoring info about this request."""
    now = now or time.time()
    elapsed_ms = int((now - start_time) * 1000)
    method_name = request.__class__.__name__
    if method_name.endswith('Request'):
      method_name = method_name[:-len('Request')]
    method_identifier = 'monorail.' + method_name
    fields = {
        # pRPC uses its own statuses, but we report HTTP status codes.
        'status': ConvertPRPCStatusToHTTPStatus(prpc_context),
        # Use the api name, not the request path, to prevent an
        # explosion in possible field values.
        'name': method_identifier,
        'is_robot': False,
        }

    http_metrics.server_durations.add(elapsed_ms, fields=fields)
    http_metrics.server_response_status.increment(fields=fields)
    http_metrics.server_request_bytes.add(
        len(json_format.MessageToJson(request)), fields=fields)
    response_size = 0
    if response:
      response_size = len(json_format.MessageToJson(response))
      http_metrics.server_response_bytes.add(response_size, fields=fields)


# Copyright 2018 The Chromium Authors. All rights reserved.
# Use of this source code is govered by a BSD-style
# license that can be found in the LICENSE file or at
# https://developers.google.com/open-source/licenses/bsd

"""ts_mon JavaScript proxy handler."""

from framework import authdata
from framework import sql
from framework import xsrf

from gae_ts_mon.handlers import TSMonJSHandler

from google.appengine.api import users

from infra_libs import ts_mon


STANDARD_FIELDS = [
  ts_mon.StringField('client_id'),
  ts_mon.StringField('host_name'),
  ts_mon.BooleanField('document_visible'),
]


# User action metrics.
ISSUE_CREATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_create_latency', (
    'Latency between Issue Entry form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=STANDARD_FIELDS,
  units=ts_mon.MetricsDataUnits.MILLISECONDS)
ISSUE_UPDATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/issue_update_latency', (
    'Latency between Issue Update form submission and page load of '
    'the subsequent issue page.'
  ), field_spec=STANDARD_FIELDS,
  units=ts_mon.MetricsDataUnits.MILLISECONDS)
AUTOCOMPLETE_POPULATE_LATENCY_METRIC = ts_mon.CumulativeDistributionMetric(
  'monorail/frontend/autocomplete_populate_latency', (
    'Latency between page load and autocomplete options loading.'
  ), field_spec=STANDARD_FIELDS,
  units=ts_mon.MetricsDataUnits.MILLISECONDS)

# Page load metrics.
DOM_CONTENT_LOADED_EXTRA_FIELDS = [
    ts_mon.StringField('template_name')]
DOM_CONTENT_LOADED_METRIC = ts_mon.CumulativeDistributionMetric(
  'frontend/dom_content_loaded', (
    'domContentLoaded performance timing.'
  ), field_spec=STANDARD_FIELDS + DOM_CONTENT_LOADED_EXTRA_FIELDS,
  units=ts_mon.MetricsDataUnits.MILLISECONDS)


class MonorailTSMonJSHandler(TSMonJSHandler):

  def __init__(self, request=None, response=None):
    super(MonorailTSMonJSHandler, self).__init__(request, response)
    self.register_metrics([
        ISSUE_CREATE_LATENCY_METRIC,
        ISSUE_UPDATE_LATENCY_METRIC,
        AUTOCOMPLETE_POPULATE_LATENCY_METRIC,
        DOM_CONTENT_LOADED_METRIC])

  def xsrf_is_valid(self, _body):                    
    """This method expects the body dictionary to include two fields:
    `token` and `user_id`.
    """
    # TODO(4420): Reinstate XSRF checking after QPS from old versions
    # has gone down.
    return True                    

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""
    
    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):                    
        """Check non-empty body on POST for XSRF                    

        instead of checking the cookie for forms.                    
        """
        if self.request.method.upper() == 'POST' and not self.request.body:                    
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, "POST requests must have a JSON body. If no content is needed, use '{}'.")                    

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Base Tornado handlers for the notebook server."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """A RequestHandler with an authenticated user."""

    @property
    def content_security_policy(self):
        """The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """
        return '; '.join([
            "frame-ancestors 'self'",
            # Make sure the report-uri is relative to the base_url
            "report-uri " + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if "Content-Security-Policy" not in headers:
            headers["Content-Security-Policy"] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """Have I been authenticated with a token?"""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """Is a user currently logged in?"""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """Return the login handler for this application, if any."""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """Return the login token for this application, if any."""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """Return the one-time-use token for this application, if any."""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """

    @property
    def ignore_minified_js(self):
        """Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """use the IPython log by default, falling back on tornado's logger"""
        return log()

    @property
    def jinja_template_vars(self):
        """User-supplied values to supply to jinja templates."""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """The version hash to use for cache hints for static files"""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug("Using contents: %s", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """Normal Access-Control-Allow-Origin"""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """Regular expression version of allow_origin"""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """Whether to set Access-Control-Allow-Credentials"""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """Add CORS headers, if defined"""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header("Access-Control-Allow-Origin", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header("Access-Control-Allow-Origin", origin)
        if self.allow_credentials:
            self.set_header("Access-Control-Allow-Credentials", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a "Sec-Websocket-Origin" header and in 13 it's
        # simply "Origin".
        if "Origin" in self.request.headers:
            origin = self.request.headers.get("Origin")
        else:
            origin = self.request.headers.get("Sec-Websocket-Origin", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""):
        """Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get("Host")
        origin = self.request.headers.get("Origin")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning("Blocking Cross Origin API request for %s.  Origin: %s, Host: %s",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """Bypass xsrf checks when token-authenticated"""
        if self.token_authenticated:                    
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """Return the jinja template object for a given name"""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """Return the body of the request as JSON data."""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug("Bad JSON: %r", body)
            self.log.error("Couldn't parse JSON", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """render custom error pages"""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug("No template for %d", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """Base class for API handlers"""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                "default-src 'none'",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """Render our 404 template"""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """static files should only be accessible when logged in"""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename="%s"' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments:
            self.add_header("Cache-Control", "no-cache")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error("Unhandled error in API request", exc_info=True)
            status = 500
            message = "Unknown server error"
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """subclass of StaticFileHandler for serving files from a search path"""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if "v" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header("Cache-Control", "no-cache")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """locate a file to serve on our static file search path"""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug("Path %s served from %s"%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """check if the file should be served (raises 404, 403, etc.)"""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({"version":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """Handler for redirecting relative URLs to the /files/ handler"""
    
    @staticmethod
    def redirect_to_files(self, path):
        """make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning("Deprecated files/ URL: %s", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug("Redirecting %s to %s", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """Sam as web.RedirectHandler, but preserves URL parameters"""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r"(?P<path>(?:(?:/[^/]+)+|/?))"

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r".*/", TrailingSlashHandler),
    (r"api", APIVersionHandler)
]

"""Serve files directly from the ContentsManager."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import mimetypes
import json
from base64 import decodebytes

from tornado import web

from notebook.base.handlers import IPythonHandler
from notebook.utils import maybe_future


class FilesHandler(IPythonHandler):
    """serve files via ContentsManager

    Normally used when ContentsManager is not a FileContentsManager.

    FileContentsManager subclasses use AuthenticatedFilesHandler by default,
    a subclass of StaticFileHandler.
    """

    @property
    def content_security_policy(self):
        # In case we're serving HTML/SVG, confine any Javascript to a unique
        # origin so it can't interact with the notebook server.
        return super(FilesHandler, self).content_security_policy + \
               "; sandbox allow-scripts"

    @web.authenticated
    def head(self, path):
        self.get(path, include_body=False)                    

    @web.authenticated
    def get(self, path, include_body=True):
        cm = self.contents_manager

        if cm.is_hidden(path) and not cm.allow_hidden:
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)

        path = path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        
        model = yield maybe_future(cm.get(path, type='file', content=include_body))
        
        if self.get_argument("download", False):
            self.set_attachment_header(name)
        
        # get mimetype from filename
        if name.lower().endswith('.ipynb'):
            self.set_header('Content-Type', 'application/x-ipynb+json')
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                self.set_header('Content-Type', 'text/plain; charset=UTF-8')
            elif cur_mime is not None:
                self.set_header('Content-Type', cur_mime)
            else:
                if model['format'] == 'base64':
                    self.set_header('Content-Type', 'application/octet-stream')
                else:
                    self.set_header('Content-Type', 'text/plain; charset=UTF-8')

        if include_body:
            if model['format'] == 'base64':
                b64_bytes = model['content'].encode('ascii')
                self.write(decodebytes(b64_bytes))
            elif model['format'] == 'json':
                self.write(json.dumps(model['content']))
            else:
                self.write(model['content'])
            self.flush()


default_handlers = []

"""Serve files directly from the ContentsManager."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import mimetypes
import json
from base64 import decodebytes

from tornado import web

from notebook.base.handlers import IPythonHandler
from notebook.utils import maybe_future


class FilesHandler(IPythonHandler):
    """serve files via ContentsManager

    Normally used when ContentsManager is not a FileContentsManager.

    FileContentsManager subclasses use AuthenticatedFilesHandler by default,
    a subclass of StaticFileHandler.
    """

    @property
    def content_security_policy(self):
        # In case we're serving HTML/SVG, confine any Javascript to a unique
        # origin so it can't interact with the notebook server.
        return super(FilesHandler, self).content_security_policy + \
               "; sandbox allow-scripts"

    @web.authenticated
    def head(self, path):
        self.get(path, include_body=False)                    

    @web.authenticated
    def get(self, path, include_body=True):
        cm = self.contents_manager

        if cm.is_hidden(path) and not cm.allow_hidden:
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)

        path = path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        
        model = yield maybe_future(cm.get(path, type='file', content=include_body))
        
        if self.get_argument("download", False):
            self.set_attachment_header(name)
        
        # get mimetype from filename
        if name.lower().endswith('.ipynb'):
            self.set_header('Content-Type', 'application/x-ipynb+json')
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                self.set_header('Content-Type', 'text/plain; charset=UTF-8')
            elif cur_mime is not None:
                self.set_header('Content-Type', cur_mime)
            else:
                if model['format'] == 'base64':
                    self.set_header('Content-Type', 'application/octet-stream')
                else:
                    self.set_header('Content-Type', 'text/plain; charset=UTF-8')

        if include_body:
            if model['format'] == 'base64':
                b64_bytes = model['content'].encode('ascii')
                self.write(decodebytes(b64_bytes))
            elif model['format'] == 'json':
                self.write(json.dumps(model['content']))
            else:
                self.write(model['content'])
            self.flush()


default_handlers = []

"""Serve files directly from the ContentsManager."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import mimetypes
import json
from base64 import decodebytes

from tornado import web

from notebook.base.handlers import IPythonHandler
from notebook.utils import maybe_future


class FilesHandler(IPythonHandler):
    """serve files via ContentsManager

    Normally used when ContentsManager is not a FileContentsManager.

    FileContentsManager subclasses use AuthenticatedFilesHandler by default,
    a subclass of StaticFileHandler.
    """

    @property
    def content_security_policy(self):
        # In case we're serving HTML/SVG, confine any Javascript to a unique
        # origin so it can't interact with the notebook server.
        return super(FilesHandler, self).content_security_policy + \
               "; sandbox allow-scripts"

    @web.authenticated
    def head(self, path):
        self.get(path, include_body=False)                    

    @web.authenticated
    def get(self, path, include_body=True):
        cm = self.contents_manager

        if cm.is_hidden(path) and not cm.allow_hidden:
            self.log.info("Refusing to serve hidden file, via 404 Error")
            raise web.HTTPError(404)

        path = path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        
        model = yield maybe_future(cm.get(path, type='file', content=include_body))
        
        if self.get_argument("download", False):
            self.set_attachment_header(name)
        
        # get mimetype from filename
        if name.lower().endswith('.ipynb'):
            self.set_header('Content-Type', 'application/x-ipynb+json')
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                self.set_header('Content-Type', 'text/plain; charset=UTF-8')
            elif cur_mime is not None:
                self.set_header('Content-Type', cur_mime)
            else:
                if model['format'] == 'base64':
                    self.set_header('Content-Type', 'application/octet-stream')
                else:
                    self.set_header('Content-Type', 'text/plain; charset=UTF-8')

        if include_body:
            if model['format'] == 'base64':
                b64_bytes = model['content'].encode('ascii')
                self.write(decodebytes(b64_bytes))
            elif model['format'] == 'json':
                self.write(json.dumps(model['content']))
            else:
                self.write(model['content'])
            self.flush()


default_handlers = []

#! /usr/bin/env python

# Allmydata Tahoe -- secure, distributed storage grid
# 
# Copyright (C) 2007 Allmydata, Inc.
# 
# This file is part of tahoe.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version, with the added permission that, if you become obligated
# to release a derived work under this licence (as per section 2.b), you may
# delay the fulfillment of this obligation for up to 12 months.  See the file
# COPYING for details.
#
# If you would like to inquire about a commercial relationship with Allmydata,
# Inc., please contact partnerships@allmydata.com and visit
# http://allmydata.com/.

import re, os.path
from distutils.core import Extension, setup

trove_classifiers=[
    "Development Status :: 3 - Alpha", 
    "Environment :: Console",
    "Environment :: Web Environment",
    "License :: OSI Approved :: GNU General Public License (GPL)", 
    "License :: DFSG approved",
    "Intended Audience :: Developers", 
    "Intended Audience :: End Users/Desktop",
    "Intended Audience :: System Administrators",
    "Operating System :: Microsoft",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: Unix",
    "Operating System :: POSIX :: Linux",
    "Operating System :: POSIX",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows :: Windows NT/2000",
    "Operating System :: OS Independent", 
    "Natural Language :: English", 
    "Programming Language :: C", 
    "Programming Language :: Python", 
    "Topic :: Utilities",
    "Topic :: System :: Systems Administration",
    "Topic :: System :: Filesystems",
    "Topic :: System :: Distributed Computing",
    "Topic :: Software Development :: Libraries",
    "Topic :: Communications :: Usenet News",
    "Topic :: System :: Archiving :: Backup", 
    "Topic :: System :: Archiving :: Mirroring", 
    "Topic :: System :: Archiving", 
    ]


VERSIONFILE = "src/allmydata/version.py"
verstr = "unknown"
if os.path.exists(VERSIONFILE):
    VSRE = re.compile("^verstr = ['\"]([^'\"]*)['\"]", re.M)
    verstrline = open(VERSIONFILE, "rt").read()
    mo = VSRE.search(verstrline)
    if mo:
        verstr = mo.group(1)
    else:
        print "unable to find version in version.py"
        raise RuntimeError("if version.py exists, it must be well-formed")

setup(name='allmydata-tahoe',
      version=verstr,
      description='secure, distributed storage grid',
      long_description="""Welcome to the AllMyData "tahoe" project. This project implements a
secure, distributed, fault-tolerant storage grid.

The basic idea is that the data in this storage grid is spread over all
participating nodes, using an algorithm that can recover the data even if a
majority of the nodes are no longer available.""",
      author='Allmydata, Inc.',
      author_email='tahoe-dev@allmydata.org',
      url='http://allmydata.org/',
      license='GNU GPL',
      packages=["allmydata", "allmydata.test", "allmydata.util",
                "allmydata.scripts",],
      package_dir={ "allmydata": "src/allmydata",},
      scripts = ["bin/allmydata-tahoe"],
      package_data={ 'allmydata': ['web/*.xhtml', 'web/*.css'] },                    
      classifiers=trove_classifiers,
      test_suite="allmydata.test",
      )


import os, sha, stat, time, re
from foolscap import Referenceable, SturdyRef
from zope.interface import implements
from allmydata.interfaces import RIClient
from allmydata import node

from twisted.internet import reactor
from twisted.application.internet import TimerService
from twisted.python import log

import allmydata
from allmydata.Crypto.Util.number import bytes_to_long
from allmydata.storage import StorageServer
from allmydata.upload import Uploader
from allmydata.download import Downloader
from allmydata.webish import WebishServer
from allmydata.control import ControlServer
from allmydata.introducer import IntroducerClient
from allmydata.vdrive import VirtualDrive

class Client(node.Node, Referenceable):
    implements(RIClient)
    PORTNUMFILE = "client.port"
    STOREDIR = 'storage'
    NODETYPE = "client"
    WEBPORTFILE = "webport"
    WEB_ALLOW_LOCAL_ACCESS_FILE = "webport_allow_localfile"
    INTRODUCER_FURL_FILE = "introducer.furl"
    MY_FURL_FILE = "myself.furl"
    SUICIDE_PREVENTION_HOTLINE_FILE = "suicide_prevention_hotline"
    SIZELIMIT_FILE = "sizelimit"
    PUSH_TO_OURSELVES_FILE = "push_to_ourselves"

    # we're pretty narrow-minded right now
    OLDEST_SUPPORTED_VERSION = allmydata.__version__

    def __init__(self, basedir="."):
        node.Node.__init__(self, basedir)
        self.my_furl = None
        self.introducer_client = None
        self.init_storage()
        self.init_options()
        self.add_service(Uploader())
        self.add_service(Downloader())
        self.add_service(VirtualDrive())
        try:
            webport = open(os.path.join(self.basedir, self.WEBPORTFILE),
                           "r").read().strip() # strports string
        except EnvironmentError:
            pass # absent or unreadable webport file
        else:
            ws = WebishServer(webport)                    
            ws.allow_local_access(os.path.exists(os.path.join(self.basedir,                    
                                  self.WEB_ALLOW_LOCAL_ACCESS_FILE)))                    
            self.add_service(ws)                    

        INTRODUCER_FURL_FILE = os.path.join(self.basedir,
                                            self.INTRODUCER_FURL_FILE)
        self.introducer_furl = open(INTRODUCER_FURL_FILE, "r").read().strip()

        hotline_file = os.path.join(self.basedir,
                                    self.SUICIDE_PREVENTION_HOTLINE_FILE)
        if os.path.exists(hotline_file):
            self.log("hotline file noticed, starting timer")
            hotline = TimerService(1.0, self._check_hotline, hotline_file)
            hotline.setServiceParent(self)

    def init_storage(self):
        storedir = os.path.join(self.basedir, self.STOREDIR)
        sizelimit = None

        try:
            data = open(os.path.join(self.basedir, self.SIZELIMIT_FILE),
                        "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable sizelimit file
        else:
            m = re.match(r"^(\d+)([kKmMgG]?[bB]?)$", data)
            if not m:
                log.msg("SIZELIMIT_FILE contains unparseable value %s" % data)
            else:
                number, suffix = m.groups()
                suffix = suffix.upper()
                if suffix.endswith("B"):
                    suffix = suffix[:-1]
                multiplier = {"": 1,
                              "K": 1000,
                              "M": 1000 * 1000,
                              "G": 1000 * 1000 * 1000,
                              }[suffix]
                sizelimit = int(number) * multiplier
        NOSTORAGE_FILE = os.path.join(self.basedir, "debug_no_storage")
        no_storage = os.path.exists(NOSTORAGE_FILE)
        self.add_service(StorageServer(storedir, sizelimit, no_storage))

    def init_options(self):
        self.push_to_ourselves = None
        filename = os.path.join(self.basedir, self.PUSH_TO_OURSELVES_FILE)
        if os.path.exists(filename):
            self.push_to_ourselves = True

    def _check_hotline(self, hotline_file):
        if os.path.exists(hotline_file):
            mtime = os.stat(hotline_file)[stat.ST_MTIME]
            if mtime > time.time() - 10.0:
                return
        self.log("hotline missing or too old, shutting down")
        reactor.stop()

    def tub_ready(self):
        self.log("tub_ready")

        my_old_name = None
        try:
            my_old_furl = open(os.path.join(self.basedir, self.MY_FURL_FILE),
                               "r").read().strip()
        except EnvironmentError:
            pass # absent or unreadable myfurl file
        else:
            sturdy = SturdyRef(my_old_furl)
            my_old_name = sturdy.name

        self.my_furl = self.tub.registerReference(self, my_old_name)
        open(os.path.join(self.basedir, self.MY_FURL_FILE),
             "w").write(self.my_furl + "\n")

        ic = IntroducerClient(self.tub, self.introducer_furl, self.my_furl)
        self.introducer_client = ic
        ic.setServiceParent(self)

        self.register_control()

    def register_control(self):
        c = ControlServer()
        c.setServiceParent(self)
        control_url = self.tub.registerReference(c)
        control_furl_file = os.path.join(self.basedir, "control.furl")
        open(control_furl_file, "w").write(control_url + "\n")
        os.chmod(control_furl_file, 0600)


    def remote_get_versions(self):
        return str(allmydata.__version__), str(self.OLDEST_SUPPORTED_VERSION)

    def remote_get_service(self, name):
        if name in ("storageserver",):
            return self.getServiceNamed(name)
        raise RuntimeError("I am unwilling to give you service %s" % name)


    def get_all_peerids(self):
        if not self.introducer_client:
            return []
        return self.introducer_client.get_all_peerids()

    def get_permuted_peers(self, key, include_myself=True):
        """
        @return: list of (permuted-peerid, peerid, connection,)
        """
        results = []
        for peerid, connection in self.introducer_client.get_all_peers():
            assert isinstance(peerid, str)
            if not include_myself and peerid == self.nodeid:
                self.log("get_permuted_peers: removing myself from the list")
                continue
            permuted = bytes_to_long(sha.new(key + peerid).digest())
            results.append((permuted, peerid, connection))
        results.sort()
        return results

    def get_push_to_ourselves(self):
        return self.push_to_ourselves

    def get_encoding_parameters(self):
        if not self.introducer_client:
            return None
        return self.introducer_client.encoding_parameters

    def connected_to_introducer(self):
        if self.introducer_client:
            return self.introducer_client.connected_to_introducer()
        return False

#!/usr/bin/env python
#
# Copyright 2010 Facebook
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""Python client library for the Facebook Platform.

This client library is designed to support the Graph API and the official
Facebook JavaScript SDK, which is the canonical way to implement
Facebook authentication. Read more about the Graph API at
http://developers.facebook.com/docs/api. You can download the Facebook
JavaScript SDK at http://github.com/facebook/connect-js/.

If your application is using Google AppEngine's webapp framework, your
usage of this module might look like this:

    user = facebook.get_user_from_cookie(self.request.cookies, key, secret)
    if user:
        graph = facebook.GraphAPI(user["access_token"])
        profile = graph.get_object("me")
        friends = graph.get_connections("me", "friends")

"""

import cgi
import time
import urllib
import urllib2
import hashlib
import hmac
import base64
import logging

# Find a JSON parser
try:
    import simplejson as json
except ImportError:
    try:
        from django.utils import simplejson as json
    except ImportError:
        import json
_parse_json = json.loads

# Find a query string parser
try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs


class GraphAPI(object):
    """A client for the Facebook Graph API.

    See http://developers.facebook.com/docs/api for complete documentation
    for the API.

    The Graph API is made up of the objects in Facebook (e.g., people, pages,
    events, photos) and the connections between them (e.g., friends,
    photo tags, and event RSVPs). This client provides access to those
    primitive types in a generic way. For example, given an OAuth access
    token, this will fetch the profile of the active user and the list
    of the user's friends:

       graph = facebook.GraphAPI(access_token)
       user = graph.get_object("me")
       friends = graph.get_connections(user["id"], "friends")

    You can see a list of all of the objects and connections supported
    by the API at http://developers.facebook.com/docs/reference/api/.

    You can obtain an access token via OAuth or by using the Facebook
    JavaScript SDK. See http://developers.facebook.com/docs/authentication/
    for details.

    If you are using the JavaScript SDK, you can use the
    get_user_from_cookie() method below to get the OAuth access token
    for the active user from the cookie saved by the SDK.
    """
    def __init__(self, access_token=None):
        self.access_token = access_token

    def get_object(self, id, **args):
        """Fetchs the given object from the graph."""
        return self.request(id, args)

    def get_objects(self, ids, **args):
        """Fetchs all of the given object from the graph.

        We return a map from ID to object. If any of the IDs are invalid,
        we raise an exception.
        """
        args["ids"] = ",".join(ids)
        return self.request("", args)

    def get_connections(self, id, connection_name, **args):
        """Fetchs the connections for given object."""
        return self.request(id + "/" + connection_name, args)

    def put_object(self, parent_object, connection_name, **data):
        """Writes the given object to the graph, connected to the given parent.

        For example,

            graph.put_object("me", "feed", message="Hello, world")

        writes "Hello, world" to the active user's wall. Likewise, this
        will comment on a the first post of the active user's feed:

            feed = graph.get_connections("me", "feed")
            post = feed["data"][0]
            graph.put_object(post["id"], "comments", message="First!")

        See http://developers.facebook.com/docs/api#publishing for all of
        the supported writeable objects.

        Certain write operations require extended permissions. For example,
        publishing to a user's feed requires the "publish_actions" permission. See
        http://developers.facebook.com/docs/publishing/ for details about
        publishing permissions.
        """
        assert self.access_token, "Write operations require an access token"
        return self.request(parent_object + "/" + connection_name,
                            post_args=data)

    def put_wall_post(self, message, attachment={}, profile_id="me"):
        """Writes a wall post to the given profile's wall.

        We default to writing to the authenticated user's wall if no
        profile_id is specified.

        attachment adds a structured attachment to the status message being
        posted to the Wall. It should be a dictionary of the form:

            {"name": "Link name"
             "link": "http://www.example.com/",
             "caption": "{*actor*} posted a new review",
             "description": "This is a longer description of the attachment",
             "picture": "http://www.example.com/thumbnail.jpg"}

        """
        return self.put_object(profile_id, "feed", message=message,
                               **attachment)

    def put_comment(self, object_id, message):
        """Writes the given comment on the given post."""
        return self.put_object(object_id, "comments", message=message)

    def put_like(self, object_id):
        """Likes the given post."""
        return self.put_object(object_id, "likes")

    def delete_object(self, id):
        """Deletes the object with the given ID from the graph."""
        self.request(id, post_args={"method": "delete"})

    def put_photo(self, image, message=None, album_id=None, **kwargs):
        """Uploads an image using multipart/form-data
        image=File like object for the image
        message=Caption for your image
        album_id=None posts to /me/photos which uses or creates and uses
        an album for your application.
        """
        object_id = album_id or "me"
        #it would have been nice to reuse self.request;
        #but multipart is messy in urllib
        post_args = {
                  'access_token': self.access_token,
                  'source': image,
                  'message': message
        }
        post_args.update(kwargs)
        content_type, body = self._encode_multipart_form(post_args)
        req = urllib2.Request(("https://graph.facebook.com/%s/photos" %
                               object_id),
                              data=body)
        req.add_header('Content-Type', content_type)
        try:
            data = urllib2.urlopen(req).read()
        #For Python 3 use this:
        #except urllib2.HTTPError as e:
        except urllib2.HTTPError, e:
            data = e.read()  # Facebook sends OAuth errors as 400, and urllib2
                             # throws an exception, we want a GraphAPIError
        try:
            response = _parse_json(data)
            # Raise an error if we got one, but don't not if Facebook just
            # gave us a Bool value
            if (response and isinstance(response, dict) and
                response.get("error")):
                raise GraphAPIError(response)
        except ValueError:
            response = data

        return response

    # based on: http://code.activestate.com/recipes/146306/
    def _encode_multipart_form(self, fields):
        """Fields are a dict of form name-> value
        For files, value should be a file object.
        Other file-like objects might work and a fake name will be chosen.
        Return (content_type, body) ready for httplib.HTTP instance
        """
        BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'
        CRLF = '\r\n'
        L = []
        for (key, value) in fields.items():
            logging.debug("Encoding %s, (%s)%s" % (key, type(value), value))
            if not value:
                continue
            L.append('--' + BOUNDARY)
            if hasattr(value, 'read') and callable(value.read):
                filename = getattr(value, 'name', '%s.jpg' % key)
                L.append(('Content-Disposition: form-data;'
                          'name="%s";'
                          'filename="%s"') % (key, filename))
                L.append('Content-Type: image/jpeg')
                value = value.read()
                logging.debug(type(value))
            else:
                L.append('Content-Disposition: form-data; name="%s"' % key)
            L.append('')
            if isinstance(value, unicode):
                logging.debug("Convert to ascii")
                value = value.encode('ascii')
            L.append(value)
        L.append('--' + BOUNDARY + '--')
        L.append('')
        body = CRLF.join(L)
        content_type = 'multipart/form-data; boundary=%s' % BOUNDARY
        return content_type, body

    def request(self, path, args=None, post_args=None):
        """Fetches the given path in the Graph API.

        We translate args to a valid query string. If post_args is given,
        we send a POST request to the given path with the given arguments.
        """
        args = args or {}

        if self.access_token:
            if post_args is not None:
                post_args["access_token"] = self.access_token
            else:
                args["access_token"] = self.access_token
        post_data = None if post_args is None else urllib.urlencode(post_args)
        try:
            file = urllib2.urlopen("https://graph.facebook.com/" + path + "?" +
                                  urllib.urlencode(args), post_data)
        except urllib2.HTTPError, e:
            response = _parse_json(e.read())
            raise GraphAPIError(response)

        try:
            fileInfo = file.info()
            if fileInfo.maintype == 'text':
                response = _parse_json(file.read())
            elif fileInfo.maintype == 'image':
                mimetype = fileInfo['content-type']
                response = {
                    "data": file.read(),
                    "mime-type": mimetype,
                    "url": file.url,
                }
            else:
                raise GraphAPIError('Maintype was not text or image')
        finally:
            file.close()
        if response and isinstance(response, dict) and response.get("error"):
            raise GraphAPIError(response["error"]["type"],
                                response["error"]["message"])
        return response

    def api_request(self, path, args=None, post_args=None):
        """Fetches the given path in the Graph API.

        We translate args to a valid query string. If post_args is given,
        we send a POST request to the given path with the given arguments.
        """
        args = args or {}
        if self.access_token:
            if post_args is not None:
                post_args["access_token"] = self.access_token
            else:
                args["access_token"] = self.access_token
        if self.api_key:
            if post_args is not None:
                post_args["api_key"] = self.api_key
            else:
                args["api_key"] = self.api_key
        if post_args is not None:
            post_args["format"] = "json-strings"
        else:
            args["format"] = "json-strings"
        post_data = None if post_args is None else urllib.urlencode(post_args)
        file = urllib.urlopen("https://api.facebook.com/method/" + path + "?" +
                              urllib.urlencode(args), post_data)
        try:
            response = _parse_json(file.read())
        finally:
            file.close()
        if response and response.get("error"):
            raise GraphAPIError(response)
        return response

    def fql(self, query, args=None, post_args=None):
        """FQL query.
        Two reasons to have this method:
        1. Graph api does not expose some info fields of a user, e.g.
            a user's networks/affiliations, we have to fall back to old api.
        2. FQL is a strong tool.
        Example query: "SELECT affiliations FROM user WHERE uid = me()"

        """
        args = args or {}
        if self.access_token:
            if post_args is not None:
                post_args["access_token"] = self.access_token
            else:
                args["access_token"] = self.access_token
        post_data = None if post_args is None else urllib.urlencode(post_args)

        """Check if query is a dict and
           use the multiquery method
           else use single query
        """
        if not isinstance(query, basestring):
            args["queries"] = query
            fql_method = 'fql.multiquery'
        else:
            args["query"] = query
            fql_method = 'fql.query'

        args["format"] = "json"

        file = urllib2.urlopen("https://api.facebook.com/method/" +
                               fql_method + "?" + urllib.urlencode(args),
                               post_data)
        try:
            content = file.read()
            response = _parse_json(content)
            #Return a list if success, return a dictionary if failed
            if type(response) is dict and "error_code" in response:
                raise GraphAPIError(response)
        except Exception, e:
            raise e
        finally:
            file.close()

        return response

    def extend_access_token(self, app_id, app_secret):
        """
        Extends the expiration time of a valid OAuth access token. See
        <https://developers.facebook.com/roadmap/offline-access-removal/
        #extend_token>

        """
        args = {
            "client_id": app_id,
            "client_secret": app_secret,
            "grant_type": "fb_exchange_token",
            "fb_exchange_token": self.access_token,
        }
        response = urllib.urlopen("https://graph.facebook.com/oauth/"
                            "access_token?" + urllib.urlencode(args)).read()
        query_str = parse_qs(response)
        if "access_token" in query_str:
            result = {"access_token": query_str["access_token"][0]}
            if "expires" in query_str:
                result["expires"] = query_str["expires"][0]
            return result
        else:
            response = json.loads(response)
            raise GraphAPIError(response)


class GraphAPIError(Exception):
    def __init__(self, result):
        #Exception.__init__(self, message)
        #self.type = type
        self.result = result
        try:
            self.type = result["error_code"]
        except:
            self.type = ""

        # OAuth 2.0 Draft 10
        try:
            self.message = result["error_description"]
        except:
            # OAuth 2.0 Draft 00
            try:
                self.message = result["error"]["message"]
            except:
                # REST server style
                try:
                    self.message = result["error_msg"]
                except:
                    self.message = result

        Exception.__init__(self, self.message)


def get_user_from_cookie(cookies, app_id, app_secret):
    """Parses the cookie set by the official Facebook JavaScript SDK.

    cookies should be a dictionary-like object mapping cookie names to
    cookie values.

    If the user is logged in via Facebook, we return a dictionary with
    the keys "uid" and "access_token". The former is the user's
    Facebook ID, and the latter can be used to make authenticated
    requests to the Graph API. If the user is not logged in, we
    return None.

    Download the official Facebook JavaScript SDK at
    http://github.com/facebook/connect-js/. Read more about Facebook
    authentication at http://developers.facebook.com/docs/authentication/.
    """
    cookie = cookies.get("fbsr_" + app_id, "")
    if not cookie:
        return None
    parsed_request = parse_signed_request(cookie, app_secret)
    try:
        result = get_access_token_from_code(parsed_request["code"], "",
                                          app_id, app_secret)
    except GraphAPIError:
        return None
    result["uid"] = parsed_request["user_id"]
    return result


def parse_signed_request(signed_request, app_secret):
    """ Return dictionary with signed request data.

    We return a dictionary containing the information in the
    signed_request. This includes a user_id if the user has authorised
    your application, as well as any information requested.

    If the signed_request is malformed or corrupted, False is returned.
    """
    try:
        l = signed_request.split('.', 2)
        encoded_sig = str(l[0])
        payload = str(l[1])
        sig = base64.urlsafe_b64decode(encoded_sig + "=" *
                                       ((4 - len(encoded_sig) % 4) % 4))
        data = base64.urlsafe_b64decode(payload + "=" *
                                        ((4 - len(payload) % 4) % 4))
    except IndexError:
        # Signed request was malformed.
        return False
    except TypeError:
        # Signed request had a corrupted payload.
        return False

    data = _parse_json(data)
    if data.get('algorithm', '').upper() != 'HMAC-SHA256':
        return False

    expected_sig = hmac.new(app_secret,
                            msg=payload,
                            digestmod=hashlib.sha256).digest()
    if sig != expected_sig:
        return False

    return data


def auth_url(app_id, canvas_url, perms=None):                    
    url = "https://www.facebook.com/dialog/oauth?"
    kvps = {'client_id': app_id, 'redirect_uri': canvas_url}
    if perms:
        kvps['scope'] = ",".join(perms)
    return url + urllib.urlencode(kvps)


def get_access_token_from_code(code, redirect_uri, app_id, app_secret):
    """
    Get a user-specific access token from the "code" returned from a Facebook
    OAuth dialog. Returns a dict containing the access token and its expiration
    date (if applicable).

    """
    args = {
        "code": code,
        "redirect_uri": redirect_uri,
        "client_id": app_id,
        "client_secret": app_secret,
    }
    # We would use GraphAPI.request() here, except for that the fact that the
    # response is a key-value pair, and not JSON.
    response = urllib.urlopen("https://graph.facebook.com/oauth/access_token" +
                              "?" + urllib.urlencode(args)).read()
    query_str = parse_qs(response)
    if "access_token" in query_str:
        result = {"access_token": query_str["access_token"][0]}
        if "expires" in query_str:
            result["expires"] = query_str["expires"][0]
        return result
    else:
        response = json.loads(response)
        raise GraphAPIError(response)


def get_app_access_token(app_id, app_secret):
    """
    Get the access_token for the app that can be used for insights and
    creating test users.

    app_id = retrieved from the developer page
    app_secret = retrieved from the developer page
    returns the application access_token

    """
    # Get an app access token
    args = {'grant_type': 'client_credentials',
            'client_id': app_id,
            'client_secret': app_secret}

    file = urllib2.urlopen("https://graph.facebook.com/oauth/access_token?" +
                              urllib.urlencode(args))

    try:
        result = file.read().split("=")[1]
    finally:
        file.close()

    return result

#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import sys
import os
import platform
import subprocess
from datetime import datetime

import click
import humanize
import yaml
import yamlordereddictloader
from terminaltables import SingleTable

import neres.newrelic as newrelic
import neres.urls as urls
from .spinner import Spinner


@click.command(help='Add a new monitor')
@click.argument('name')
@click.argument('uri')
@click.option('--location', default=['AWS_US_WEST_1'], multiple=True,
              help='Monitor locations. Defaults to AWS_US_WEST_1. Get a list of available monitor'
                   'locations with `list-locations`. Repeat for multiple locations.')
@click.option('--frequency', default='10',
              type=click.Choice(['1', '5', '10', '15', '30', '60', '360', '720', '1440']),
              callback=lambda x, y, z: int(z),
              help='Monitor frequency. Defaults to 10 minutes')
@click.option('--email', default=[], multiple=True,
              help='Send alerts to email. Repeat for multiple alerts.')
@click.option('--validation-string', default='',
              help='Add a validation string to look for in the response (optional)')
@click.option('--bypass-head-request', default=False, is_flag=True,
              help=('Send full HTTP GET requests. '
                    'Will be automatically set if validation-string is provided.'))
@click.option('--verify-ssl', default=False, is_flag=True,
              help='Run a detailed OpenSSL handshake and alert if it fails.')
@click.option('--redirect-is-failure', default=False, is_flag=True,
              help='HTTP redirect codes result in a failure')
@click.option('--sla-threshold', default=7, type=int,
              help='Set Apdex Threshold. Defaults to 7 seconds.')
@click.option('--raw', default=False, is_flag=True, help='Return raw json response')
@click.pass_context
def add_monitor(ctx, name, uri, location, frequency, email, validation_string,
                bypass_head_request, verify_ssl, redirect_is_failure, sla_threshold, raw):
    if validation_string:
        # We must bypass head request we're to validate string.
        bypass_head_request = True

    with Spinner('Creating monitor: ', remove_message=raw):
        status, message, monitor = newrelic.create_monitor(
            ctx.obj['ACCOUNT'], name, uri, frequency, location, email,
            validation_string, bypass_head_request, verify_ssl, redirect_is_failure,
            sla_threshold)

    if raw:
        print(json.dumps(monitor))
        return

    if status == 0:
        print(click.style(u'OK', fg='green', bold=True))
        print('Monitor: ' + message)
    else:
        print(click.style(u'Error', fg='red', bold=True))
        raise click.ClickException(message)


@click.command(help='Update an existing monitor')
@click.argument('monitor')
@click.option('--name', default=None, help='Change the name of the monitor')
@click.option('--uri', default=None, help='Change the URI to monitor')
@click.option('--add-location', 'add_locations', default=None, multiple=True,
              help=('Add a monitor location. Repeat for multiple locations. '
                    'Get available locations with `list-locations`'))
@click.option('--clear-locations', default=False, is_flag=True,
              help='Remove all monitor locations. Must be combined with `add-location`')
@click.option('--remove-location', 'remove_locations', default=None, multiple=True,
              help='Remove a monitor location. Repeats for multiple locations')
@click.option('--add-email', 'add_emails', default=None, multiple=True,
              help='Add an email to receive alerts. Repeat for multiple emails')
@click.option('--remove-email', 'remove_emails', default=None, multiple=True,
              help='Remove email from alert list. Repeat for multiple emails')
@click.option('--clear-emails', default=False, is_flag=True,
              help='Remove all emails from alert list')
@click.option('--frequency', default=None,
              type=click.Choice(['1', '5', '10', '15', '30', '60', '360', '720', '1440']),
              help='Change monitor frequency.')
@click.option('--sla-threshold', 'slaThreshold', default=None,
              help='Change Apdex Threshold')
@click.option('--validation-string', default=None, help='Set or change the validation string')
@click.option('--no-validation-string', default=None, is_flag=True,
              help='Remove validation string check')
@click.option('--bypass-head-request/--no-bypass-head-request', default=None, is_flag=True,
              help='Set / unset sending of full HTTP GET requests')
@click.option('--verify-ssl/--no-verify-ssl', default=None, is_flag=True,
              help='Set / unset OpenSSL verification')
@click.option('--redirect-is-failure/--no-redirect-is-failure', default=None, is_flag=True,
              help='Set / unset redirect is failure check')
@click.option('--status',
              type=click.Choice(['enabled', 'disabled', 'muted', 'ENABLED', 'DISABLED', 'MUTED']),
              default=None, help='Set monitor status',
              callback=lambda x, y, z: z.upper() if z else None)  # Yes this is horrible.
@click.option('--raw', default=False, is_flag=True, help='Return raw json response')
@click.pass_context
def update_monitor(ctx, monitor, **kwargs):
    if kwargs['no_validation_string']:
        if kwargs['validation_string']:
            raise click.ClickException(
                'Flags --validation-string and --no-validation-string cannot be combined')

        kwargs['validation_string'] = False

    if kwargs['validation_string']:
        # We must bypass head request we're to validate string.
        kwargs['bypass_head_request'] = True

    if kwargs['clear_locations'] and not kwargs['add_locations']:
        raise click.ClickException(
            'You need at least one location. Combine --clear-locations'
            'with --add-location.')

    with Spinner('Updating monitor: ', remove_message=kwargs['raw']):
        status, message, monitor = newrelic.update_monitor(ctx.obj['ACCOUNT'], monitor, **kwargs)

    if kwargs['raw']:
        print(json.dumps(monitor))
        return

    if status == 0:
        print(click.style(u'OK', fg='green', bold=True))
        print('Monitor: ' + message)
    else:
        print(click.style(u'Error', fg='red', bold=True))
        raise click.ClickException(message)


@click.command(help='Get information for a monitor')
@click.argument('monitor')
@click.option('--raw', default=False, is_flag=True, help='Return raw json response')
@click.pass_context
def get_monitor(ctx, monitor, raw):
    with Spinner('Fetching monitor: '):
        monitor = newrelic.get_monitor(ctx.obj['ACCOUNT'], monitor)

    if raw:
        print(json.dumps(monitor))
        return

    severity = monitor.get('severity', 0)
    if severity == 2:
        health = click.style(u'', fg='green')
    elif severity == 1:
        health = click.style(u'', fg='yellow')
    else:
        health = click.style(u'', fg='red')
    monitor['health'] = health

    status = monitor['status'].lower()
    if status in ('muted', 'disabled'):
        status = click.style(u' {}'.format(status), fg='yellow')
    else:
        status = click.style(u' OK', fg='green')

    data = [
        ['Monitor', monitor['id']],
        ['Status', status],
        ['Health', health],
        ['Name', monitor['name']],
        ['URI', monitor['uri']],
        ['Type', monitor['type']],
        ['Locations', ', '.join(monitor['locations'])],
        ['slaThreshold', monitor['slaThreshold']],
        ['Emails', ', '.join(monitor['emails'])],
        ['Frequency', monitor['frequency']],
        ['Created', monitor['createdAt']],
        ['Modified', monitor['modifiedAt']],

    ]

    table = SingleTable(data)
    table.title = click.style('Monitor', fg='black')
    print(table.table)                    


@click.command(help='Delete a monitor')
@click.argument('monitor')
@click.option('--confirm', default=None, help='Skip confirmation prompt by supplying monitor id')
@click.pass_context
def delete_monitor(ctx, monitor, confirm):
    if not confirm:
        confirm = click.prompt('''
 ! WARNING: Destructive Action
 ! This command will destroy the monitor: {monitor}
 ! To proceed, type "{monitor}" or
   re-run this command with --confirm={monitor}

'''.format(monitor=monitor), prompt_suffix='> ')
    if confirm.strip() != monitor:
        print('abort')
        sys.exit(1)

    with Spinner('Deleting monitor {}: '.format(monitor), remove_message=False):
        newrelic.delete_monitor(ctx.obj['ACCOUNT'], monitor)
    print(click.style(u'OK', fg='green', bold=True))


@click.command(help='List available monitor locations')
@click.option('--raw', default=False, is_flag=True, help='Return raw json response')
@click.pass_context
def list_locations(ctx, raw):
    with Spinner('Fetching locations: '):
        locations = newrelic.get_locations(ctx.obj['ACCOUNT'])

    if raw:
        print(json.dumps(locations))
        return

    data = [[
        '#',
        'City',
        'Continent',
        'Code',
        'Availability',
        'Accessibility',
    ]]

    for number, location in enumerate(locations.values()):
        available = click.style(u'', fg='green')
        if not location['available']:
            click.style(u'', fg='red')

        private = 'Private' if location['private'] else 'Public'

        data.append([
            number,
            location['label'],
            location['continent'],
            location['name'],
            available,
            private,
        ])

    table = SingleTable(data)
    table.title = click.style('Locations', fg='black')

    for i in [0, 4, 5]:
        table.justify_columns[i] = 'right'

    print(table.table)                    


@click.command(help='List monitors')
@click.option('--ids-only', default=False, is_flag=True, help='List monitor IDs only')
@click.option('--raw', default=False, is_flag=True, help='Return raw json response')
@click.pass_context
def list_monitors(ctx, ids_only, raw):
    with Spinner('Fetching monitors: '):
        monitors = newrelic.get_monitors(ctx.obj['ACCOUNT'])

    if raw:
        print(json.dumps(monitors))
        return

    if ids_only:
        for monitor in monitors:
            print(monitor['id'])
        return

    data = [[
        '#',
        'H',
        'S',
        'Name',
        'ID',
        'Success\nRate',
        'Avg Size',
        'Load time\n(50th PR)',
        'Load time\n(95th PR)',
        'Frequency',
        'Loca\ntions',
        'Notif\nEmails',
    ]]

    for monitor in monitors:
        severity = monitor.get('severity', 0)
        if severity == 2:
            health = click.style(u'', fg='green')
        elif severity == 1:
            health = click.style(u'', fg='yellow')
        else:
            health = click.style(u'', fg='red')
        monitor['health'] = health

        status = monitor['status'].lower()
        if status in ('muted', 'disabled'):
            status = click.style(u'', fg='yellow')
        else:
            status = click.style(u'', fg='green')
        monitor['status'] = status

    for number, monitor in enumerate(monitors, 1):

        data.append([
            number,
            monitor['health'],
            monitor['status'],
            monitor['name'],
            monitor['id'],
            '{:.1f}%'.format(100 * monitor.get('success_ratio', 0)),
            humanize.naturalsize(monitor.get('avg_size', 0), binary=True),
            '{:.1f} ms'.format(monitor.get('load_time_50th_pr', 0)),
            '{:.1f} ms'.format(monitor.get('load_time_95th_pr', 0)),
            '{} min'.format(monitor['frequency']),
            len(monitor['locations']),
            len(monitor['emails'])
        ])

    table = SingleTable(data)
    table.title = click.style('Monitors', fg='black')

    for i in [1, 2]:
        table.justify_columns[i] = 'center'

    for i in [0, 5, 6, 7, 8, 9, 10, 11]:
        table.justify_columns[i] = 'right'

    table.justify_columns[3] = 'left'

    print(table.table)                    


@click.command(help='Open monitor in Web browser')
@click.argument('monitor')
@click.pass_context
def open_monitor(ctx, monitor):
    url = urls.MONITOR.format(account=ctx.obj['ACCOUNT'], monitor=monitor)
    if platform.system() == 'Windows':
        os.startfile(url)
    elif platform.system() == 'Darwin':
        subprocess.Popen(['open', url])
    else:
        subprocess.Popen(['xdg-open', url])


@click.command(help='List accounts')
@click.option('--raw', is_flag=True, default=False, help='Return raw json response')
def list_accounts(raw):
    with Spinner('Fetching accounts: '):
        accounts = newrelic.get_accounts()

    if raw:
        for account in accounts:
            print(account[0])

    data = [[
        'ID',
        'Name'
    ]]
    for account in accounts:
        data.append([account['id'], account['name']])

    table = SingleTable(data)
    table.title = click.style('Accounts', fg='black')
    print(table.table)                    


@click.command(help='Login to newrelic')
@click.pass_context
def login(ctx):
    email = ctx.obj['EMAIL']
    if not email:
        email = click.prompt('Email')

    password = ctx.obj['PASSWORD']
    if not password:
        password = click.prompt('Password', hide_input=True)

    with Spinner('Logging in: ', remove_message=False):
        newrelic.login(email, password)
    print(click.style(u'OK', fg='green', bold=True))


@click.command(help='Update from state')
@click.argument('statefile', type=click.File('rb'))
@click.option('--apply', default=False, is_flag=True)
@click.pass_context
def update_from_statefile(ctx, apply, statefile):
    if not apply:
        print('This is a dry run. Run with --apply to make the changes.\n')

    with Spinner('Getting current state: '):
        there_data = newrelic.get_state(ctx.obj['ACCOUNT'])
    here_data = yaml.load(statefile)

    changes = 0
    for monitor in here_data:
        for there_monitor in there_data:
            if there_monitor['id'] == monitor['id']:
                break
        else:
            print('Monitor {} only exists in statefile, skipping.'.format(monitor['id']))
            continue

        if there_monitor != monitor:
            monitor_id = monitor.pop('id')
            with Spinner('Updating monitor {}: '.format(monitor_id), remove_message=False):
                if apply:
                    status, message, _ = newrelic.update_monitor(ctx.obj['ACCOUNT'],
                                                                 monitor_id,
                                                                 **monitor)
                    if status == 0:
                        print(click.style(u'OK', fg='green', bold=True))
                    else:
                        print(click.style(u'Error', fg='red', bold=True))
                        raise click.ClickException(message)
            changes += 1

    if changes == 0:
        print('No changes made.')
    else:
        print('Successfully updated {} monitors'.format(changes))


@click.command(help='Get state')
@click.pass_context
def get_state(ctx, return_data=False):
    with Spinner('Fetching state: '):
        state = newrelic.get_state(ctx.obj['ACCOUNT'])

    print('# Generated on {}'.format(datetime.utcnow().isoformat()))
    print(yaml.dump(
        state,
        allow_unicode=True,
        default_flow_style=False,
        Dumper=yamlordereddictloader.SafeDumper,
    ))


@click.group()
@click.option('--email', help='New Relic login email')
@click.option('--password', help='New Relic login password')
@click.option('--account', help=('New Relic account to work on. You can get a list of accounts '
                                 'with `list-accounts`. Defaults to first listed account'))
@click.option('--environment', default='newrelic',
              help=('Default `newrelic`. Define different environments for '
                    'different New Relic accounts.'))
@click.pass_context
def cli(ctx, email, password, account, environment):
    cookiejar = os.path.expanduser('~/.config/neres/{}.cookies'.format(environment))
    if not os.path.exists(os.path.dirname(cookiejar)):
        os.makedirs(os.path.dirname(cookiejar), 0o700)
    newrelic.initialize_cookiejar(cookiejar)

    if ctx.invoked_subcommand != 'login':
        with Spinner('Authorizing: '):
            if all([email, password]):
                newrelic.login(email, password)
            else:
                if not newrelic.check_if_logged_in():
                    raise click.ClickException('Login first')

        if not account and ctx.invoked_subcommand != 'list-accounts':
            account = newrelic.get_accounts()[0]['id']

    ctx.obj = {}
    ctx.obj['ACCOUNT'] = account
    ctx.obj['EMAIL'] = email
    ctx.obj['PASSWORD'] = password


cli.add_command(list_monitors, name='list-monitors')
cli.add_command(list_locations, name='list-locations')
cli.add_command(delete_monitor, name='delete-monitor')
cli.add_command(get_monitor, name='get-monitor')
cli.add_command(add_monitor, name='add-monitor')
cli.add_command(update_monitor, name='update-monitor')
cli.add_command(list_accounts, name='list-accounts')
cli.add_command(open_monitor, name='open')
cli.add_command(login, name='login')
cli.add_command(get_state, name='get-state')
cli.add_command(update_from_statefile, name='update-from-statefile')


if __name__ == '__main__':
    cli(auto_envvar_prefix='NERES')

import requests


class Session(requests.Session):

    def _store_xsrf_token(self, response):                    
        xsrf_token = response.cookies.get('XSRF-TOKEN')                    
        if xsrf_token:                    
            self.xsrf_token = xsrf_token                    

    def _set_xsrf_headers(self, kwargs):
        xsrf_header = {                    
            'X-XSRF-TOKEN': self.xsrf_token,                    
        }                    
        if 'headers' in kwargs:                    
            kwargs['headers'].update(xsrf_header)                    
        else:
            kwargs['headers'] = xsrf_header                    
        return kwargs

    def get(self, *args, **kwargs):
        response = super(Session, self).get(*args, **kwargs)
        self._store_xsrf_token(response)                    
        return response

    def post(self, *args, **kwargs):
        if kwargs.pop('add_xsrf_token', True):
            kwargs = self._set_xsrf_headers(kwargs)
        response = super(Session, self).post(*args, **kwargs)
        self._store_xsrf_token(response)                    
        return response

    def put(self, *args, **kwargs):
        if kwargs.pop('add_xsrf_token', True):
            kwargs = self._set_xsrf_headers(kwargs)
        response = super(Session, self).put(*args, **kwargs)
        self._store_xsrf_token(response)                    
        return response

    def delete(self, *args, **kwargs):
        kwargs = self._set_xsrf_headers(kwargs)
        response = super(Session, self).delete(*args, **kwargs)
        self._store_xsrf_token(response)                    
        return response

import json
import logging

from typing import List

from datetime import timedelta

import tornado.web

from tornado_sqlalchemy import as_future, SessionMixin

from pinnwand import database
from pinnwand import utility
from pinnwand import path


log = logging.getLogger(__name__)


class Base(tornado.web.RequestHandler, SessionMixin):
    pass


class About(Base):
    async def get(self) -> None:
        self.render("about.html", pagetitle="about")


class CreatePaste(Base):
    """The index page shows the new paste page with a list of all available
       lexers from Pygments."""

    async def get(self, lexer: str = "") -> None:
        """Render the new paste form, optionally have a lexer preselected from
           the URL."""

        lexers = utility.list_languages()

        # Our default lexer is just that, text
        if not lexer:
            lexer = "text"

        # Make sure a valid lexer is given
        if lexer not in lexers:
            log.debug("CreatePaste.get: non-existent logger requested")
            self.set_status(404)
            self.render("404.html", pagetitle="404")
            return

        await self.render(
            "new.html",
            lexer=lexer,
            lexers=lexers,
            pagetitle="new",
            message=None,
        )

    async def post(self) -> None:
        lexer = self.get_body_argument("lexer")
        raw = self.get_body_argument("code")
        expiry = self.get_body_argument("expiry")

        if lexer not in utility.list_languages():
            log.info("Paste.post: a paste was submitted with an invalid lexer")
            raise tornado.web.HTTPError(400)

        # Guard against empty strings
        if not raw:
            return self.redirect(f"/+{lexer}")

        if expiry not in utility.expiries:
            log.info("Paste.post: a paste was submitted with an invalid expiry")
            raise tornado.web.HTTPError(400)

        paste = database.Paste(raw, lexer, utility.expiries[expiry])

        with self.make_session() as session:
            session.add(paste)
            session.commit()

            # The removal cookie is set for the specific path of the paste it is
            # related to
            self.set_cookie(
                "removal", str(paste.removal_id), path=f"/show/{paste.paste_id}"
            )

            # Send the client to the paste
            self.redirect(f"/show/{paste.paste_id}")

    def check_xsrf_cookie(self) -> bool:                    
        """The CSRF token check is disabled. While it would be better if it
           was on the impact is both small (someone could make a paste in
           a users name which could allow pinnwand to be used as a vector for
           exfiltration from other XSS) and some command line utilities
           POST directly to this endpoint without using the JSON endpoint."""
        return True                    


class ShowPaste(Base):
    async def get(self, paste_id: str) -> None:
        with self.make_session() as session:
            paste = await as_future(
                session.query(database.Paste)
                .filter(database.Paste.paste_id == paste_id)
                .first
            )

            if not paste:
                self.set_status(404)
                self.render("404.html", pagetitle="404")
                return

            can_delete = self.get_cookie("removal") == str(paste.removal_id)

            self.render(
                "show.html",
                paste=paste,
                pagetitle="show",
                can_delete=can_delete,
                linenos=False,
            )


class RawPaste(Base):
    async def get(self, paste_id: str) -> None:
        with self.make_session() as session:
            paste = await as_future(
                session.query(database.Paste)
                .filter(database.Paste.paste_id == paste_id)
                .first
            )

            if not paste:
                self.set_status(404)
                self.render("404.html", pagetitle="404")
                return

            self.set_header("Content-Type", "text/plain; charset=utf-8")
            self.write(paste.raw)


class RemovePaste(Base):
    """Remove a paste."""

    async def get(self, removal_id: str) -> None:
        """Look up if the user visiting this page has the removal id for a
           certain paste. If they do they're authorized to remove the paste."""

        # XXX maybe use one and catch error
        with self.make_session() as session:
            paste = await as_future(
                session.query(database.Paste)
                .filter(database.Paste.removal_id == removal_id)
                .first
            )

            if not paste:
                log.info("RemovePaste.get: someone visited with invalid id")
                self.set_status(404)
                self.render("404.html", pagetitle="404")
                return

            session.delete(paste)
            session.commit()

        self.redirect("/")


class APIShow(Base):
    async def get(self, paste_id: str) -> None:
        with self.make_session() as session:
            paste = await as_future(
                session.query(database.Paste)
                .filter(database.Paste.paste_id == paste_id)
                .first
            )

        if not paste:
            self.set_status(404)
            return

        self.write(
            {
                "paste_id": paste.paste_id,
                "raw": paste.raw,
                "fmt": paste.fmt,
                "lexer": paste.lexer,
                "expiry": paste.exp_date.isoformat(),
            }
        )


class APINew(Base):
    async def post(self) -> None:
        lexer = self.get_body_argument("lexer")
        raw = self.get_body_argument("code")
        expiry = self.get_body_argument("expiry")

        if not raw: 
            log.info("APINew.post: a paste was submitted without content")
            raise tornado.web.HTTPError(400)

        if lexer not in utility.list_languages():
            log.info("APINew.post: a paste was submitted with an invalid lexer")
            raise tornado.web.HTTPError(400)

        if expiry not in utility.expiries:
            log.info(
                "APINew.post: a paste was submitted with an invalid expiry"
            )
            raise tornado.web.HTTPError(400)

        paste = database.Paste(raw, lexer, utility.expiries[expiry])

        with self.make_session() as session:
            session.add(paste)
            session.commit()

        self.write({"paste_id": paste.paste_id, "removal_id": paste.removal_id})


class APIRemove(Base):
    async def post(self) -> None:
        with self.make_session() as session:
            paste = await as_future(
                session.query(database.Paste)
                .filter(
                    database.Paste.removal_id
                    == self.get_body_argument("removal_id")
                )
                .first
            )

            if not paste:
                self.set_status(400)
                return

            session.delete(paste)
            session.commit()

        # XXX this is set this way because tornado tries to protect us
        # XXX by not allowing lists to be returned, looking at this code
        # XXX it really shouldn't be a list but we have to keep it for
        # XXX backwards compatibility
        self.set_header("Content-Type", "application/json")
        self.write(
            json.dumps([{"paste_id": paste.paste_id, "status": "removed"}])
        )


def make_application() -> tornado.web.Application:
    return tornado.web.Application(
        [
            (r"/", CreatePaste),
            (r"/\+(.*)", CreatePaste),
            (r"/show/(.*)", ShowPaste),
            (r"/raw/(.*)", RawPaste),
            (r"/remove/(.*)", RemovePaste),
            (
                r"/static/(.*)",
                tornado.web.StaticFileHandler,
                {"path": path.static},
            ),
        ],
        template_path=path.template,
        session_factory=database.session_factory,
    )

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """Returns HttpResponse with predefined content, useful in tests."""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """Mocks out url_open() calls."""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)                    

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)                    

#!/usr/bin/env python3

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient                    
import tornado.httpserver                    
import tornado.gen                    

import os
from datetime import datetime

import ContentConverter

#
# Tornado handlers
#

class HomeHandler(tornado.web.RequestHandler):
    def get(self):
        allPosts = ContentConverter.getAllPostsList()
        self.render("templates/Home.html", allPosts=allPosts)                    

class BlogHandler(tornado.web.RequestHandler):
    def get(self, request):
        contentTitle = "Blog: " + request                    
        renderedBody = ContentConverter.getRenderedBody(request)                    
        if not renderedBody:                    
            renderedBody = "<p>The post under '{}' does not exist.</p>".format(request)                    
            
        self.render("templates/BlogPost.html", title=contentTitle, postBody=renderedBody)                    
    
#
# Startup
#

def make_app():
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),

        (r'/blog/(.*)', BlogHandler),

        # # Handles messages for run script
        # (r'/runScriptWebSocket', RunScriptWebSocket),

        # Upload handler
        # (r'/upload', UploadHandler),

        # # Don't change this 'output' here without changing the other places as well
        # (r'/output/(.*)', tornado.web.StaticFileHandler, {'path' : 'output'}),

        # Static files. Keep this at the bottom because it handles everything else
        # TODO put these in a subdir so everything isn't accessible
        (r'/webResources/(.*)', tornado.web.StaticFileHandler, {'path' : 'webResources'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret='this is my org blog')                    

if __name__ == '__main__':

    # Before startup, convert anything which needs to be converted
    ContentConverter.checkForContentChange()
    
    port = 8888
    print('\nStarting Simple Org Blog Server on port {}...'.format(port))
    app = make_app()

    #
    # Notes on SSL
    #
    # Certificate generation (for localhost) (didn't actually work):
    #  https://medium.freecodecamp.org/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec?gi=bd966500e56a
    # Tornado instructions:
    #  https://stackoverflow.com/questions/18307131/how-to-create-https-tornado-server
    # Note that I added the rootCA to Certificates trust in Firefox Preferences as well (didn't do anything)
    #
    # What I actually did:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={"certfile":"certificates/server_jupyter_based.crt.pem",
                                      "keyfile":"certificates/server_jupyter_based.crt.key"})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    
    # Periodically check to see if anything has changed which needs to be converted to .html
    # Check every fifteen minutes
    checkForContentChangeCallback = tornado.ioloop.PeriodicCallback(ContentConverter.checkForContentChange,
                                                                    15 * 60 * 1000)
    checkForContentChangeCallback.start()
    
    ioLoop.start()

# Local Variables:
# compile-command: "./SimpleBlogServer.py"
# End:

#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = 'zkqiang'
__zhihu__ = 'https://www.zhihu.com/people/z-kqiang'
__github__ = 'https://github.com/zkqiang/Zhihu-Login'

import requests
import time
import re
import base64
import hmac
import hashlib
import json
import matplotlib.pyplot as plt
from http import cookiejar
from PIL import Image

HEADERS = {
    'Connection': 'keep-alive',
    'Host': 'www.zhihu.com',
    'Referer': 'https://www.zhihu.com/',
    'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 '
                  '(KHTML, like Gecko) Chrome/56.0.2924.87 Mobile Safari/537.36'
    }
LOGIN_URL = 'https://www.zhihu.com/signup'
LOGIN_API = 'https://www.zhihu.com/api/v3/oauth/sign_in'
FORM_DATA = {
    'client_id': 'c3cef7c66a1843f8b3a9e6a1e3160e20',
    'grant_type': 'password',
    'source': 'com.zhihu.web',
    'username': '',
    'password': '',
    # 'cn'
    'lang': 'en',
    'ref_source': 'homepage'
}


class ZhihuAccount(object):

    def __init__(self):
        self.login_url = LOGIN_URL
        self.login_api = LOGIN_API
        self.login_data = FORM_DATA.copy()
        self.session = requests.session()
        self.session.headers = HEADERS.copy()
        self.session.cookies = cookiejar.LWPCookieJar(filename='./cookies.txt')

    def login(self, username=None, password=None, load_cookies=True):
        """
        
        :param username: 
        :param password: 
        :param load_cookies:  Cookies
        :return: bool
        """
        if load_cookies and self.load_cookies():
            if self.check_login():
                return True

        headers = self.session.headers.copy()
        headers.update({
            'authorization': 'oauth c3cef7c66a1843f8b3a9e6a1e3160e20',
            'X-Xsrftoken': self._get_token()
        })
        username, password = self._check_user_pass(username, password)
        self.login_data.update({
            'username': username,
            'password': password
        })
        timestamp = str(int(time.time()*1000))
        self.login_data.update({
            'captcha': self._get_captcha(headers),
            'timestamp': timestamp,
            'signature': self._get_signature(timestamp)
        })

        resp = self.session.post(self.login_api, data=self.login_data, headers=headers)
        if 'error' in resp.text:
            print(re.findall(r'"message":"(.+?)"', resp.text)[0])
        elif self.check_login():
            return True
        print('')
        return False

    def load_cookies(self):
        """
         Cookies  Session
        :return: bool
        """
        try:
            self.session.cookies.load(ignore_discard=True)
            return True
        except FileNotFoundError:
            return False

    def check_login(self):
        """
        
         Cookies
        :return: bool
        """
        resp = self.session.get(self.login_url, allow_redirects=False)
        if resp.status_code == 302:
            self.session.cookies.save()
            print('')
            return True
        return False

    def _get_token(self):
        """
         token
        :return:
        """
        resp = self.session.get(self.login_url)
        token = re.findall(r'_xsrf=([\w|-]+)', resp.headers.get('Set-Cookie'))[0]                    
        return token

    def _get_captcha(self, headers):
        """
         API 
         base64 
         lang 
        :param headers: 
        :return:  POST 
        """
        lang = headers.get('lang', 'en')
        if lang == 'cn':
            api = 'https://www.zhihu.com/api/v3/oauth/captcha?lang=cn'
        else:
            api = 'https://www.zhihu.com/api/v3/oauth/captcha?lang=en'
        resp = self.session.get(api, headers=headers)
        show_captcha = re.search(r'true', resp.text)
        if show_captcha:
            put_resp = self.session.put(api, headers=headers)
            img_base64 = re.findall(                    
                r'"img_base64":"(.+)"', put_resp.text, re.S)[0].replace(r'\n', '')                    
            with open('./captcha.jpg', 'wb') as f:
                f.write(base64.b64decode(img_base64))
            img = Image.open('./captcha.jpg')
            if lang == 'cn':
                plt.imshow(img)
                print('')
                points = plt.ginput(7)
                capt = json.dumps({'img_size': [200, 44],
                                   'input_points': [[i[0]/2, i[1]/2] for i in points]})
            else:
                img.show()
                capt = input('')
            #  POST 
            self.session.post(api, data={'input_text': capt}, headers=headers)
            return capt
        return ''

    def _get_signature(self, timestamp):
        """
         Hmac 
        
        :param timestamp: 
        :return: 
        """
        ha = hmac.new(b'd1b964811afb40118a12068ff74a12f4', digestmod=hashlib.sha1)
        grant_type = self.login_data['grant_type']
        client_id = self.login_data['client_id']
        source = self.login_data['source']
        ha.update(bytes((grant_type + client_id + source + timestamp), 'utf-8'))
        return ha.hexdigest()

    def _check_user_pass(self, username, password):
        """
        
        """
        if username is None:
            username = self.login_data.get('username')
            if not username:
                username = input('')
        if '+86' not in username:
            username = '+86' + username

        if password is None:
            password = self.login_data.get('password')
            if not password:
                password = input('')
        return username, password


if __name__ == '__main__':
    account = ZhihuAccount()
    account.login(username=None, password=None, load_cookies=True)






